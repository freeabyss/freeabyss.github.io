<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Abyss&#39;s blog</title>
  <subtitle>随笔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.freeabyss.com/"/>
  <updated>2017-02-25T12:53:29.000Z</updated>
  <id>http://blog.freeabyss.com/</id>
  
  <author>
    <name>Abyss</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Maven的自动部署配置</title>
    <link href="http://blog.freeabyss.com/2017/02/25/Maven-Maven%E7%9A%84%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.freeabyss.com/2017/02/25/Maven-Maven的自动部署配置/</id>
    <published>2017-02-25T12:51:51.000Z</published>
    <updated>2017-02-25T12:53:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>利用Maven的<code>tomcat7-maven-plugin</code>插件，可以仅仅使用一行命令就可以将项目部署到本地或者远程的Tomcat上。<br>插件的名称虽然带有<code>tomcat7</code>，但经过我实际测验Tomcat8中也可以使用。<br>完成自动部署需要两步，首先是Tomcat的配置，其次是pom文件的配置。 </p>
<h2 id="配置Tomcat"><a href="#配置Tomcat" class="headerlink" title="配置Tomcat"></a>配置Tomcat</h2><p> 在Tomcat目录下的<code>conf/tomcat-users.xml</code>文件中添加以下代码   </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager-gui"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager-script"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"password"</span> <span class="attr">roles</span>=<span class="string">"manager-script"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"password"</span> <span class="attr">roles</span>=<span class="string">"manager-gui"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p><code>username</code>和<code>password</code>可以随意更改。    </p>
<p>在<code>conf/context.xml</code>添加以下代码     </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">pathname</span>=<span class="string">"/manager"</span> <span class="attr">debug</span>=<span class="string">"0"</span> <span class="attr">privileged</span>=<span class="string">"true"</span> <span class="attr">docBase</span>=<span class="string">"$&#123;catalina.home&#125;/webapps/manager"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>在<code>conf/Catalina/localhost/</code>目录下创建<code>manager.xml</code>文件，并填充以下内容:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">privileged</span>=<span class="string">"true"</span> <span class="attr">antiResourceLocking</span>=<span class="string">"false"</span> <span class="attr">docBase</span>=<span class="string">"$&#123;catalina.home&#125;/webapps/manager"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.RemoteAddrValve"</span> <span class="attr">allow</span>=<span class="string">"^.*$"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></div></pre></td></tr></table></figure></p>
<ol>
<li>验证配置是否正确，启动Tomcat，打开浏览器，输入地址是<code>http://localhost:8080/manager/html</code>（假设Tomcat地址是<code>locahost:8080</code>）。然后输入<code>root</code>的登录名和密码，成功登入就说明配置成功。 <h2 id="配置pom-xml"><a href="#配置pom-xml" class="headerlink" title="配置pom.xml"></a>配置pom.xml</h2>在<code>pom.xml</code>文件中添加以下代码，如果是多模块项目，则在web模块所在的<code>pom.xml</code>添加。    </li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://serverip:port/manager/text<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">password</span>&gt;</span>password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">update</span>&gt;</span>true<span class="tag">&lt;/<span class="name">update</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">path</span>&gt;</span>/webapp<span class="tag">&lt;/<span class="name">path</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="启动部署"><a href="#启动部署" class="headerlink" title="启动部署"></a>启动部署</h2><p>第一次部署输入以下命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn tomcat7:deploy</div></pre></td></tr></table></figure>
<p>以后每次部署，可以输入以下命令 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn tomcat7:redeploy</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;利用Maven的&lt;code&gt;tomcat7-maven-plugin&lt;/code&gt;插件，可以仅仅使用一行命令就可以将项目部署到本地或者远程的
    
    </summary>
    
      <category term="Maven" scheme="http://blog.freeabyss.com/categories/Maven/"/>
    
    
      <category term="Java" scheme="http://blog.freeabyss.com/tags/Java/"/>
    
      <category term="Maven" scheme="http://blog.freeabyss.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 欧拉回路和哈密顿通路 34</title>
    <link href="http://blog.freeabyss.com/2017/02/25/Math-DM-34-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E5%92%8C%E5%93%88%E5%AF%86%E9%A1%BF%E9%80%9A%E8%B7%AF/"/>
    <id>http://blog.freeabyss.com/2017/02/25/Math-DM-34-欧拉回路和哈密顿通路/</id>
    <published>2017-02-25T08:31:37.000Z</published>
    <updated>2017-02-25T12:09:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h2><p>图$G$的欧拉回路是包含着$G$的每一条边的封闭路线。图$G$里的欧拉通路是包含着$G$的每一条边的路线。<br>欧拉回路和欧拉通路都是恰好包含图的每一条边且不重复，唯一的区别就是，欧拉回路回到原点，而欧拉通路不必回到原点。    </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;欧拉回路&quot;&gt;&lt;a href=&quot;#欧拉回路&quot; class=&quot;headerlink&quot; title=&quot;欧拉回路&quot;&gt;&lt;/a&gt;欧拉回路&lt;/h2&gt;&lt;p&gt;图$G$的欧拉回路是包含着$G$的每一条边的封闭路线。图$G$里的欧拉通路是包含着$G$的每一条边的路线。&lt;br&gt;欧拉回路和
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="graph" scheme="http://blog.freeabyss.com/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 图的连通性 33</title>
    <link href="http://blog.freeabyss.com/2017/02/25/Math-DM-33-%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7/"/>
    <id>http://blog.freeabyss.com/2017/02/25/Math-DM-33-图的连通性/</id>
    <published>2017-02-25T06:46:18.000Z</published>
    <updated>2017-02-25T08:31:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h2><h3 id="定义和相关术语"><a href="#定义和相关术语" class="headerlink" title="定义和相关术语"></a>定义和相关术语</h3><h4 id="无向图定义"><a href="#无向图定义" class="headerlink" title="无向图定义"></a>无向图定义</h4><p>设$n$是非负整数且$G$是无向图。在$G$中从$u$到$v$的长度为$n$<strong>路径</strong>是$G$的$n$条边$e_1,\dots,e_n$的序列，使得$f(e_1)=\{x_0,x_1\},f(e_2)=\{x_1,x_2\},\dots,f(e_n)=\{x_{n-1},x_n\}$，其中$x_0=u$而$x_n=v$。当这个图是简单图时，就用顶点序列$x_0,x_1,\dots,x_n$表示这条路径。<br>若一条路径在相同的顶点上开始和结束，即$u=v$且长度大于0，则它是一条<strong>封闭路径</strong>。<br>若通路径不包含重复的相同边，则它是<strong>路线</strong> 。<br>当没有必要区分多重边时，就用顶点序列$x_0,x_1,\dots,x_n$表示路径。<br>通路表示没有重复顶点的路径。       </p>
<blockquote>
<p>路径(walk)、通路(path)，、封闭路径(closed walk)、回路(circuit)、路线(trail)<br>上面定义的概念，有很多不同的术语， 因此需要注意以下几点： </p>
<ul>
<li>是否起始和终止于相同的顶点</li>
<li>是否有重复的相同边      </li>
<li>是否有重复的顶点   </li>
</ul>
</blockquote>
<h4 id="有向图定义"><a href="#有向图定义" class="headerlink" title="有向图定义"></a>有向图定义</h4><p>在有向图$G$中从$a$到$b$的一条路径是$G$中一条或多条边的序列$(x_0,x_1),(x_1,x_2),(x_2,x_3),\dots,(x_{n-1},x_n)$，其中$x_0=a,x_n=b$。</p>
<h3 id="无向图的连通性"><a href="#无向图的连通性" class="headerlink" title="无向图的连通性"></a>无向图的连通性</h3><p>若无向图每一对不同的顶点之间都有路径，则该图称为<strong>连通</strong>的。     </p>
<p>不连通的图是2个或2个以上连通子图之并，每一对子图都没有公共的顶点。这些不相交的连通子图称为图的连通分支。     </p>
<p>删除一个顶点和它所关联的边，就产生带有比原图更多的连通分支的子图。把这样的顶点称为割点。    </p>
<p>把一旦删除就产生带有比原图更多的连通分支的子图的边称为割边或桥。    </p>
<h4 id="连通无向图的每一对不同顶点之间都存在路线"><a href="#连通无向图的每一对不同顶点之间都存在路线" class="headerlink" title="连通无向图的每一对不同顶点之间都存在路线"></a>连通无向图的每一对不同顶点之间都存在路线</h4><p>证： 设$u$和$v$是连通无向图$G=(\mathbf V,\mathbf E)$的两个不同的顶点。因为$G$是连通的，所以$u$和$v$之间至少有1条路径。设$x_0,x_1,\dots,x_n$是长度最短的路径的顶点序列，其中$x_0=u$而$x_n=v$。这条长度最短的路径是路线。假设它不是路线，则对满足$0\le i\lt j$的某个$i$和$j$来说，有$x_i=x_j$。这意味着通过删除顶点序列$x_i,\dots,x_{j-1}$所对应的边，就获得了 带有顶点序列$x_0,x_1,\dots,x_{i-1},x_j,\dots,x_n$的从$u$到$v$的更短的路线。     </p>
<h3 id="有向图的连通性"><a href="#有向图的连通性" class="headerlink" title="有向图的连通性"></a>有向图的连通性</h3><p>在有向图里有两种连通性的概念。若任意两顶点之间都有路径，则该有向图是<strong>弱连通性</strong>的。若任意两顶点$a$和$b$，其中从$a$到$b$和从$b$到$a$都有路径，则该图是<strong>强连通性</strong>。    </p>
<p>$G$的子图是强连通图，则称为$G$的强连通分支或强分枝。    </p>
<h3 id="顶点之间的路径数"><a href="#顶点之间的路径数" class="headerlink" title="顶点之间的路径数"></a>顶点之间的路径数</h3><p>设$G$是带有相对于顶点顺序$v_1,v_2,\dots,v_n$的邻接矩阵$\mathbf A$的图（允许带有无向、有向、多重边、环）。从$v_i$到$v_j$的长度为$r$的不同路径数目等于$\mathb A^r$的第$(i,j)项，其中$r$是正整数。    </p>
<h2 id="路径和同构"><a href="#路径和同构" class="headerlink" title="路径和同构"></a>路径和同构</h2><p>有多种方式可以利用路径和封闭路径来帮助判定两个图是否同构。例如，具有特定长度的路线的存在性，就是一种可以用来证明两个图是不同构的有用的不变量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;连通性&quot;&gt;&lt;a href=&quot;#连通性&quot; class=&quot;headerlink&quot; title=&quot;连通性&quot;&gt;&lt;/a&gt;连通性&lt;/h2&gt;&lt;h3 id=&quot;定义和相关术语&quot;&gt;&lt;a href=&quot;#定义和相关术语&quot; class=&quot;headerlink&quot; title=&quot;定义和相关术语
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="graph" scheme="http://blog.freeabyss.com/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 图的同构 32</title>
    <link href="http://blog.freeabyss.com/2017/02/25/Math-DM-32-%E5%9B%BE%E7%9A%84%E5%90%8C%E6%9E%84/"/>
    <id>http://blog.freeabyss.com/2017/02/25/Math-DM-32-图的同构/</id>
    <published>2017-02-25T04:02:03.000Z</published>
    <updated>2017-02-25T06:46:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同构"><a href="#同构" class="headerlink" title="同构"></a>同构</h2><p>设$G_1=(\mathbf V_1,\mathbf E_1)$和$G_2=(\mathbf V_2,\mathbf E_2)$是简单图，若从$\mathbf V_1$到$\mathbf V_2$存在一对一的映射$f$，且$f$具有如下性质：对$\mathbf V_1$里的所有的$a$和$b$来说，$a$和$b$在$G_1$里相邻当且仅当$f(a)$和$f(b)$在$G_2$里相邻，就说$G_1$和$G_2$是同构的。这样的函数$f$称为同构。简单来讲，当两个简单图同构时，两个图的顶点之间具有保持相邻关系的一一对应。      </p>
<p>判断两个简单图是否同构常常是一件困难的事情。在两个带有$n$个顶点的简单图顶点集之间有$n!$钟可能的一一对应。若$n$太大，则通过检验每一种对应来看它是否保持相邻关系是不可能的。      </p>
<h3 id="判断同构的方法"><a href="#判断同构的方法" class="headerlink" title="判断同构的方法"></a>判断同构的方法</h3><p>同构的简单图必然具有相同的顶点数、边数和顶点的度，这些被称为同构下的不变量。这些量有任何不同，则两个图就不是同构的，不过即使，这些量都是相同的，也不一定意味着两个图同构。目前没有已知的用来判定简单是否同构的不变量集。    </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;同构&quot;&gt;&lt;a href=&quot;#同构&quot; class=&quot;headerlink&quot; title=&quot;同构&quot;&gt;&lt;/a&gt;同构&lt;/h2&gt;&lt;p&gt;设$G_1=(\mathbf V_1,\mathbf E_1)$和$G_2=(\mathbf V_2,\mathbf E_2)$是简单图，若
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="graph" scheme="http://blog.freeabyss.com/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 图的表示 31</title>
    <link href="http://blog.freeabyss.com/2017/02/23/Math-DM-31-%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
    <id>http://blog.freeabyss.com/2017/02/23/Math-DM-31-图的表示/</id>
    <published>2017-02-23T13:06:27.000Z</published>
    <updated>2017-02-23T13:48:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><p>图有很多种表示方式，本章介绍两种表示方法，一种是邻接表，一种是邻接矩阵。     </p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>邻接表可以用来表示不带多重边的图，它规定了每个顶点相邻的顶点       </p>
<h4 id="简单表的邻接表"><a href="#简单表的邻接表" class="headerlink" title="简单表的邻接表"></a>简单表的邻接表</h4><table>
<thead>
<tr>
<th style="text-align:left">顶点</th>
<th style="text-align:left">相邻的顶点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">b,c,e</td>
</tr>
<tr>
<td style="text-align:left">b</td>
<td style="text-align:left">a</td>
</tr>
<tr>
<td style="text-align:left">c</td>
<td style="text-align:left">a,d,e</td>
</tr>
<tr>
<td style="text-align:left">d</td>
<td style="text-align:left">c,e</td>
</tr>
<tr>
<td style="text-align:left">e</td>
<td style="text-align:left">a,c,d</td>
</tr>
</tbody>
</table>
<h4 id="有向图的邻接表"><a href="#有向图的邻接表" class="headerlink" title="有向图的邻接表"></a>有向图的邻接表</h4><table>
<thead>
<tr>
<th style="text-align:left">起点</th>
<th style="text-align:left">终点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">b,c,d,e</td>
</tr>
<tr>
<td style="text-align:left">b</td>
<td style="text-align:left">b,d</td>
</tr>
<tr>
<td style="text-align:left">c</td>
<td style="text-align:left">a,c,e</td>
</tr>
<tr>
<td style="text-align:left">d</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">e</td>
<td style="text-align:left">b,c,d</td>
</tr>
</tbody>
</table>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><h4 id="基于顶点的相邻关系"><a href="#基于顶点的相邻关系" class="headerlink" title="基于顶点的相邻关系"></a>基于顶点的相邻关系</h4><p>假设$G=(\mathbf V,\mathbf E)$是简单图，其中$\mid\mathbf V\mid=m$。假设把$G$的顶点任意地排列成$v_1,v_2,\dots,v_n$。对这个顶点表来说，$G$的邻接矩阵$\mathbf A$是一个$n\times n$的$0-1$矩阵，它满足这样的性质：当$v_i$和$v_j$相邻时第$(i,j)$项是1，当$v_i$和$v_j$不相邻时第$(i,j)$项是0。      </p>
<p>图的邻接矩阵依赖于所选择顶点的顺序。因此带$n$个顶点的图有$n!$个不同的邻接矩阵，因为$n$个顶点有$n!$个不同的顺序。     </p>
<p>邻接矩阵也可以用来表示带环和多重边的无向图。把顶点$a_i$上的环表示成邻接矩阵第$(i,i)$位置上1，当出现多重边时，第$(i,j)$项等于$\{a_i,a_j\}$关联的边数。包括多重图和伪图在内的所有无向图都具有对称的邻接矩阵。      </p>
<p>有向图的邻接矩阵不必是对称的，因为当从$a_i$到$a_j$有边时，从$a_j$到$a_i$可以没边。    </p>
<h4 id="关联矩阵"><a href="#关联矩阵" class="headerlink" title="关联矩阵"></a>关联矩阵</h4><p>设$G=(\mathbf V,\mathbf E)$是无向图。设$v_1,v_2,\dots, v_n$，是顶点而$e_1,e_2,\dots,e_n$是边。则相对于$\mathbf V$和$\mathbf E$的这个顺序的关联矩阵是$n\times m$矩阵$\mathbf M=[m_{ij}]$，其中$$m_{ij} =\begin{cases}1\qquad 当边e_j关联v_i时\\0\qquad 否则\end{cases}$$<br>关联矩阵示例：<br><img src="../images/graph_06.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图的表示&quot;&gt;&lt;a href=&quot;#图的表示&quot; class=&quot;headerlink&quot; title=&quot;图的表示&quot;&gt;&lt;/a&gt;图的表示&lt;/h2&gt;&lt;p&gt;图有很多种表示方式，本章介绍两种表示方法，一种是邻接表，一种是邻接矩阵。     &lt;/p&gt;
&lt;h3 id=&quot;邻接表&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="graph" scheme="http://blog.freeabyss.com/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>Mac-Mac下制作MacOS启动盘</title>
    <link href="http://blog.freeabyss.com/2017/02/10/Mac-Mac%E4%B8%8B%E5%88%B6%E4%BD%9CMacOS%E5%90%AF%E5%8A%A8%E7%9B%98/"/>
    <id>http://blog.freeabyss.com/2017/02/10/Mac-Mac下制作MacOS启动盘/</id>
    <published>2017-02-10T06:37:04.000Z</published>
    <updated>2017-02-10T06:41:43.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>从App Store中下载macOS Sierra，不需要安装</li>
<li></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;从App Store中下载macOS Sierra，不需要安装&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

    
    </summary>
    
      <category term="Mac" scheme="http://blog.freeabyss.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://blog.freeabyss.com/tags/Mac/"/>
    
      <category term="os" scheme="http://blog.freeabyss.com/tags/os/"/>
    
      <category term="tools" scheme="http://blog.freeabyss.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 关系的闭包 29</title>
    <link href="http://blog.freeabyss.com/2017/01/27/Math-DM-29-%E5%85%B3%E7%B3%BB%E7%9A%84%E9%97%AD%E5%8C%85/"/>
    <id>http://blog.freeabyss.com/2017/01/27/Math-DM-29-关系的闭包/</id>
    <published>2017-01-27T08:32:03.000Z</published>
    <updated>2017-02-23T12:57:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系的闭包"><a href="#关系的闭包" class="headerlink" title="关系的闭包"></a>关系的闭包</h2><p>一般来说，设$\mathbf R$是集合$\mathbf A$上的关系。$\mathbf R$可能具有或者不具有某些性质$\mathbf P$，例如自反性、对称性或传递性。如果存在包含$\mathbf R$的具有性质$\mathbf P$的关系$\mathbf S$，并且$\mathbf S$是包含$\mathbf R$且具有性质$\mathbf P$的每一个关系的子集，那么$\mathbf S$叫做$\mathbf R$的关于$\mathbf P$的闭包。</p>
<h3 id="构造闭包"><a href="#构造闭包" class="headerlink" title="构造闭包"></a>构造闭包</h3><h4 id="自反闭包"><a href="#自反闭包" class="headerlink" title="自反闭包"></a>自反闭包</h4><p>给定集合$\mathbf A$上的关系$\mathbf R$，对于$a\in\mathbf R$，可以通过把形如$(a,a)$的所有的对，除了已在$\mathbf R$中的之外，都加到$\mathbf R$中，就构成了$\mathbf R$的自反闭包。 </p>
<h4 id="对称闭包"><a href="#对称闭包" class="headerlink" title="对称闭包"></a>对称闭包</h4><p>$\mathbf R\cup\mathbf R^{-1}$是$\mathbf R$的对称闭包，其中$\mathbf R^{-1}=\{(b,a)\mid (a,b)\in\mathbf R\}$。     </p>
<h4 id="传递闭包"><a href="#传递闭包" class="headerlink" title="传递闭包"></a>传递闭包</h4><p>我们需要借助图来构造传递闭包，首先介绍几个关于图的术语。      </p>
<ol>
<li>在有向图$G$中从$a$到$b$的一条路径是$G$中一条或多条边的序列$(x_0,x_1),(x_1,x_2),(x_2,x_3),\dots,(x_{n-1},x_n)$，其中$x_0=a, x_n=b$。即一个边的序列，其中一条边的终点和路径中下一条边的始点相同。这条路记为$x_0,x_1,\dots,x_{n-1},x_n$，长度为$n$。    </li>
<li>在同一顶点开始和结束的路径叫做回路或圈。       </li>
<li>有向图的一条路径可以多次通过一个顶点。此外，有向图的一条边也可以多次出现在一条路径中。     </li>
<li>设$\mathbf R$是集合$\mathbf A$上的关系。从$a$到$b$存在一条长为$n$的路径，当且仅当$(a,b)\in\mathbf R$。      </li>
</ol>
<p>现在证明找一个关系的传递闭包与在相关的有向图中确定哪些顶点对被路径连接是等价的。由此要定义一个新的关系。<br>连通性关系:设$\mathbf R$是集合$\mathbf A$上的关系，连通性关系$\mathbf R^<em>$由对$(a,b)$构成，使得在$\mathbf R$中从顶点$a$到$b$之间存在一条至少长为1的路径。<br>因为$\mathbf R^n$由对$(a,b)$构成，使得存在一条从$a$到$b$的长为$n$的路径，从而$\mathbf R^</em>$是所有集合$\mathbf R^n$的并。即$$\mathbf R^<em>=\bigcup^\infty_{n=1}\mathbf R^n$$<br>关系$\mathbf R$的传递闭包等于连通性关系$\mathbf R^</em>$。     </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关系的闭包&quot;&gt;&lt;a href=&quot;#关系的闭包&quot; class=&quot;headerlink&quot; title=&quot;关系的闭包&quot;&gt;&lt;/a&gt;关系的闭包&lt;/h2&gt;&lt;p&gt;一般来说，设$\mathbf R$是集合$\mathbf A$上的关系。$\mathbf R$可能具有或者不具有某些
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="Relations" scheme="http://blog.freeabyss.com/tags/Relations/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 关系的表示 28</title>
    <link href="http://blog.freeabyss.com/2017/01/22/Math-DM-28-%E5%85%B3%E7%B3%BB%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
    <id>http://blog.freeabyss.com/2017/01/22/Math-DM-28-关系的表示/</id>
    <published>2017-01-22T11:25:37.000Z</published>
    <updated>2017-02-23T12:56:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系的表示"><a href="#关系的表示" class="headerlink" title="关系的表示"></a>关系的表示</h2><p>本文讨论用$0-1$矩阵和有向图的方式表示关系。    </p>
<h3 id="用矩阵表示关系"><a href="#用矩阵表示关系" class="headerlink" title="用矩阵表示关系"></a>用矩阵表示关系</h3><p>假设$\mathbf R$是从$\mathbf A=\{a_1,a_2,\dots,a_m\}$到$\mathbf B=\{b_1,b_2,\dots,b_n\}$的关系。关系$\mathbf R$可以用矩阵$\mathbf M_R=[m_{ij}]$来表示，其中<br>$$m_{ij}=\begin{cases}1\qquad 如果(a_i,a_j)\in\mathbf R\\0\qquad 如果(a_i,b_j)\notin\mathbf R\end{cases}$$该表示方式，依赖于$\mathbf A$和$\mathbf B$的使用的排序。<br>集合上的关系的矩阵是一个方阵，可以用矩阵来确定关系是否具有某种性质。<br>例如$\mathbf R=\{(2,1),(3,1),(3,2)\}$,关于$\mathbf R$的矩阵是$$\mathbf M_R=\begin{bmatrix}0&amp;0\\1&amp;0\\1&amp;1\end{bmatrix}$$   </p>
<h4 id="自反关系的矩阵"><a href="#自反关系的矩阵" class="headerlink" title="自反关系的矩阵"></a>自反关系的矩阵</h4><p>$\mathbf R$是自反的，当且仅当$i=1,2,\dots,n,m_i=1$。换句话说，如果$\mathbf M_R$的主对角线的所有元素都等于1，那么$\mathbf R$是自反的。    </p>
<h4 id="对称关系的矩阵"><a href="#对称关系的矩阵" class="headerlink" title="对称关系的矩阵"></a>对称关系的矩阵</h4><p>$\mathbf R$是对称的，当且仅当对所有的整数对$i，j$(其中$i=1,2,\dots,n, j=1,2,\dots,m$)都有$m_{ij}=m_{ji}$。也就是说$\mathbf R$是对称的当且仅当$\mathbf M_R=(\mathbf M_R)^t$</p>
<h4 id="反对称关系的矩阵"><a href="#反对称关系的矩阵" class="headerlink" title="反对称关系的矩阵"></a>反对称关系的矩阵</h4><p>$\mathbf R$是反对称的，当$i\neq j$时，$m_{ij}=0$或$m_{ji}=0$</p>
<h4 id="关系运算和矩阵"><a href="#关系运算和矩阵" class="headerlink" title="关系运算和矩阵"></a>关系运算和矩阵</h4><p>$$\mathbf M_{R_1\cup R_2}=\mathbf M_{R_1}\lor \mathbf M_{R_2}\\<br>\mathbf M_{R_1\cap R_2}=\mathbf M_{R_1}\land \mathbf M_{R_2}\\<br>\mathbf M_{R_1\cdot R_2}=\mathbf M_{R_1}\odot  \mathbf M_{R_2}\\$$</p>
<h3 id="用图表示关系"><a href="#用图表示关系" class="headerlink" title="用图表示关系"></a>用图表示关系</h3><p>一个有向图由顶点(或结点)集$V$和边(或弧)集$E$组成，其中边集是$V$中元素的有序对的集合。顶点$a$叫做边$(a,b)$的始点，而顶点$b$叫做这条边的终点。<br>形如$(a,a)$的边用一条从顶点$a$到自身的弧表示。这种边叫做环。<br>用图来表示关系，就是把集合的每个元素表示成一个点，每个有序对表示成一条弧，弧上的箭头标明了弧的方向。    </p>
<h4 id="用图来确定关系的性质"><a href="#用图来确定关系的性质" class="headerlink" title="用图来确定关系的性质"></a>用图来确定关系的性质</h4><ul>
<li>一个关系是自反的，当且仅当有向图的每个顶点都有环</li>
<li>一个关系是对称的，当且仅当有向图不同顶点之间的每一条边都存在一条方向相反的边</li>
<li>一个关系是反对称的，当且仅当在不同的两个顶点之间不存在两条方向相反的边</li>
<li>一个关系是传递的，当且仅当一条从顶点$x$到顶点$y$的边和一条顶点$y$到顶点$z$的边，就有一条从顶点$x$到顶点$z$的边(完成一个三角形，其中每条边都是具有正确方向的有向边)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关系的表示&quot;&gt;&lt;a href=&quot;#关系的表示&quot; class=&quot;headerlink&quot; title=&quot;关系的表示&quot;&gt;&lt;/a&gt;关系的表示&lt;/h2&gt;&lt;p&gt;本文讨论用$0-1$矩阵和有向图的方式表示关系。    &lt;/p&gt;
&lt;h3 id=&quot;用矩阵表示关系&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="Relations" scheme="http://blog.freeabyss.com/tags/Relations/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 关系及其性质 27</title>
    <link href="http://blog.freeabyss.com/2017/01/21/Math-DM-27-%E5%85%B3%E7%B3%BB%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/"/>
    <id>http://blog.freeabyss.com/2017/01/21/Math-DM-27-关系及其性质/</id>
    <published>2017-01-21T08:59:50.000Z</published>
    <updated>2017-01-27T08:46:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二元关系"><a href="#二元关系" class="headerlink" title="二元关系"></a>二元关系</h2><p>关系是一种结构，通常用元组来表示关系。<br>集合之间的关系，是集合间的笛卡儿积的一个子集。<br>设$\mathbf A$和$\mathbf B$是集合，一个从$\mathbf A$到$\mathbf B$的二元关系是$\mathbf A\times \mathbf B$的子集。<br>二元关系表示了两个集合的元素之间的关系。$n$元关系表示三个以上集合中元素之间的关系。    </p>
<h3 id="函数作为关系"><a href="#函数作为关系" class="headerlink" title="函数作为关系"></a>函数作为关系</h3><p>函数表示了这样一种关系，对于$\mathbf A$中的每个元素恰好只有一个$\mathbf B$中的元素与之相关。  </p>
<h3 id="集合的关系"><a href="#集合的关系" class="headerlink" title="集合的关系"></a>集合的关系</h3><p>集合的关系表示集合到它自身的关系。 例如，集合$\mathbf A$的关系是从$\mathbf A$到$\mathbf A$的关系。    </p>
<h4 id="集合关系的数量"><a href="#集合关系的数量" class="headerlink" title="集合关系的数量"></a>集合关系的数量</h4><p>因为集合$\mathbf A$上的关系是$\mathbf A\times \mathbf A$的子集，$n$个元素集合的笛卡儿积有$n^2$个元素，因此集合$\mathbf A$存在$2^{n^2}$个关系。    </p>
<h3 id="关系的性质"><a href="#关系的性质" class="headerlink" title="关系的性质"></a>关系的性质</h3><h4 id="自反"><a href="#自反" class="headerlink" title="自反"></a>自反</h4><p>如果对每个元素$a\in\mathbf A$有$(a,a)\in\mathbf R$，那么集合$\mathbf A$上的关系$\mathbf R$叫做自反的。    </p>
<h4 id="反自反"><a href="#反自反" class="headerlink" title="反自反"></a>反自反</h4><p>如果对于每个$a\in\mathbf A$，有$(a,a)\notin\mathbf R$,那么集合$\mathbf A$上的关系$\mathbf R$是反自反的，即没有$\mathbf A$中的元素与自己有关系，关系$\mathbf R$就是反自反的。</p>
<h4 id="对称"><a href="#对称" class="headerlink" title="对称"></a>对称</h4><p>对于$a,b\in\mathbf A$，如果只要$(a,b)\in\mathbf R$就有$(b,a)\in\mathbf R$，则集合$\mathbf A$上的关系$\mathbf R$叫做对称的。$a$和$b$可以是相等的。  </p>
<h4 id="非对称的"><a href="#非对称的" class="headerlink" title="非对称的"></a>非对称的</h4><p>如果$(a,b)\in\mathbf R$推出$(b,a)\notin\mathbf R$，关系$\mathbf R$叫做非对称的。  </p>
<h4 id="反对称"><a href="#反对称" class="headerlink" title="反对称"></a>反对称</h4><p>如果对$a,b\in\mathbf A$，仅当$a=b$时$(a,b)\in\mathbf R$和$(b,a)\in\mathbf R$，则集合$\mathbf A$上的关系$\mathbf R$叫做反对称的。<br>只要关系$\mathbf R$不存在这样的有序对:即由$a$和$b$构成，并且$a\neq b$，但是$(a,b)\in\mathbf R$和$(b,a)\in\mathbf R$。    </p>
<h4 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h4><p>如果对于$a,b,c\in\mathbf A，(a,b)\in\mathbf R$并且$(b,c)\in\mathbf R$则$(a,c)\in\mathbf R$，那么集合$\mathbf A$上的关系$\mathbf R$叫做传递的</p>
<h4 id="逆关系"><a href="#逆关系" class="headerlink" title="逆关系"></a>逆关系</h4><p>设$\mathbf R$是从集合$\mathbf A$到集合$\mathbf B$的关系。从$\mathbf B$到$\mathbf A$的逆关系是有序对的集合$\{(b,a)\mid (a,b)\in\mathbf R\}$，记作$\mathbf R^{-1}$。    </p>
<h4 id="补关系"><a href="#补关系" class="headerlink" title="补关系"></a>补关系</h4><p>补关系$\overline {\mathbf R}$是有序对的集合$\{(a,b)\mid (a,b)\notin\mathbf R\}$</p>
<h3 id="关系的组合"><a href="#关系的组合" class="headerlink" title="关系的组合"></a>关系的组合</h3><p>因为从$\mathbf A$到$\mathbf B$的关系是$\mathbf A\times\mathbf B$的子集，可以按照两个集合组合的任何方式来组合两个从$\mathbf A$到$\mathbf B$的关系。例如<br>$$\mathbf R_1\cup\mathbf  R_2 \\ \mathbf R_1\cap\mathbf R_2\\\mathbf R_1-\mathbf R_2\\\mathbf R_1\oplus\mathbf R_2$$<br>另一种组合方式类似于复函数。<br>设$\mathbf R$是从集合$\mathbf A$到集合$\mathbf B$的关系，$\mathbf S$是从集合$\mathbf B$到集合$\mathbf C$的关系。$\mathbf R$和$\mathbf S$的合成是由有序对$(a,c)$构成的关系，其中$a\in\mathbf A，c\in\mathbf C$，并且对于它们存在一个元素$b\in\mathbf B$使得$(a,b)\in\mathbf R$和$(b,c)\in\mathbf S$.我们用$\mathbf S\dots\mathbf R$表示$\mathbf R$和$\mathbf S$的合成。</p>
<h4 id="自身的合成"><a href="#自身的合成" class="headerlink" title="自身的合成"></a>自身的合成</h4><p>设$\mathbf R$是集合$\mathbf A$上的关系。幂$\mathbf R^n, n=1,2,3,\dots,$递归的定义为$$\mathbf R^1=\mathbf R\quad 和\quad \mathbf R^{n+1}=\mathbf R^n\cdot \mathbf R $$</p>
<h2 id="n元关系"><a href="#n元关系" class="headerlink" title="n元关系"></a>n元关系</h2><p>设$\mathbf A_1,\mathbf A_2,\dots ,\mathbf A_n$是集合。在这些集合上的$n$元关系是$\mathbf A_1\times\mathbf A_2\times\dots\times\mathbf A_n$的子集。这些集合$\mathbf A_1,\mathbf A_2,\dots,\mathbf A_n$叫做关系的域，$n$叫做它的阶。    </p>
<h3 id="n元关系运算"><a href="#n元关系运算" class="headerlink" title="n元关系运算"></a>n元关系运算</h3><h4 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h4><p>设$\mathbf R$是$n$元关系，$\mathbf C$是$\mathbf R$中元素可能满足的一个条件。那么选择运算$s_c$将$n$元关系$\mathbf R$映射到$\mathbf R$中满足条件$\mathbf C$的所有$n$元组构成的$n$元关系。    </p>
<h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>投影$\mathbf P_{i_1,i_2,\dots,i_m}$将$n$元组$(a_1,a_2,\dots,a_n)$映到$m$元组$(a_{i_1},a_{i_2},\dots,a_{i_m})$，其中$m\le n$。</p>
<h4 id="连接运算"><a href="#连接运算" class="headerlink" title="连接运算"></a>连接运算</h4><p>设$\mathbf R$是$m$元关系且$\mathbf S$是$n$元关系，其中$p\le m$和$p\le n$。连接$\mathbf J_p(\mathbf R,\mathbf S)$是$m+n-p$元关系，它包含了所有的$(m+n-p)$元组$(a_1,a_2,\dots,a_{m-p},c_1,c_2,\dots,c_p,b_1,b_2,\dots,b_{n-p})$，其中$m$元组(a_1,a_2,\dots,a_{m-p},c_1,c_2,\dots,c_p)$属于$\mathbf R$且$n$元组$(c_1,c_2,\dots,c_p,b_1,b_2,\dots,b_{n-p})$属于$\mathbf S$。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二元关系&quot;&gt;&lt;a href=&quot;#二元关系&quot; class=&quot;headerlink&quot; title=&quot;二元关系&quot;&gt;&lt;/a&gt;二元关系&lt;/h2&gt;&lt;p&gt;关系是一种结构，通常用元组来表示关系。&lt;br&gt;集合之间的关系，是集合间的笛卡儿积的一个子集。&lt;br&gt;设$\mathbf A$
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="Relations" scheme="http://blog.freeabyss.com/tags/Relations/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 最佳实践</title>
    <link href="http://blog.freeabyss.com/2017/01/17/JavaScript-JavaScript-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://blog.freeabyss.com/2017/01/17/JavaScript-JavaScript-最佳实践/</id>
    <published>2017-01-17T06:25:53.000Z</published>
    <updated>2017-01-18T07:48:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UI-松耦合"><a href="#UI-松耦合" class="headerlink" title="UI 松耦合"></a>UI 松耦合</h2><h3 id="将JavaScript从CSS中抽离"><a href="#将JavaScript从CSS中抽离" class="headerlink" title="将JavaScript从CSS中抽离"></a>将JavaScript从CSS中抽离</h3><p>IE8及更早版本的IE有一个特性，允许将JavaScript直接插入CSS中。虽然IE9已经不在支持这种特性，但应当注意不要在CSS中嵌入JavaScript代码</p>
<h3 id="将CSS从JavaScript中抽离"><a href="#将CSS从JavaScript中抽离" class="headerlink" title="将CSS从JavaScript中抽离"></a>将CSS从JavaScript中抽离</h3><p>所有的样式信息都应当保持在CSS中，当需要通过JavaScript来修改元素样式的时候，最佳方法是操作CSS的<code>className</code>。<br>有一种情形可以例外:当需要给页面中的元素作定位，使其相对于另外一个元素或整个页面重新定位。这种计算是无法在CSS中完成的。    </p>
<h3 id="将JavaScript从HTML中抽离"><a href="#将JavaScript从HTML中抽离" class="headerlink" title="将JavaScript从HTML中抽离"></a>将JavaScript从HTML中抽离</h3><ul>
<li>最好将所有的JavaScript代码都放入外置文件中，并在页面中通过<code>&lt;script&gt;</code>标签引用</li>
<li>在HTML页面中，禁止使用<code>on</code>属性挂载事件处理程序。应当使用方法来添加事件</li>
</ul>
<h3 id="将HTML从JavaScript中抽离"><a href="#将HTML从JavaScript中抽离" class="headerlink" title="将HTML从JavaScript中抽离"></a>将HTML从JavaScript中抽离</h3><p>尽量避免将HTML嵌入JavaScript代码中。</p>
<h2 id="避免使用全局变量"><a href="#避免使用全局变量" class="headerlink" title="避免使用全局变量"></a>避免使用全局变量</h2><p>全局变量和全局函数带来很多问题，例如命名冲突、代码脆弱性、难以测试、意外的bug。    </p>
<h3 id="零全局变量方式"><a href="#零全局变量方式" class="headerlink" title="零全局变量方式"></a>零全局变量方式</h3><p>如果你的代码运行时不需要于其他代码产生交互，可以使用零全局变量方式 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">win</span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line">    <span class="comment">// body</span></div><div class="line">&#125;(<span class="built_in">window</span>));</div></pre></td></tr></table></figure>
<p>如果项目中使用jQuery框架的话，一般用<code>jQuery</code>代替<code>window</code>。 </p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="隔离应用逻辑"><a href="#隔离应用逻辑" class="headerlink" title="隔离应用逻辑"></a>隔离应用逻辑</h3><p>将应用逻辑从事件处理程序中抽离出来有两点好处:一是可重用，二是方便测试。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> popup = <span class="built_in">document</span>.getElementById(<span class="string">"popup"</span>);</div><div class="line">    popup.style.left = event.clientX + <span class="string">"px"</span>;</div><div class="line">    popup.style.top = event.clientY + <span class="string">"px"</span>;</div><div class="line">    popup.className = <span class="string">"reveal"</span>;</div><div class="line">&#125;</div><div class="line">addListener(element, <span class="string">"click"</span>, handleClick);</div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">var</span> MyApplication = &#123;</div><div class="line">    handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.showPopup(event);</div><div class="line">    &#125;,</div><div class="line">    showPopup: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> popup = <span class="built_in">document</span>.getElementById(<span class="string">"popup"</span>);</div><div class="line">        popup.style.left = event.clientX + <span class="string">"px"</span>;</div><div class="line">        popup.style.top = event.clientY + <span class="string">"px"</span>;</div><div class="line">        popup.className = <span class="string">"reveal"</span>;        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">addListener(element, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    MyApplication.handleClick(event);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="不要分发事件"><a href="#不要分发事件" class="headerlink" title="不要分发事件"></a>不要分发事件</h3><p>上述实例代码还存在一个问题，即<code>event</code>被毫无节制地分发，应用逻辑不应当依赖于<code>event</code>对像，原因如下:      </p>
<ul>
<li>方法接口没有表明那些数据是必要的。好的API应该明确清楚表明回调传值的用处以及需要传那些值 </li>
<li>最重要的一点是，如果想测试这个方法，必须重新创建一个<code>event</code>对象并将它作为参数传入。</li>
</ul>
<p>最佳方法是让事件处理程序使用<code>event</code>对象来处理事件，然后拿到所有需要的数据传给应用逻辑。<br>另外，如果需要对<code>event</code>执行任何必要的操作，包括阻止默认事件或阻止事件冒泡，都应该直接包含在事件处理程序中。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyApplication = &#123;</div><div class="line">    handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        event.preventDefault();</div><div class="line">        event.stopPropagation();</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.showPopup(event.clientX, event.clientY);</div><div class="line">    &#125;,</div><div class="line">    showPopup: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> popup = <span class="built_in">document</span>.getElementById(<span class="string">"popup"</span>);</div><div class="line">        popup.style.left = x + <span class="string">"px"</span>;</div><div class="line">        popup.style.top = y +<span class="string">"px"</span>;</div><div class="line">        popup.className = <span class="string">"reveal"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="避免“空比较”"><a href="#避免“空比较”" class="headerlink" title="避免“空比较”"></a>避免“空比较”</h2><h3 id="检测原始值"><a href="#检测原始值" class="headerlink" title="检测原始值"></a>检测原始值</h3><p>如果你希望一个值是字符串、数字、布尔值或<code>undefined</code>，最佳选择是使用<code>typeof</code>运算符。<code>typeof</code>的独特之处在于，将其用于一个未声明的变量也不会报错。<br><code>null</code>一般不应用于检测语句，简单的和<code>null</code>比较通常不会包含足够的信息以判断值的类型是否合法。 但是如果所期望的值真的是<code>null</code>，则可以直接和<code>null</code>比较。这时应当使用<code>===</code>或<code>!==</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">"string"</span>) &#123;</div><div class="line">    anotherName = name.substirng(<span class="number">3</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> count === <span class="string">"number"</span>) &#123;</div><div class="line">    updateCount(count);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> found === <span class="string">"boolean"</span> &amp;&amp; found) &#123;</div><div class="line">    message(<span class="string">"Found!"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> MyApp === <span class="string">"undefined"</span>) &#123;</div><div class="line">    MyApp = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"><span class="comment">// null</span></div><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"my-div"</span>);</div><div class="line"><span class="keyword">if</span> (element !== <span class="literal">null</span>) &#123;</div><div class="line">    element.className = <span class="string">"found"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="检测引用值"><a href="#检测引用值" class="headerlink" title="检测引用值"></a>检测引用值</h3><ul>
<li>杜绝使用<code>typeof</code>检测<code>null</code>的类型，因为<code>typeof null</code>会返回<code>object</code></li>
<li>检测自定义类型或者内置类型可以使用<code>value instanceof Object</code>来判断，不过因为<code>instanceof</code>不仅检测对象的构造器，还检测原型链，因此使用时需注意 </li>
</ul>
<h3 id="检测函数"><a href="#检测函数" class="headerlink" title="检测函数"></a>检测函数</h3><p>检测函数最好的方法是使用<code>typeof</code>。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myFunc === <span class="string">"function"</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>检测数组最优雅的解决方案是:   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">"[object Array]"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式在识别内置对象时往往十分有用。<br>ECMAScript5 已经将<code>Array.isArray</code>正式引入JavaScript。</p>
<h3 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h3><ul>
<li>判断属性是否存在的最好办法是使用<code>in</code>运算符。<code>in</code>运算符仅仅简单的判断属性是否存在，而不会读取属性的值 </li>
<li><code>in</code>运算符同时会检测对象的原型，如果只想检测实例对象的某个属性是否存在，则使用<code>hasOwnProperty()</code>方法</li>
</ul>
<h2 id="将配置数据从代码中分离出来"><a href="#将配置数据从代码中分离出来" class="headerlink" title="将配置数据从代码中分离出来"></a>将配置数据从代码中分离出来</h2><p>配置数据示例:     </p>
<ul>
<li>URL</li>
<li>需要展现给用户的字符串</li>
<li>重复的值</li>
<li>设置(比如每页的配置项)</li>
<li>任何可能发生变更的值</li>
</ul>
<p>最好将配置数据抽离出来，可以放在文件最前面，或者单独一个文件。好处是不用修改JavaScript源码已、方便修改和防止漏改。   </p>
<h2 id="抛出自定义错误"><a href="#抛出自定义错误" class="headerlink" title="抛出自定义错误"></a>抛出自定义错误</h2><h3 id="抛出错误的方式"><a href="#抛出错误的方式" class="headerlink" title="抛出错误的方式"></a>抛出错误的方式</h3><p>抛出错误时，最好抛出<code>Error</code>类型对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Something bad happened'</span>);</div></pre></td></tr></table></figure>
<h3 id="抛出错误的好处"><a href="#抛出错误的好处" class="headerlink" title="抛出错误的好处"></a>抛出错误的好处</h3><p>抛出错误有助于调试，例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDivs</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (element &amp;&amp; element.getElementsByTagName) &#123;</div><div class="line">        <span class="keyword">return</span> element.getElementsByTagName(<span class="string">"div"</span>);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"getDivs() : Argument must be a DOM element."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="何时检查错误"><a href="#何时检查错误" class="headerlink" title="何时检查错误"></a>何时检查错误</h3><ul>
<li>如果一个函数被已知的实体调用，错误检查很可能没有必要，一般情况下该函数为私有函数</li>
<li>如果不能确定函数被调用的所有地方，则需要进行一些错误检查</li>
<li>抛出错误最佳的地方是在工具函数中  </li>
<li>一旦修复了一个很难调试的错误，尝试增加一两个自定义错误，当再次发生错误时，这将有助于更容易的解决问题</li>
<li>如果正在编写代码，思考一下: “我希望[某些事情]不会发生，如果发生，我的代码会一团糟糕”。这时，如果“某些事情”发生，就抛出一个错误</li>
<li>如果正在编写的代码别人也会使用，思考一下他们使用的方式在特定的情况下抛出错误</li>
<li>抛出错误的目的不是防止错误，而是在错误发生时能更加容易地调试</li>
</ul>
<h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><ul>
<li>可以用<code>instanceof</code>判断错误类型，从而处理特定的错误</li>
<li>自定义错误类型可以区别于浏览器抛出的错误</li>
<li>不要将<code>try-catch</code>中的<code>catch</code>块留空</li>
</ul>
<h2 id="直接量"><a href="#直接量" class="headerlink" title="直接量"></a>直接量</h2><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>禁止八进制直接量</p>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>以下场景应当使用<code>null</code></p>
<ul>
<li>用来初始化一个变量</li>
<li>用来和一个已初始化的变量比较</li>
<li>当函数的入参和返回值</li>
</ul>
<p>以下场景不应当使用<code>null</code>   </p>
<ul>
<li>不要使用<code>null</code>来检测是否传入了某个参数 </li>
<li>不要用<code>null</code>来检测一个未初始化的变量<br>理解<code>null</code>最好的方式是将它当作对象的占位符。    <h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3>避免在代码中使用<code>undefined</code>。  尤其不要将一个变量赋值为<code>undefined</code>。</li>
</ul>
<h3 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h3><p>推荐使用对象直接量的方式创建一个对象。    </p>
<h3 id="数组直接量"><a href="#数组直接量" class="headerlink" title="数组直接量"></a>数组直接量</h3><p>推荐使用数组直接量的方式创建数组</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>任何情况下，都不应该省略<code>default</code>语句。    </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UI-松耦合&quot;&gt;&lt;a href=&quot;#UI-松耦合&quot; class=&quot;headerlink&quot; title=&quot;UI 松耦合&quot;&gt;&lt;/a&gt;UI 松耦合&lt;/h2&gt;&lt;h3 id=&quot;将JavaScript从CSS中抽离&quot;&gt;&lt;a href=&quot;#将JavaScript从CSS中抽离&quot;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.freeabyss.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.freeabyss.com/tags/JavaScript/"/>
    
      <category term="effective" scheme="http://blog.freeabyss.com/tags/effective/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript编程风格</title>
    <link href="http://blog.freeabyss.com/2017/01/17/JavaScript-JavaScript-%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"/>
    <id>http://blog.freeabyss.com/2017/01/17/JavaScript-JavaScript-编程风格/</id>
    <published>2017-01-17T02:40:58.000Z</published>
    <updated>2017-01-17T07:12:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h2><h3 id="基本格式化"><a href="#基本格式化" class="headerlink" title="基本格式化"></a>基本格式化</h3><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>使用4个空格进行缩进     </p>
<h4 id="语句结尾"><a href="#语句结尾" class="headerlink" title="语句结尾"></a>语句结尾</h4><p>不要省略分号     </p>
<h4 id="长度限制"><a href="#长度限制" class="headerlink" title="长度限制"></a>长度限制</h4><p>每行的长度不要超过100字符  </p>
<h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>当需要换行时，最好在运算符后换行，下一行增加两个层级的缩进。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">callAFunction(<span class="built_in">document</span>, element, <span class="built_in">window</span>, <span class="string">"some string value"</span>, <span class="literal">true</span>, <span class="number">123</span>,</div><div class="line">        navigator);</div></pre></td></tr></table></figure>
<p>例外:当给变量赋值时，第二行的位置应当和赋值运算符的位置保持对齐，比如:      </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = something + anotherThing + yeAnotherTing + somethingElse + </div><div class="line">             anotherSomethingElse;</div></pre></td></tr></table></figure>
<h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><p>一般在以下场景中添加空行:      </p>
<ul>
<li>方法之间</li>
<li>方法中的局部变量和第一条语句之间</li>
<li>在多行或单行注释之前</li>
<li>在方法内的逻辑片段之间插入空行，提高可读性</li>
</ul>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ul>
<li>遵照小驼峰式大小写命名法，即由小写字母开始，后续每个单词首字母都大写   </li>
<li>变量尽量以名词作为前缀，函数以动词作为前缀  </li>
<li>尽量在变量名中体现出值的数据类型，例如<code>count</code>、<code>length</code>和<code>size</code>表明数据类型是数字，<code>name</code>、<code>title</code>和<code>message</code>表明数据类型是字符串</li>
<li>单个字符命名的变量，例如<code>i</code>、<code>j</code>和<code>k</code>通常在循环中使用   <h5 id="动词常见的约定"><a href="#动词常见的约定" class="headerlink" title="动词常见的约定"></a>动词常见的约定</h5>|动词| 含义|<br>|:–|:—|<br>|can| 函数返回一个布尔值|<br>|has| 函数返回一个布尔值|<br>|is | 函数返回一个布尔值|<br>|get| 函数返回一个非布尔值|<br>|set| 函数用来保存一个值|</li>
</ul>
<h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>使用大写字母和下划线 </p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>构造函数即前面冠以<code>new</code>运算符的函数，遵循大驼峰命名法，即以大写字母开始，后续每个单词首字母都大写。     </p>
<h4 id="直接量字符串使用双引号，主要是因为方便在Java和JavaScript之间来回切换。"><a href="#直接量字符串使用双引号，主要是因为方便在Java和JavaScript之间来回切换。" class="headerlink" title="直接量字符串使用双引号，主要是因为方便在Java和JavaScript之间来回切换。"></a>直接量字符串使用双引号，主要是因为方便在<code>Java</code>和<code>JavaScript</code>之间来回切换。</h4><p>禁止使用多行字符串，使用字符串连接符将字符串分成多份。     </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> longString = <span class="string">"Here's the sotry, of a man \</span></div><div class="line">named Brady";</div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">var</span> longString = <span class="string">"Here's the sotry, of a man "</span> +</div><div class="line">                 <span class="string">"named Brady"</span>;</div></pre></td></tr></table></figure>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h4 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h4><ul>
<li>独占一行的注释，用来解释下一行代码。这行注释之前总是有一个空行，且缩进层级和下一行代码保持一致</li>
<li>代码行尾部的注释。代码结束到注释之间至少有一个缩进。并且不应当超过单行最大字符数限制，如果超过了应该将注释放在代码行上方</li>
<li>单行注释不应该以连续多行注释的形式出现，除非你注释掉一大段代码</li>
</ul>
<h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4><ul>
<li>多行注释推荐使用<code>Java</code>的风格</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 这是一段多行注释</div><div class="line"> * 这段注释包含两行文本</div><div class="line"> */</div></pre></td></tr></table></figure>
<ul>
<li>多行注释和代码之间没有空行，注释上方应当有一行空行，并且缩进层级和下放的代码保持一致</li>
</ul>
<h4 id="使用注释"><a href="#使用注释" class="headerlink" title="使用注释"></a>使用注释</h4><ul>
<li>难于理解的代码通常都应当加注释</li>
<li>可能被误认为错误的代码，应当添加注释，防止被好心的开发者“修复”</li>
</ul>
<h2 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h2><p>无论何种情况下，所有块语句都应当使用花括号，包括:</p>
<ul>
<li>if…else</li>
<li>for</li>
<li>while</li>
<li>do…while</li>
<li>try…catch…finally</li>
</ul>
<h3 id="花括号的对齐方式"><a href="#花括号的对齐方式" class="headerlink" title="花括号的对齐方式"></a>花括号的对齐方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">    doSomething();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    doSomethingElse();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><h4 id="缩进-1"><a href="#缩进-1" class="headerlink" title="缩进"></a>缩进</h4><ul>
<li>每条<code>case</code>语句相对于<code>switch</code>关键字都缩进一个层级</li>
<li>从第二条<code>case</code>语句开始，每条<code>case</code>语句前后各有一个空行</li>
<li>连续的<code>case</code>语句之间省略空行</li>
<li><code>default</code>语句是必须的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (condition) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"first"</span>:</div><div class="line">         <span class="comment">// 代码</span></div><div class="line">         <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="string">"second"</span>:</div><div class="line">    <span class="keyword">case</span> <span class="string">"third"</span>:</div><div class="line">         <span class="comment">// 代码</span></div><div class="line">         <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>: </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="变量、函数和运算符"><a href="#变量、函数和运算符" class="headerlink" title="变量、函数和运算符"></a>变量、函数和运算符</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>推荐将局部变量的定义作为函数内第一条语句。 并且推荐使用单<code>var</code>语句风格，每个变量的初始化独占一行，没有初始值的变量放在<code>var</code>语句的尾部。 例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingWithItems</span>(<span class="params">items</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> value = <span class="number">10</span>,</div><div class="line">        result = value + <span class="number">10</span>,</div><div class="line">        i, len;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>, len=items.length; i&lt;len; i++) &#123;</div><div class="line">        doSomething(items[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><ul>
<li>推荐先声明函数，再使用</li>
<li>对于函数内的局部函数，应该紧接着变量声明之后声明，之间用空行隔开</li>
<li>函数声明禁止出现在<code>if</code>、<code>while</code>、<code>for</code>、<code>try...catch</code>、<code>switch</code>的语句块内</li>
</ul>
<h3 id="立即调用的函数"><a href="#立即调用的函数" class="headerlink" title="立即调用的函数"></a>立即调用的函数</h3><p>为了让立即执行的函数能够被一眼看出来，将函数用一对圆括号包裹起来。比如:    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> value = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 函数体</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        message: <span class="string">"Hi"</span></div><div class="line">    &#125;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>最好不要在全局作用域使用<code>&quot;use strict&quot;</code>。 如果你将多个文件连接合并成一个文件时，当期中一个文件在全局作用域中启用了严格模式，则所有的代码都将以严格模式解析，这会很可能造成其他以非严格模式写的代码报错。     </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// code </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line">    <span class="comment">// code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>推荐所有函数中都加上<code>&quot;use strict&quot;</code>。 </p>
<h3 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h3><p>因为强制类型转换的缘故，推荐使用<code>===</code>和<code>!==</code>，而不要使用<code>==</code>和<code>!=</code>。</p>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><ul>
<li>尽量避免使用<code>eval()</code>，如果无它法，尽量在严格模式下使用<code>eval()</code></li>
<li>严禁使用<code>Function</code> </li>
<li>可以使用<code>setTimeout()</code>和<code>setInterval()</code>，但不要用字符串形式，要用函数</li>
</ul>
<h3 id="原始包装类型"><a href="#原始包装类型" class="headerlink" title="原始包装类型"></a>原始包装类型</h3><p>禁止使用原始包装类型</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编程风格&quot;&gt;&lt;a href=&quot;#编程风格&quot; class=&quot;headerlink&quot; title=&quot;编程风格&quot;&gt;&lt;/a&gt;编程风格&lt;/h2&gt;&lt;h3 id=&quot;基本格式化&quot;&gt;&lt;a href=&quot;#基本格式化&quot; class=&quot;headerlink&quot; title=&quot;基本格式化&quot;&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.freeabyss.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.freeabyss.com/tags/JavaScript/"/>
    
      <category term="style guideline" scheme="http://blog.freeabyss.com/tags/style-guideline/"/>
    
  </entry>
  
  <entry>
    <title>Windows 10 快速安装.NET 3.5</title>
    <link href="http://blog.freeabyss.com/2017/01/16/Window-Windows-10-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85-NET-3-5/"/>
    <id>http://blog.freeabyss.com/2017/01/16/Window-Windows-10-快速安装-NET-3-5/</id>
    <published>2017-01-16T03:49:25.000Z</published>
    <updated>2017-02-10T06:36:21.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>加载windows 10镜像文件到光驱</li>
<li>按<code>Win</code>+<code>X</code>，选择’命令提示符(管理员)’ </li>
<li>输入以下命令，其中<code>D:</code>代表光驱盘符 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dism.exe /online /enable-feature /featurename:netfx3 /Source:D:\sources\sxs</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;加载windows 10镜像文件到光驱&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;Win&lt;/code&gt;+&lt;code&gt;X&lt;/code&gt;，选择’命令提示符(管理员)’ &lt;/li&gt;
&lt;li&gt;输入以下命令，其中&lt;code&gt;D:&lt;/code&gt;代表光驱盘符 &lt;figure class
    
    </summary>
    
      <category term="windows" scheme="http://blog.freeabyss.com/categories/windows/"/>
    
    
      <category term="os" scheme="http://blog.freeabyss.com/tags/os/"/>
    
      <category term="tools" scheme="http://blog.freeabyss.com/tags/tools/"/>
    
      <category term="windows" scheme="http://blog.freeabyss.com/tags/windows/"/>
    
      <category term=".net" scheme="http://blog.freeabyss.com/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>幻方介绍</title>
    <link href="http://blog.freeabyss.com/2017/01/15/Math-01-%E5%B9%BB%E6%96%B9/"/>
    <id>http://blog.freeabyss.com/2017/01/15/Math-01-幻方/</id>
    <published>2017-01-15T10:10:55.000Z</published>
    <updated>2017-01-21T09:06:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="幻方"><a href="#幻方" class="headerlink" title="幻方"></a>幻方</h2><p>幻方是一种将数字安排在正方形格子中，使每行、列和对角线上的数字和都相等的方法。<br>通常幻方由从$1$到$n^2$的连续整数组成。其中$n$为正方形的行或列的数目。因此$n$阶幻方有$n$行$n$列。<br>幻和是幻方各行、各列、各对角线上所有数的和。幻和的公式: $$s={n(n^2+1)\over 2}$$</p>
<h3 id="幻方的数量"><a href="#幻方的数量" class="headerlink" title="幻方的数量"></a>幻方的数量</h3><h3 id="幻方生成方法"><a href="#幻方生成方法" class="headerlink" title="幻方生成方法"></a>幻方生成方法</h3><h4 id="奇数阶幻方构造法"><a href="#奇数阶幻方构造法" class="headerlink" title="奇数阶幻方构造法"></a>奇数阶幻方构造法</h4><ul>
<li>把$1$放置在第一行的中间    </li>
<li>顺序将$2、3、\dots$等数放在右上方格子中。</li>
<li>当右上方格出界的时候，则由另一方进入。 </li>
<li>当右上方格中已经填有数，则把数填入正下方的方格中。</li>
<li>按照以上步骤直到填完所有$n^2$个方格。      <h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5>以$5$阶幻方为例<br>第一行中间格填 1，从这个格子开始，向右上方按顺序填充。如果超出了第一行，则填到最底下一行；如果超出了最右边一列，则填到最左边一列<br><img src="../images/magic_0.jpg" alt="阶乘图"><br>如果遇到下一个格子里已经有数字的，就填到当前格子的下方<br><img src="../images/magic_1.jpg" alt="阶乘图"><br>按照上面两条规则继续填充<br><img src="../images/magic_2.jpg" alt="阶乘图"></li>
</ul>
<h4 id="4m阶幻方构造法"><a href="#4m阶幻方构造法" class="headerlink" title="4m阶幻方构造法"></a>4m阶幻方构造法</h4><ul>
<li>将所有格子划分为$2m\times 2m$的小幻方，给每个小幻方画上对角线。      </li>
<li>从第一行第一列开始，从左往右，从上到下，从$1$到$(4m)^2$。依次填充。规则是只填充没对角线经过的格子。</li>
<li>从最后一行最后一列开始，从右到左，从下到上，从$1$到$(4m)^2$依次填充。规则是只填充对角线经过的格子。 </li>
</ul>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>以$8$阶幻方为例，将其分成$4$个$4\times 4$个小幻方，每个小幻方画上对角线。<br><img src="../images/magic_3.jpg" alt="阶乘图"><br>从第一行第一列，从左到右，从上到下，从$1$到$64$，依次填充，跳过对角线经过的格子<br><img src="../images/magic_4.jpg" alt="阶乘图"><br>从最后一行最后一列，从右到左，从下到上，从$1$到$64$，依次添加，跳过对角线没有经过的格子，忽略已经填过的数字<br><img src="../images/magic_5.jpg" alt="阶乘图">      </p>
<h4 id="4m-2阶幻方构造法"><a href="#4m-2阶幻方构造法" class="headerlink" title="4m+2阶幻方构造法"></a>4m+2阶幻方构造法</h4><ul>
<li>将格子分成$4$个等大的象限。      </li>
<li>按照$A\rightarrow D\rightarrow B\rightarrow C$的顺序，把四个部分按照奇数阶幻方的顺序填充起来。      </li>
<li>从$A$象限的中间行中间列开始为第一格，往右标出$m$格。然后标出$A$象限其他行的左边$m$列。把$A$象限作出标记的格子跟$C$象限对应的格子对换。     </li>
<li>从$B$象限的中间列开始，向左标出$m-1$列，与$D$象限对换。</li>
</ul>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><p>以$6$阶幻方为例。<br>把格子分成$4$个等大的象限<br><img src="../images/magic_6.jpg" alt="阶乘图"><br>按照$A\rightarrow D\rightarrow B\rightarrow C$的顺序，把四个部分按照奇数阶幻方的顺序填充起来。<br><img src="../images/magic_7.jpg" alt="阶乘图"><br>标出需要互换的格子，因为$m-1=0$所以$B、D$象限不需要互换<br><img src="../images/magic_8.jpg" alt="阶乘图">      </p>
<p>如果是$14$阶幻方，需要对换的格子如下图所示<br><img src="../images/magic_9.jpg" alt="阶乘图">      </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;幻方&quot;&gt;&lt;a href=&quot;#幻方&quot; class=&quot;headerlink&quot; title=&quot;幻方&quot;&gt;&lt;/a&gt;幻方&lt;/h2&gt;&lt;p&gt;幻方是一种将数字安排在正方形格子中，使每行、列和对角线上的数字和都相等的方法。&lt;br&gt;通常幻方由从$1$到$n^2$的连续整数组成。其中$n
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 递推关系</title>
    <link href="http://blog.freeabyss.com/2017/01/11/Math-DM-26-%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB/"/>
    <id>http://blog.freeabyss.com/2017/01/11/Math-DM-26-递推关系/</id>
    <published>2017-01-11T13:00:45.000Z</published>
    <updated>2017-01-21T09:06:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h2><p>对于递归定义，这个从某些前项求后项的规则就叫做递推关系。<br>关于序列$\{a_n\}$的递推关系是一个等式，它把$a_n$用序列中在$a_n$前面的一项或多项即$a_0,a_1,\dots,a_{n-1}$来表示，这里$n\ge n_0$，$n_0$是一个非负整数。如果一个序列的项满足递推关系，这个序列就叫做递推关系的解。     </p>
<h3 id="用递推关系构造模型"><a href="#用递推关系构造模型" class="headerlink" title="用递推关系构造模型"></a>用递推关系构造模型</h3><h4 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h4><p>令$H_n$表示解$n$个盘子的汉诺塔问题所需要的移动次数。建立一个关于序列$\{H_n\}$的递推关系。<br>解:开始$n$个盘子在柱1。按照游戏规则我们可以用$H_{n-1}$次移动将上边的$n-1$个盘子移动柱3.在这些移动中保留最大的盘子不动。然后，我们用一次移动将最大的盘子移动第二根柱子上。我们可以再使用$H_{n-1}$次移动将柱3上的$n-1$个盘子移到柱2，把它们放到最大的盘子上面，这个最大的盘子一直放在柱2的底部。容易看出，使用更少的步数是不能求解这个难题。这就证明了$H_n=2H_{n-1}+1$。<br>使用迭代方法求这个递推关系:$$\begin{array}{l}H_n&amp;=2H_{n-1}+1\\ &amp;=2(2H_{n-2}+1)+1=2^2H_{n-2}+2+1\\ &amp;=2^2(2H_{n-3}+1)+2+1=2^3H_{n-3}+2^2+2+1\\ &amp;\dots\\ &amp;=2^{n-1}H_1+2^{n-2}+2^{n-3}+\dots+2+1\\ &amp;=2^{n-1}+2^{n-2}+\dots+2+1\\&amp;=2^n-1\end{array}$$</p>
<h4 id="编码字的枚举"><a href="#编码字的枚举" class="headerlink" title="编码字的枚举"></a>编码字的枚举</h4><p>一个计算机系统把一个十进制数字串作为一个编码字，如果它包含偶数个$0$，就是有效的。<br>注意到$a_1=9$，因为存在$10$个$1$位十进制数字串，并且只有一个，即串$0$是无效的。通过考虑怎样由$n-1$位的数字串构成一个$n$位有效数字串，就可以推导出关于这个序列的递推关系。从少$1$位数字的串构成$n$位有效数字串有两种方式:      </p>
<ol>
<li>在一个$n-1$位有效数字串后面加上一个非$0$的数字就可以得到一个$n$位的有效数字串。加这个数字的方式有$9$种。因此用这个方法构成$n$位有效数字串的方式有$9a_{n-1}$种。      </li>
<li>在一个无效的$n-1$位数字串后面加上一个$0$就可以得到$n$位有效的数字串。这样做的方式数等于无效的$n-1$位数字串的个数。因为存在$10^{n-1}$个$n-1$位数字串，其中有$a_{n-1}$个是有效的，通过在无效的$n-1$位数字串后面加上一个$0$就得到$10^{n-1}-a_{n-1}$个$n$位的有效数字串。<br>因为所有的$n$位有效数字串都用这两种方式之一产生，从而存在$$\begin{array}{l}a_n &amp;=9a_{n-1}+(10^{n-1}-a_{n-1})\\ &amp;=8a_{n-1}+10^{n-1}\end{array}$$</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;递推关系&quot;&gt;&lt;a href=&quot;#递推关系&quot; class=&quot;headerlink&quot; title=&quot;递推关系&quot;&gt;&lt;/a&gt;递推关系&lt;/h2&gt;&lt;p&gt;对于递归定义，这个从某些前项求后项的规则就叫做递推关系。&lt;br&gt;关于序列$\{a_n\}$的递推关系是一个等式，它把$a_n
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
  </entry>
  
  <entry>
    <title>npm 概述</title>
    <link href="http://blog.freeabyss.com/2017/01/08/JavaScript-NPM-%E6%A6%82%E8%BF%B0/"/>
    <id>http://blog.freeabyss.com/2017/01/08/JavaScript-NPM-概述/</id>
    <published>2017-01-08T04:24:29.000Z</published>
    <updated>2017-01-17T06:29:40.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.freeabyss.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.freeabyss.com/tags/JavaScript/"/>
    
      <category term="npm" scheme="http://blog.freeabyss.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 递归 25</title>
    <link href="http://blog.freeabyss.com/2017/01/07/Math-DM-25-%E9%80%92%E5%BD%92/"/>
    <id>http://blog.freeabyss.com/2017/01/07/Math-DM-25-递归/</id>
    <published>2017-01-07T08:20:54.000Z</published>
    <updated>2017-01-09T14:06:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>为了定义以非负整数集合作为其定义域的函数，使用两个步骤:<br>基础步骤:规定这个函数在$0$处的值。<br>递归步骤:给出从较小的整数处的值来求出当前的值的规则。<br>这样的定义称为递归定义或归纳定义。     </p>
<h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p>斐波那契数$f_0,f_1,f_2,\dots $是用方程组$f_0=0,f_1=1$和$f_n=f_{n-1}+f_n$来定义的。<br>其中$n=2,3,4,\dots $ </p>
<h4 id="使用斐波那契数的性质证明示例"><a href="#使用斐波那契数的性质证明示例" class="headerlink" title="使用斐波那契数的性质证明示例"></a>使用斐波那契数的性质证明示例</h4><p>证明:每当$n\ge 3$时，有$f_n&gt;a_{n-1}$，其中$a=(1+\sqrt 5)/2$<br>基础步骤:证明$P(3)$和$P(4)$都为真。 $$a<2=f_3,\; a^2="(3+\sqrt" 5)="" 2<3="f_4$$" 归纳步骤:假定$p(j)$为真，即对所有满足$3\le="" j\le="" k$的整数$j$来说有$f_j="">a^{j-2}$。其中$k\ge 4$。必须证明$P(k+1)$为真，即$f_{k+1}&gt;a^{k-1}$。因为$a$是$x^2-x-1=0$的解，所有得出$a^2=a+1$。因此$$a^{k-1}=a^2\cdot a^{k-1}=(a+1)a^{k-3}=a\cdot a^{k-3}+1\cdot a^{k-3}=a^{k-2}+a^{k-3}$$<br>根据归纳假设，若$k\ge 4$则得出 $$f_{k-1}&gt;a^{k-3},\;\;f_k&gt;a^{k-2}$$<br>因此有 $$f_{k+1}=f_k+f_{k-1}&gt;a^{k-2}+a^{k-3}$$因此$P(k+1)$为真，证毕。 </2=f_3,\;></p>
<p>###拉梅定理<br>设$a$和$b$是满足$a\ge b$的正整数，则欧几里得算法为了求出$gcd(a,b)$而使用的除法的次数小于或等于$b$的十进制位数的$5$倍。<br>证: 当用欧几里得算法求满足$a\ge b$的$gcd(a,b)$时，得出下面的等式序列(其中$a=r_0$而$b=r_1$)<br>$$\begin{array}{l}<br>r_0=r_1q_1+r_2 \qquad 0\le r_2<r_1 1="f_2" \\="" r_1="r_2q_2+r_3" \qquad="" 0\le="" r_3<r_2="" \dots="" r_{n-2}="r_{n-1}q_{n-1}+r_n" r_n<r_{n-1}="" r_{n-1}="r_nq_n" \end{array}$$="" 在这里为了求出$r_n="gcd(a,b)$而使用了$n$次除法。注意商$q_1,q_2,\dots,q_{n-1}$都至少是$1$。另外，$q_n\ge" 2$，因为$r_n<r_{n-1}$。这就蕴含着="" $$\begin{array}{l}r_n\ge="" \\r_{n-1}\ge="" 2r_n\ge="" 2f_2="f_2" \\r_{n-2}\ge="" r_{n-1}+r_n\ge="" f_3+f_2="f_4" \\\dots="" r_2\ge="" r_3+r_4\ge="" f_{n-1}+f_{n-2}="f_n\\b=r_1\ge" r_2+r_3\ge="" f_n+f_{n-1}="f_{n+1}\end{array}$$" 因此得出，若欧几里得算法为了求出满足$a\ge="" b$的$gcd(a,b)$而使用了$n$次除法，则$b\ge="" f_{n+1}$从列6中知道，对$n="">2$来说$f_{n+1}&gt;a^{n-1}$，其中$a=(1+\sqrt 5)/2$。因此得出$b&gt; a^{n-1}$.另外，因为$log_{10}a~0.208&gt;1/5$。所以可以看出$$log_{10}b&gt;(n-1)log_{10}a&gt;(n-1)/5$$因此，$n-1&lt;5\cdot log_{10}b$。现在假定$b$有$k$个十进制位。则$b&lt;10^k$而且$log_{10}b&lt;k$。由此得出$n-1&lt;5k$，而且因为$k$是整数，所以得出$n\le 5k$。证毕。</r_1></p>
<h3 id="结构归纳法"><a href="#结构归纳法" class="headerlink" title="结构归纳法"></a>结构归纳法</h3><p>结构归纳法包含两个步骤:<br>基础步骤:证明对于递归定义的基础步骤所规定的属于该集合的所以元素来说，结果成立。<br>递归步骤:证明如果对于定义的递归步骤中用来构造新元素的每个元素来说命题为真，则对于这些新的元素来说结果成立。      </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h2&gt;&lt;p&gt;为了定义以非负整数集合作为其定义域的函数，使用两个步骤:&lt;br&gt;基础步骤:规定这个函数在$0$处的值。&lt;br&gt;递归步骤:给出从较小的整数处的
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 强归纳法 24</title>
    <link href="http://blog.freeabyss.com/2017/01/07/Math-DM-24-%E5%BC%BA%E5%BD%92%E7%BA%B3%E6%B3%95/"/>
    <id>http://blog.freeabyss.com/2017/01/07/Math-DM-24-强归纳法/</id>
    <published>2017-01-07T07:54:56.000Z</published>
    <updated>2017-01-09T13:36:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="强归纳法"><a href="#强归纳法" class="headerlink" title="强归纳法"></a>强归纳法</h2><p>要证明对所有正整数$n$而言，都有$P(n)$为真，其中$P(n)$为命题函数，我们要完成如下两个步骤:<br>基础步骤: 证明$P(1)$为真。<br>归纳步骤: 要证明对所有正整数$k$来说，蕴含式$[P(1)\land P(2)\land\dots\land P(k)]\rightarrow P(k+1)$</p>
<h3 id="强归纳法-or-数学归纳法"><a href="#强归纳法-or-数学归纳法" class="headerlink" title="强归纳法 or 数学归纳法"></a>强归纳法 or 数学归纳法</h3><p>一般情况下，我们应当尽量限制数学归纳法的使用。除非已经看出数学归纳法的归纳步骤证明是明显成立的。</p>
<h3 id="强归纳法示例"><a href="#强归纳法示例" class="headerlink" title="强归纳法示例"></a>强归纳法示例</h3><h4 id="算术基本定理证明"><a href="#算术基本定理证明" class="headerlink" title="算术基本定理证明"></a>算术基本定理证明</h4><p>证明:若$n$是大于$1$的整数，则$n$可以写成素数之和。<br>设$P(n)$是命题:$n$可以写成素数之积。<br>基础步骤: $P(2)$为真，因为$2$可以写成一个素数之积，即它自身。<br>归纳步骤: 假定对所有满足$j\le k$的正整数$j$来说$P(j)$为真。要完成归纳步骤就必须证明在这个假定下$P(k+1)$为真。<br>有两种情况要考虑，即$k+1$是素数和$k+1$是合数。$k+1$是素数，则立即看出$P(k+1)$为真。否则，$k+1$是合数并且可以写成满足$2\le a\le b&lt;k+1$的两个整数$a$和$b$之积。根据归纳假设，$a$和$b$都可以写成素数之积。因此，若$k+1$是合数，则它可以写成素数之积。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;强归纳法&quot;&gt;&lt;a href=&quot;#强归纳法&quot; class=&quot;headerlink&quot; title=&quot;强归纳法&quot;&gt;&lt;/a&gt;强归纳法&lt;/h2&gt;&lt;p&gt;要证明对所有正整数$n$而言，都有$P(n)$为真，其中$P(n)$为命题函数，我们要完成如下两个步骤:&lt;br&gt;基础步骤: 
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 数学归纳法 23</title>
    <link href="http://blog.freeabyss.com/2017/01/07/Math-DM-23-%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/"/>
    <id>http://blog.freeabyss.com/2017/01/07/Math-DM-23-数学归纳法/</id>
    <published>2017-01-07T01:59:39.000Z</published>
    <updated>2017-01-07T07:51:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><p>数学归纳法用来证明形如$\forall nP(n)$的一类定理，其中论域是正整数集合。<br>数学归纳法主要用于证明一个公式是否正确，而不能用于推导公式。     </p>
<h3 id="数学归纳法原理"><a href="#数学归纳法原理" class="headerlink" title="数学归纳法原理"></a>数学归纳法原理</h3><p>为证明对所有的正整数$n$，$P(n)$为真，其中$P(n)$是一个命题函数，需要完成两个步骤:<br>    基础步骤:证明命题$P(1)$为真。<br>    归纳步骤:证明对每个正整数$k$来说，蕴含式$P(k)\rightarrow P(k+1)$为真。<br>有时候需要证明对$n=b,b+1,b+2,\dots$ 来说$P(n)$为真，其中$b$是不等于$1$的整数。只要改变基础步骤，就可以用数学归纳法来完成这个证明。     </p>
<h3 id="数学归纳法证明示例"><a href="#数学归纳法证明示例" class="headerlink" title="数学归纳法证明示例"></a>数学归纳法证明示例</h3><h4 id="几何级数求和"><a href="#几何级数求和" class="headerlink" title="几何级数求和"></a>几何级数求和</h4><p>设$n$是一个非负整数，证明一下等式成立。 $$\sum_{j=0}^n ar^j=a+ar+ar^2+\dots+ar^n={ar^{n+1}-a\over r-1}, r\neq 1$$<br>基础步骤: $P(0)$为真，因为$${ar^{0+1}-a\over r-1}={ar-a\over r-1}=a$$<br>归纳步骤: 假设$P(k)$为真。 $$a+ar+ar^2+\dots+ar^k={ar^{k+1}-a\over r-1}$$<br>接着要证明$P(k+1)$为真， 将上述等式两边加上$ar^{k+1}$，得到$$a+ar+ar^2+\dots+ar^k+ar^{k+1}={ar^{k+1}-a\over r-1}+ar^{k+1}$$<br>改写等式右边: $${ar^{k+1}-a\over r-1}+ar^{k+1}={ar^{k+1}-a\over r-1}+{ar^{k+2}-ar^{k+1}\over r-1}={ar^{k+2}-a\over r-1}$$<br>于是: $$a+ar+ar^2+\dots+ar^k+ar^{k+1}={ar^{k+2}-a\over r-1}$$<br>这就证明了，如果归纳假设$P(k)$为真，则$P(k+1)$也必为真。      </p>
<h4 id="证明不等式"><a href="#证明不等式" class="headerlink" title="证明不等式"></a>证明不等式</h4><p>证明:对每个满足$n\ge 4$的正整数$n$来说，有$2^n&lt;n!$。<br>设$P(n)$是命题:$2^n&lt;n!$。<br>基础步骤: 为了证明对$n\ge 4$来说这个不等式成立，基础步骤应该是$P(4)$。$P(4)$为真，因为$2^4&lt;4!$。<br>归纳步骤: 对归纳步骤，假定$P(k)$为真，其中$k\ge 4$。接下来证明$2^{k+1}&lt;(k+1)!$为真，<br>$$\begin{array}{l}2^{k+1} &amp; =2\cdot 2^k\\ &amp;&lt; 2\cdot k!\\ &amp;&lt;(k+1)k!\\&amp;=(k+1)!\end{array}$$</p>
<h4 id="调和数的不等式"><a href="#调和数的不等式" class="headerlink" title="调和数的不等式"></a>调和数的不等式</h4><p>调和数$H_j(j=1,2,3,\dots)$的定义为 $$H_j=1+{1\over 2}+{1\over 3}+\dots + {1\over j}$$<br>证明:$$H_{2^n}\ge 1+{n\over 2}$$<br>设$P(n)$是命题 $H_{2^n}\ge 1+n/2$<br>基础步骤: $P(0)$为真，因为$H_{2^0}=H_1=1\ge 1+0/2$<br>归纳步骤: 归纳假设命题是$P(k)$为真，即$H_{2^k}\ge 1+{k\over 2}$,其中$k$是非负整数。证明$P(k+1)$也为真，即命题$H_{2^{k+1}}\ge 1+{k+1\over 2}$为真。<br>$$\begin{array}{l} H_{2^{k+1}}&amp;=1+{1\over 2}+\dots+{1\over 2^k}+{1\over 2^k+1}+\dots+{1\over 2^{k+1}}\\&amp;=H_{2^k}+{1\over 2^k+1}+\dots+{1\over 2^{k+1}}\\&amp;\ge (1+{k\over 2})+{1\over 2^k+1}+\dots+{1\over 2^{k+1}}\\&amp;\ge (1+{k\over 2}+2^k\cdot {1\over 2^{k+1}}\\ &amp;\ge (1+{k\over 2})+{1\over 2}\\&amp;=1+{k+1\over 2} \end{array}$$</p>
<h4 id="有限集合自己的个数"><a href="#有限集合自己的个数" class="headerlink" title="有限集合自己的个数"></a>有限集合自己的个数</h4><p>证明: 若$S$有$n$个元素的有限集合，其中$n$是一个非负整数，则$S$有$2^n$个子集。<br>设 $P(n)$是命题:有$n$个元素的集合有$2^n$个子集。<br>基础步骤:$P(0)$为真，因为有$0$个元素的集合，即空集，有$1$个子集，即它本身。<br>归纳步骤:假定对于所有非负整数$k$，$P(k)$为真，即假定所有$k$个元素的几个都有$2^k$个子集。必须证明在此假定下，命题$P(k+1)$为真。为此，假定$T$是一个具有$k+1$个元素的集合，于是$T$可以写成$T=S\cup \{a\}$,其中$a$是$T$中的一个元素，且$S=T-\{a\}$，因此$\mid S\mid =k$。对于$S$的每个子集$X$而言，存在$T$的两个子集，即$X$和$X\cup {a}$。这些集合构成卵$T$的所有子集，且这些子集都不相同。因为$S$有$2^k$个子集，所有$T$有$2\cdot 2^k=2^{k+1}$个子集。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数学归纳法&quot;&gt;&lt;a href=&quot;#数学归纳法&quot; class=&quot;headerlink&quot; title=&quot;数学归纳法&quot;&gt;&lt;/a&gt;数学归纳法&lt;/h2&gt;&lt;p&gt;数学归纳法用来证明形如$\forall nP(n)$的一类定理，其中论域是正整数集合。&lt;br&gt;数学归纳法主要用于证明
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 把物体放入盒子 22</title>
    <link href="http://blog.freeabyss.com/2016/12/28/Math-DM-22-%E6%8A%8A%E7%89%A9%E4%BD%93%E6%94%BE%E5%85%A5%E7%9B%92%E5%AD%90/"/>
    <id>http://blog.freeabyss.com/2016/12/28/Math-DM-22-把物体放入盒子/</id>
    <published>2016-12-28T14:11:05.000Z</published>
    <updated>2017-01-07T02:00:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="把物体放入盒子"><a href="#把物体放入盒子" class="headerlink" title="把物体放入盒子"></a>把物体放入盒子</h2><p>许多计数问题都可以通过枚举把不同的物体放入不同盒子的方式数来解决，这些被放入盒子的物体的次序是无关紧要的。<br>这些物体既可以是可辨别的，即每个都是不同的，也可以是不可辨别的，即认为每个都是相同的。可辨别的物体也称为有标号的，而不可辨别的物体则称为没有标号的。<br>类似的盒子也分为可辨别的、不可辨别的。    </p>
<h3 id="可辨别的物体与可辨别的盒子"><a href="#可辨别的物体与可辨别的盒子" class="headerlink" title="可辨别的物体与可辨别的盒子"></a>可辨别的物体与可辨别的盒子</h3><p>把$n$个不同的物体分配到$k$个不同的盒子使得$n_i$个物体放入盒子$i(i=1,2,\dots,k)$的方式数等于<br>$$n!\over n_1!n_2!\dots n_k!$$</p>
<h3 id="不可辨别的物体与可辨别的盒子"><a href="#不可辨别的物体与可辨别的盒子" class="headerlink" title="不可辨别的物体与可辨别的盒子"></a>不可辨别的物体与可辨别的盒子</h3><p>$n$个不可辨别的物体放入$k$个可辨别的盒子的方式数等价于在允许重复计数的情况下，对具有$k$个元素的集合计算$n$组合的问题。    </p>
<h3 id="可辨别的物体与不可辨别的盒子"><a href="#可辨别的物体与不可辨别的盒子" class="headerlink" title="可辨别的物体与不可辨别的盒子"></a>可辨别的物体与不可辨别的盒子</h3><p>关于计算把$n$个可辨别的物体放入$j$个不可辨别的盒子的方式数问题，我们没有一个简单可用的封闭公式。但是，却有一个相当复杂的计算公式，设$S(n,j)$表示将$n$个可辨别的物体放入$j$个不可辨别的盒子的方式数，其中不允许有空的盒子。$S(n,j)$称为第二类斯特灵数。<br>$$\sum_{j=1}^kS(n,j)=\sum_{j=1}^k{1\over j!}\sum_{i=0}^{j-1}(-1)^i\left(\begin{array}{c}j\\i\end{array}\right)(j-i)^n$$</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;把物体放入盒子&quot;&gt;&lt;a href=&quot;#把物体放入盒子&quot; class=&quot;headerlink&quot; title=&quot;把物体放入盒子&quot;&gt;&lt;/a&gt;把物体放入盒子&lt;/h2&gt;&lt;p&gt;许多计数问题都可以通过枚举把不同的物体放入不同盒子的方式数来解决，这些被放入盒子的物体的次序是无关紧
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="count" scheme="http://blog.freeabyss.com/tags/count/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 其他排列组合 21</title>
    <link href="http://blog.freeabyss.com/2016/12/27/Math-DM-21-%E9%87%8D%E5%A4%8D%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    <id>http://blog.freeabyss.com/2016/12/27/Math-DM-21-重复的排列组合/</id>
    <published>2016-12-27T13:49:58.000Z</published>
    <updated>2017-01-15T12:58:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重复的排列和组合"><a href="#重复的排列和组合" class="headerlink" title="重复的排列和组合"></a>重复的排列和组合</h2><p>具有$n$个物体的集合允许重复的$r$的排列数是$n^r$。<br>$n$个元素的集合中允许重复的$r$的组合含有$Cn+r-1,r)=C(n+r-1,n-1)$个。     </p>
<h3 id="允许和不允许重复的组合与排列"><a href="#允许和不允许重复的组合与排列" class="headerlink" title="允许和不允许重复的组合与排列"></a>允许和不允许重复的组合与排列</h3><table>
<thead>
<tr>
<th style="text-align:left">类别</th>
<th style="text-align:left">允许重复</th>
<th style="text-align:left">公式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$r$排列</td>
<td style="text-align:left">不</td>
<td style="text-align:left">$n!\over (n-r)!$</td>
</tr>
<tr>
<td style="text-align:left">$r$组合</td>
<td style="text-align:left">不</td>
<td style="text-align:left">$n!\over r!(n-r)!$</td>
</tr>
<tr>
<td style="text-align:left">$r$排列</td>
<td style="text-align:left">是</td>
<td style="text-align:left">$n^r$</td>
</tr>
<tr>
<td style="text-align:left">$r$组合</td>
<td style="text-align:left">是</td>
<td style="text-align:left">$(n+r-1)!\over r!(n-1)!$</td>
</tr>
</tbody>
</table>
<h2 id="多重排列"><a href="#多重排列" class="headerlink" title="多重排列"></a>多重排列</h2><p>设类型1的相同物体有$n_1$个，类型2的相同物体有$n_2$个，$\dots$，类型$k$的相同物体有$n_k$个，那么$n$个物体的不同排列数是$$n!\over n_1!n_2!\dots n_k!$$</p>
<p>证: 为确定排列数，首先注意到可以用$C(n,n_1)$种方式在$n$个位置中放类型1的$n_1$个物体，剩下$n-n_1$个空位。然后用$C(n-n_1,n_2)$种方式放类型2的物体，剩下$n-n_1-n_2$个空位。继续放类型3的物体，$\dots$，类型$k-1$的物体，直到最后可用$C(n-n_1-n_2-\dots -n_{k-1},n_k)$种方式放类型$k$的物体。因此由乘积法则，不同排列的总数是<br>$$\begin{array}{l}<br>C(n,n_1)C(n-n_1,n_2)\dots(n-n_1-\dots -n_{k-1},n_k) \\<br>={n!\over n_1!(n-n_1)!}{(n-n_1)!\over n_2!(n-n_1-n_2)!}\dots{(n-n_1-\dots -n_{k-1})!\over n_k!0!} \\<br>={n!\over n_1!n_2!\dots n_k!}<br>\end{array}$$</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>重新排序单词SUCCESS中的字母能构成多少个不同的串?<br>因为SUCCESS中的某些字母是重复的，答案并不是$7$个字母的排列数。这个单词包含$3$个S、$2$个、$1$个U和$1$个E。为确定重新排列单词中的字母能构成多少个不同的串，首先，注意到$3$个S可以用$C(7,3)$种不同的方式放在$7$个位置中，剩下$4$个空位i。然后可以用$C(4,2)$种方式放$2$个C，留下2个空位。又可以用$C(2,1)$种方式放U，留下$1$个空位。因此放E只有$C(1,1)$种方式。从而，由乘积法则，产生不同的串数是<br>$$\begin{array}{l}C(7,3)C(4,2)C(2,1)C(1,1)&amp;={7!\over 3!4!}\cdot{4!\over 2!2!}\cdot{2!\over 1!1!}\cdot{1!\over 1!0!}\\<br>&amp;={7!\over 3!2!1!1!}\\<br>&amp;=420\end{array}$$</p>
<p>换个思路，我们可以将$SUCCESS$的看成是$S_1S_2S_3U_1C_1C_2E_1$，然后再除以每个字母的冗余度。$S_1S_2S_3$共有$3!$种排列方式，$U_1$共有$1!$种排列方式，$C_1C_2$共有$2!$种排列方式，$E_1$共有$1!$种排列方式，因此SUCCESS产生的排列数是${7!\over 3!2!1!1!}$</p>
<h2 id="其他排列"><a href="#其他排列" class="headerlink" title="其他排列"></a>其他排列</h2><h3 id="字母不可相邻"><a href="#字母不可相邻" class="headerlink" title="字母不可相邻"></a>字母不可相邻</h3><p>从26个字母中选取4个不同的字母，且b、d不能相邻。<br>首先，找出b,d相邻有多少排列数。 其中bd已确定，需要从剩下24个字母中选取2个与bd进行排列，共有$C(24，2)\times 3!$种方式，又因为b、d有bd,db两种相邻方式，因此b、d相邻共有$C(24,2)\times 3!\times 2$种方式。<br>因此，不包含b、d相邻的排列数有$P(26,4)-C(24,2)\times 3!\times 2$</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;重复的排列和组合&quot;&gt;&lt;a href=&quot;#重复的排列和组合&quot; class=&quot;headerlink&quot; title=&quot;重复的排列和组合&quot;&gt;&lt;/a&gt;重复的排列和组合&lt;/h2&gt;&lt;p&gt;具有$n$个物体的集合允许重复的$r$的排列数是$n^r$。&lt;br&gt;$n$个元素的集合中允许
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="count" scheme="http://blog.freeabyss.com/tags/count/"/>
    
  </entry>
  
</feed>
