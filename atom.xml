<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Abyss&#39;s blog</title>
  <subtitle>Java程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.freeabyss.com/"/>
  <updated>2017-03-28T01:38:41.000Z</updated>
  <id>http://blog.freeabyss.com/</id>
  
  <author>
    <name>Abyss</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Math-DL-02- 命题演算</title>
    <link href="http://blog.freeabyss.com/Mathematical-Logic/Math-DL-02-%E5%91%BD%E9%A2%98%E6%BC%94%E7%AE%97.html"/>
    <id>http://blog.freeabyss.com/Mathematical-Logic/Math-DL-02-命题演算.html</id>
    <published>2017-03-25T13:22:37.000Z</published>
    <updated>2017-03-28T01:38:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="概览"><a href="# 概览" class="headerlink" title="概览"></a>概览</h2><p><img src="../images/propostion_01.png" alt="概览图"></p>
<h2 id="命题"><a href="# 命题" class="headerlink" title="命题"></a>命题 </h2><p> 命题是数理逻辑中最基本的概念，就好像自然数对于算数一样。</p>
<p>对确定的对象作出判断的陈述句称作命题。 如果判断正确，称命题为 <strong> 真</strong>，否则为 <strong> 假</strong>。「真、假」是命题的属性，成为「真值」。</p>
<p>命题要符合三个条件：</p>
<ul>
<li>必须是陈述句</li>
<li>要做出判断</li>
<li>要对确定的对象作出判断</li>
</ul>
<p>自相矛盾语句的不能作为命题，例如「这句话是错的」。</p>
<h2 id="命题符号化"><a href="# 命题符号化" class="headerlink" title="命题符号化"></a>命题符号化 </h2><p><strong> 逻辑联结词 </strong> 是指，连接命题，对命题进行运算的词。<strong>原子命题 </strong> 是不含有逻辑联结词的命题。<strong>复合命题 </strong> 是包含了原子命题和逻辑联结词的命题。 </p>
<p>原子命题一般用 $p$、$q$ 、$r$ 、$s$ 等小写字母表示。</p>
<h3 id="逻辑联结词"><a href="# 逻辑联结词" class="headerlink" title="逻辑联结词"></a>逻辑联结词 </h3><p> 逻辑联结词是数理逻辑中的运算符号，就好像数学运算中的「加、减、乘、除」一样。</p>
<p>常用的逻辑联结词有以下几种：</p>
<ul>
<li>非：表示命题的否定。记作 $\lnot p$</li>
<li>合取：逻辑关系为两个命题同时成立，表示自然语言中「即…又…」、「不但…而且…」等并列的连接词。记作 $p\land q$ </li>
<li>析取：逻辑关系为两个命题至少一个成立，表示自然语言中的「或」。记作 $p\lor q$ </li>
<li>异或：有时自然语言中的「或」具有排斥性，例如「人固有一死，或重于泰山，或轻于鸿毛」这时就用异或表示，记作 $p\oplus q$ ，等价于 $(p\land\lnot q)\lor (\lnot p\land q)$</li>
<li>蕴含：逻辑关系是 $p$ 是 $q$ 的充分条件，或者说 $q$ 是 $p$  的必要条件。记作 $p\rightarrow q$ </li>
<li>双向蕴含：逻辑关系是 $p$ 和 $q$ 互为充分必要条件。记作 $p\leftrightarrow q$</li>
<li>或非：也称 Peirce 记号。在 $p$ 和 $q$ 均为假时为真，相当于 $\lnot (p\lor q)$</li>
<li>与非：在 $p$ 和 $q$ 均为真时为假，相当于 $\lnot (p\land q)$</li>
</ul>
<p>以下是几种逻辑联结词的真值表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$p\qquad q$</th>
<th style="text-align:center">$\lnot p$</th>
<th style="text-align:center">$p\lor q$</th>
<th style="text-align:center">$p\land q$</th>
<th style="text-align:center">$p\oplus q$</th>
<th style="text-align:center">$p\rightarrow q$</th>
<th style="text-align:center">$p\leftrightarrow q$</th>
<th style="text-align:center">$p\mid q$</th>
<th style="text-align:center">$p\downarrow q$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$T\qquad T$</td>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
</tr>
<tr>
<td style="text-align:center">$T\qquad F$</td>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
<td style="text-align:center">F</td>
</tr>
<tr>
<td style="text-align:center">$F\qquad T$</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
<td style="text-align:center">F</td>
</tr>
<tr>
<td style="text-align:center">$F\qquad F$</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
</tr>
</tbody>
</table>
<h3 id="命题公式"><a href="# 命题公式" class="headerlink" title="命题公式"></a>命题公式 </h3><p> 命题公式的组成：</p>
<ul>
<li>命题常元：即具体的命题和 $\mathbf T\quad \mathbf F$</li>
<li>命题变元：以「真、假」为取值范围的变量</li>
<li>命题公式：由命题常元、命题变元和联结词组成的形式更为复杂的命题</li>
</ul>
<p>命题公式的定义：</p>
<ol>
<li>命题变元和命题常元是命题公式，特别的称为原子公式或原子</li>
<li>如果 $A$ ，$B$  是命题公式，那么 $(\lnot A)$，$(A\land B)$，$(A\lor B)$，$(A\rightarrow B)$，$(A\leftrightarrow B)$ 也是命题公式</li>
<li>只有有限步骤引用上述两条所组成的符号串是命题公式</li>
</ol>
<p>命题公式简称公式，采用大写 $A$，$B$ 等表示。</p>
<p>命题公式形式上是一个规则的字符串，内容上对应一个真值函数。</p>
<h4 id="逻辑联结词优先级"><a href="# 逻辑联结词优先级" class="headerlink" title="逻辑联结词优先级"></a>逻辑联结词优先级 </h4><p> 严格按照定义的命题公式太过繁琐，为了简化括号，约定了逻辑联结词的优先级。</p>
<p>我们定义优先级为：$\lnot$， $[\land\; \lor]$，$\rightarrow$，$\leftrightarrow$ </p>
<h3 id="真值函数"><a href="# 真值函数" class="headerlink" title="真值函数"></a>真值函数 </h3><p> 我们可以将命题变元 $p_1, p_2, p_3,\dots,p_n$ 的公式 $A$ 看作是关于 $p_1, p_2, \dots, p_n$ 的一个真值函数。 每个变元的取值范围是 ${0, 1}$。 真值函数的取值范围也是 ${0,1}$ 。</p>
<h4 id="赋值"><a href="# 赋值" class="headerlink" title="赋值"></a>赋值 </h4><p> 对任意给定的 $p_1,p_2,\dots,p_n$ 的一种取值状况组合，称为 <strong> 赋值</strong>。对于每个赋值，公式都有一个确定的真值。赋值用希腊字母 $\alpha\;\beta$ 表示。</p>
<p>当公式 $A$ 对赋值 $\alpha$ 为真时，称 $\alpha$  是 $A$ 的 <strong> 成真赋值</strong>，或者 $\alpha$ 弄真 $A$ 记作 $\alpha(A)=1$ </p>
<p>反之，称 $\alpha$  是 $A$ 的 <strong> 成假赋值</strong>，或者 $\alpha$ 弄假 $A$ 记作 $\alpha(A)=0$ </p>
<h3 id="命题形式化"><a href="# 命题形式化" class="headerlink" title="命题形式化"></a>命题形式化 </h3><p> 由自然语言表述的命题，经过抽象，可以形式化为命题公式。形式化首先确定原子命题，其次确定联结词，最后处理命题之间的联结关系及顺序。</p>
<p>有的语句形式化结果不是唯一的，可能具有不同形式，但逻辑上是等价的。</p>
<h2 id="逻辑等价式和逻辑蕴涵式"><a href="# 逻辑等价式和逻辑蕴涵式" class="headerlink" title="逻辑等价式和逻辑蕴涵式"></a>逻辑等价式和逻辑蕴涵式 </h2><p> 命题公式可以从真值的角度进行分类：</p>
<ul>
<li>重言式：也称永真式，是指命题变元的所有赋值都是命题公式的成真赋值</li>
<li>矛盾式：也称永假式，是指命题变元的所有赋值都是命题公式的成假赋值</li>
<li>可满足式：命题公式至少又一个成真赋值</li>
</ul>
<h3 id="逻辑等价式"><a href="# 逻辑等价式" class="headerlink" title="逻辑等价式"></a>逻辑等价式 </h3><p> 当命题公式 $A\leftrightarrow B$ 是重言式时，则称 $A$ 逻辑等价于 $B$ ，记作 $A ⧦ B$，逻辑等价式。</p>
<blockquote>
<p>有的地方也记作 $A\equiv B$ </p>
</blockquote>
<p>也可以理解为公式 $A$ 和公式 $B$ 是等值的。逻辑等价式体现了，两个公式在任何情况下的赋值都具有相同的真值。</p>
<h4 id="一些重要的逻辑等价式"><a href="# 一些重要的逻辑等价式" class="headerlink" title="一些重要的逻辑等价式"></a>一些重要的逻辑等价式</h4><table>
<thead>
<tr>
<th style="text-align:left">等价关系</th>
<th style="text-align:left">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$\lnot (A\land B) ⧦ \lnot A \lor \lnot B$ <br>  $\lnot (A\lor B) ⧦ \lnot A \land \lnot B$</td>
<td style="text-align:left">摩根定律</td>
</tr>
<tr>
<td style="text-align:left">$A\land \mathbf T ⧦ A$ <br> $A\lor \mathbf F ⧦ A$</td>
<td style="text-align:left">同一律（恒等律）</td>
</tr>
<tr>
<td style="text-align:left">$A\lor \mathbf T ⧦ \mathbf T$ <br> $A\land \mathbf F ⧦ \mathbf F$</td>
<td style="text-align:left">支配律（零律）</td>
</tr>
<tr>
<td style="text-align:left">$A\land A ⧦ A$ <br> $A\lor A ⧦ A$</td>
<td style="text-align:left">幂等律</td>
</tr>
<tr>
<td style="text-align:left">$\lnot(\lnot A) ⧦ A$</td>
<td style="text-align:left">双非律（双重否定律）</td>
</tr>
<tr>
<td style="text-align:left">$A\lor B ⧦ B\lor A$ <br> $A\land B⧦ B\land A$</td>
<td style="text-align:left">交换律</td>
</tr>
<tr>
<td style="text-align:left">$(A\lor B)\lor C⧦ A\lor (B\lor C)$ <br> $(A\land B)\land C⧦ A\land (B\land C)$</td>
<td style="text-align:left">结合律</td>
</tr>
<tr>
<td style="text-align:left">$A\lor(B\land C) ⧦ (A\lor B)\land (A\lor C)$ <br>$A\land (B\lor C) ⧦ (A\land B)\lor (A\land C)$</td>
<td style="text-align:left">分配律</td>
</tr>
<tr>
<td style="text-align:left">$A\lor (A\land B)⧦ A$ <br> $A\land (A\lor B)⧦ A$</td>
<td style="text-align:left">吸收律</td>
</tr>
<tr>
<td style="text-align:left">$A\lor \lnot A⧦ \mathbf T$<br> $A\land \lnot A⧦ \mathbf F$</td>
<td style="text-align:left">否定律（排中律和矛盾律）</td>
</tr>
<tr>
<td style="text-align:left">$A\rightarrow B⧦ \lnot A\lor B $</td>
<td style="text-align:left">蕴含等值式</td>
</tr>
<tr>
<td style="text-align:left">$A\rightarrow B⧦ \lnot B\rightarrow \lnot A$</td>
<td style="text-align:left">假言易位</td>
</tr>
<tr>
<td style="text-align:left">$A\lor B⧦ \lnot A\rightarrow B$</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$A\land B⧦ \lnot(A\rightarrow \lnot B) $</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$\lnot(A\rightarrow B)⧦ A\land \lnot B $</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$(A\rightarrow B)\land (A\rightarrow C)⧦ A\rightarrow (B\land C) $</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$(A\rightarrow C)\land (B\rightarrow C)⧦ (A\lor B)\rightarrow C $</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$(A\rightarrow B)\lor (A\rightarrow C)⧦ A\rightarrow (B\lor C) $</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$A\land B\rightarrow C⧦ A\rightarrow (B\rightarrow C)$</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$(A\rightarrow C)\lor (B\rightarrow C)⧦ (A\land B)\rightarrow C$</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$A \leftrightarrow B ⧦ (A\rightarrow B)\land (B\rightarrow A) $</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$A \leftrightarrow B ⧦ \lnot A \leftrightarrow \lnot B $\</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">$A \leftrightarrow B ⧦ (A \land B)\lor (\lnot A\land \lnot B) $</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$\lnot (A \leftrightarrow B) ⧦ A \leftrightarrow\lnot B$</td>
</tr>
</tbody>
</table>
<h4 id="排中律"><a href="# 排中律" class="headerlink" title="排中律"></a>排中律 </h4><p> 排中律是数理逻辑的基本规律之一，数学证明中常用的「反证法」就是利用了排中律。</p>
<h3 id="逻辑蕴涵式"><a href="# 逻辑蕴涵式" class="headerlink" title="逻辑蕴涵式"></a>逻辑蕴涵式 </h3><p> 当命题公式 $A\rightarrow B$ 是重言式时，则称 $A$ 逻辑蕴涵 $B$，记作 $A\models B$，称作逻辑蕴涵式。</p>
<p>也可以理解为公式 $A$ 的所有成真赋值也是公式 $B$ 的所有成真赋值。</p>
<p>每个逻辑等价式可以看作两个逻辑蕴涵式，即 $A⧦ B$ 也有 $A\models B$ 和 $B\models A$ </p>
<p>逻辑蕴含式体现了，在任何赋值状况下只要 $A$ 为真，$B$ 就为真。  </p>
<h4 id="一些重要的逻辑蕴涵式"><a href="# 一些重要的逻辑蕴涵式" class="headerlink" title="一些重要的逻辑蕴涵式"></a>一些重要的逻辑蕴涵式</h4><table>
<thead>
<tr>
<th>逻辑蕴涵式</th>
</tr>
</thead>
<tbody>
<tr>
<td>$A\models A\lor B$</td>
</tr>
<tr>
<td>$A\lor B\models A$</td>
</tr>
<tr>
<td>$A\land (A\rightarrow B)\models B$</td>
</tr>
<tr>
<td>$(A\rightarrow B)\land\lnot B\models\lnot A$</td>
</tr>
<tr>
<td>$\lnot A\land(A\lor B)\models B$</td>
</tr>
<tr>
<td>$(A\rightarrow B)\land(B\rightarrow C)\models A\rightarrow C$</td>
</tr>
<tr>
<td>$(A\rightarrow B)\land (C\rightarrow D)\models (A\land C)\rightarrow (B\land D)$</td>
</tr>
<tr>
<td>$(A\leftrightarrow B)\land (B\leftrightarrow C)\models A\leftrightarrow C$</td>
</tr>
</tbody>
</table>
<h4 id="逻辑结果"><a href="# 逻辑结果" class="headerlink" title="逻辑结果"></a>逻辑结果 </h4><p> 逻辑蕴涵式经常被推广为 $\Gamma\models B$ 的形式，其中 $\Gamma$ 是一系列公式，表示 $B$ 是 $\Gamma $ 的逻辑结果。也即 $\Gamma$ 中所有公式的合取逻辑蕴涵 $B$ 。</p>
<p>当 $\Gamma$ 中仅包含一个公式时，就是 $A\models B$ 。当 $\Gamma$ 为空时，记作 $\models B$ ，表示 $B$ 永真。</p>
<h3 id="重要性质"><a href="# 重要性质" class="headerlink" title="重要性质"></a>重要性质 </h3><p> 逻辑等价式和逻辑蕴涵式的主要性质有自反、对称、传递等。</p>
<ul>
<li>$A⧦ B$ 当且仅当 $\models A\leftrightarrow B$ </li>
<li>$A\models B$ 当且仅当 $\models A\rightarrow B$</li>
<li>若 $A⧦ B$ ，则 $B⧦ A$</li>
<li>若 $A⧦ B$ ，$B⧦ C$ ，则 $A⧦ C$</li>
<li>若 $A\models B$ ，则 $\lnot B\models\lnot A$</li>
<li>若 $A\models B$ ，$B\models C$ ，则 $A\models C$</li>
<li>若 $A\models B$ ，$A⧦ A’$，$B⧦ B’$ ，则 $A’\models B’$</li>
</ul>
<h3 id="重言式代入原理"><a href="# 重言式代入原理" class="headerlink" title="重言式代入原理"></a>重言式代入原理 </h3><p> 将重言式 $A$ 中的某个命题变元 $p$ 的所有出现都代换为命题公式 $B$ ，得到的命题公式记作 $A(B/p)$，$A(B/p)$ 也是重言式。</p>
<p>因为重言式 $A$ 的真值与 $p$ 的取值状况无关，恒为 $\mathbf T$，所以将 $p$ 全部代换后的公式 $A(B/p)$ 的真值也恒为 $\mathbf T$ 。</p>
<h3 id="命题公式的替换原理"><a href="# 命题公式的替换原理" class="headerlink" title="命题公式的替换原理"></a>命题公式的替换原理 </h3><p> 将命题公式 $A$ 中的子公式 $C$ 的部分出现替换为和 $C$ 逻辑等价的公式 $D$ （$C⧦ D$ ），得到的命题公式记作 $B$ ，则 $A⧦ B$ 。</p>
<p>因为 $C$ 和 $D$ 在任何赋值下等值，所以用 $D$ 替换 $C$ 不会改变 $A$ 的真值。</p>
<h3 id="代入原理和替换原理的区别"><a href="# 代入原理和替换原理的区别" class="headerlink" title="代入原理和替换原理的区别"></a>代入原理和替换原理的区别</h3><table>
<thead>
<tr>
<th></th>
<th>代入原理</th>
<th>替换原理</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用对象</td>
<td>任意永真式</td>
<td>任意命题公式</td>
</tr>
<tr>
<td>代换对象</td>
<td>任意命题变元</td>
<td>任意子公式</td>
</tr>
<tr>
<td>代换物</td>
<td>任意命题公式</td>
<td>任意与代换对象等价的命题公式</td>
</tr>
<tr>
<td>代换方式</td>
<td>代换同一命题变元的所有出现</td>
<td>代换子公式的某些出现</td>
</tr>
<tr>
<td>代换结果</td>
<td>仍为永真式</td>
<td>与原公式等价</td>
</tr>
</tbody>
</table>
<h2 id="范式"><a href="# 范式" class="headerlink" title="范式"></a>范式 </h2><p> 每个命题公式都会存在很多与之逻辑等价的公式，<strong>范式 </strong> 就是在命题公式的多个逻辑等价的形式中，较为符合「标准」和「规范」的一种形式。</p>
<p>范式所涉及的基本术语：</p>
<ul>
<li>文字：是指命题变元、命题常元以及它们的否定，前者称为正文字，后者称为负文字</li>
<li>析取子句：文字或若干文字的析取，例如 $p$，$p\lor q$ </li>
<li>合取子句：文字或若干文字的合取，例如 $p$ ，$p\land q$</li>
<li>互补文字对：指一对正文字和负文字</li>
<li>析取范式：公式 $A’$ 称作公式 $A$ 的析取范式，如果：$A’⧦ A$ ，且 $A’$ 为 <strong> 合取子句 </strong> 或者若干 <strong> 合取子句 </strong> 的<strong>析取</strong></li>
<li>合取范式：公式 $A’$ 称作公式 $A$ 的合取范式，如果：$A’⧦ A$，且 $A’$ 为 <strong> 析取子句 </strong> 或者若干 <strong> 析取子句 </strong> 的<strong>合取</strong></li>
</ul>
<p>范式可以用来识别重言式和矛盾式：</p>
<ul>
<li>重言式识别：合取范式中每个析取子句都包含至少一个互补文字对</li>
<li>矛盾式识别：析取范式中每个合取子句都包含至少一个互补文字对</li>
</ul>
<h3 id="求范式的一般步骤"><a href="# 求范式的一般步骤" class="headerlink" title="求范式的一般步骤"></a>求范式的一般步骤 </h3><p> 利用逻辑等价式、代入原理和替换原理，可以求出任一一个公式的析取范式和合取范式。</p>
<p>具体步骤为：</p>
<ul>
<li>消去公式中的联结词 $\rightarrow $ 和 $\leftrightarrow$</li>
<li>利用徳摩根律将否定联结词 $\lnot$ 向内深入，最后只作用于文字，再将 $\lnot\lnot p$ 化为 $p$</li>
<li>利用分配律，最后得到需要的析取或者合取范式</li>
</ul>
<h3 id="主范式"><a href="# 主范式" class="headerlink" title="主范式"></a>主范式</h3><ul>
<li>主析取范式：公式 $A’$ 称作公式 $A(p_1,p_2,\dots,p_n)$ 的主析取范式，如果 $A’$ 是 $A$ 的析取范式，$A’$ 中每一个合取子句里都要包含所有的命题变元，并且每一个命题变元恰好出现一次</li>
<li>主合取范式：公式 $A’$ 称作公式 $A(p_1,p_2,\dots,p_n)$ 的主合取范式，如果 $A’$ 是 $A$ 的合取范式，$A’$ 中每一个析取子句里都要包含所有的命题变元，并且每一个命题变元恰好出现一次</li>
</ul>
<h4 id="主范式的唯一性证明"><a href="# 主范式的唯一性证明" class="headerlink" title="主范式的唯一性证明"></a>主范式的唯一性证明 </h4><p> 以主析取范式为例，证明主范式的唯一性。</p>
<h5 id="约定"><a href="# 约定" class="headerlink" title="约定"></a>约定</h5><ul>
<li>合取子句中的文字按照其包含的变元下标从小到大排列</li>
<li>对于包含所有变元 $p_1,p_2,\dots,p_n$ 并且排列好文字顺序的合取子句，我们称之为极小项，记作 $m_i$</li>
<li>其中 $i$ 是一个整数，$i$ 对应的 $n$ 位二进制表示描述了对应下标的变元在合取子句中的否定状态</li>
<li>用 $1$ 表示该位是正文字，$0$ 表示该位是负文字。</li>
<li>例如 $p_1\land p_2\land p_3$ 记作 $m_7(7=111)$ ，$p_1\land\lnot p_2\land\lnot p_3$ 记作 $m_4 (4=100)$</li>
</ul>
<p>主析取范式是极小项按照其下标从小到大排列的析取</p>
<h5 id="极小项赋值引理"><a href="# 极小项赋值引理" class="headerlink" title="极小项赋值引理"></a>极小项赋值引理</h5><ul>
<li>极小项只有唯一的成真赋值</li>
<li>极小项的成真赋值中每个变元的取值等于极小项下标的二进制形式中变元下标所对应的二进制位的值</li>
<li>例如 $p_1\land p_2\land p_3$ 的唯一成真赋值是 $p_1=1,p_2=1,p_3=1$ ；$p_1\land\lnot p_2\land\lnot p_3$ 的唯一成真赋值是 $p_1=1,p_2=0,p_3=0$ </li>
</ul>
<h5 id="极小项和主析取范式之间的关系"><a href="# 极小项和主析取范式之间的关系" class="headerlink" title="极小项和主析取范式之间的关系"></a>极小项和主析取范式之间的关系</h5><ul>
<li>主析取范式包含的极小项的成真赋值也是主析取范式的成真赋值</li>
<li>主析取范式的任一一个成真赋值是其包含的某个极小项的成真赋值</li>
<li>主析取范式不包含的极小项的成真赋值是主析取范式的成假赋值</li>
</ul>
<h5 id="存在性证明"><a href="# 存在性证明" class="headerlink" title="存在性证明"></a>存在性证明 </h5><p> 假设 $A’$ 是公式 $A(p_1,p_2,\dots,p_n)$ 的析取范式，如果 $A’$ 中某个合取子句 $A_i$ 即不包含 $p_j$ 也不包含 $\lnot p_j$ ，那么我们将 $A_i$ 展成如下形式：$$\begin{array}{cl} A_i &amp; ⧦ A_i\land\mathbf T \\&amp; ⧦ A_i\land (p_j\lor\lnot p_j) \\&amp; ⧦ (A_i\land p_j)\lor (A_i\land\lnot p_j)\end{array}$$ </p>
<p>将合取子句中重复出现的命题变元、矛盾式消去，将重复出现的合取子句消去。</p>
<p>最后将所有的合取子句整理变元顺序，成为极小项，并得到主析取范式 $A’’$</p>
<h5 id="唯一性证明"><a href="# 唯一性证明" class="headerlink" title="唯一性证明"></a>唯一性证明 </h5><p> 假设公式 $A(p_1,p_2,\dots,p_n)$ 存在两个不同的主析取范式 $B$ 和 $C$ 。由于 $A⧦B$ 且 $A⧦C$ 所以 $B⧦C$ 。</p>
<p>因为 $B$ 和 $C$ 是两个不同的主析取范式，那么一定存在某个极小项 $m_i$ 只出现在 $B$ 或只出现在 $C$ 中，不妨假设 $m_i$ 只出现在 $B$ 中，不出现在 $C$ 中，这样 $m_i$ 的成真赋值是 $B$ 的成真赋值，却是 $C$ 的成假赋值，这与 $B⧦C$ 矛盾。      </p>
<p>所以 $B$ 和 $C$ 必然相同，也就是说公式 $A(p_1,p_2,\dots,p_n)$ 的主析取范式是唯一的。</p>
<h5 id="命题公式的等值分类"><a href="# 命题公式的等值分类" class="headerlink" title="命题公式的等值分类"></a>命题公式的等值分类 </h5><p> 具有相同主析取范式的公式都是等值的，属于同一个等值类，否则属于不同的等值类。</p>
<p>虽然公式的数量无限多，但是等值类的数量是有限的。</p>
<p>极小项的数量为 $N=2^n$ ，由极小项组合成的主析取范式的数量为 $2^N$，等值类的数量等于主析取范式的数量</p>
<h5 id="主合取范式的证明"><a href="# 主合取范式的证明" class="headerlink" title="主合取范式的证明"></a>主合取范式的证明 </h5><p> 主合取范式具有和主析取范式对称的性质。</p>
<p>主合取范式由极大项合取构成的。极大项具有唯一的成假赋值。</p>
<h2 id="联结词集完备性"><a href="# 联结词集完备性" class="headerlink" title="联结词集完备性"></a>联结词集完备性 </h2><p> 每个等值类都对应唯一的真值函数，它们是一一对应的。真值函数与相应等值类的每个命题公式等值，尤其是主范式。</p>
<h3 id="功能完备集"><a href="# 功能完备集" class="headerlink" title="功能完备集"></a>功能完备集 </h3><p> 如果任意一个真值函数都可以用仅包含某个联结词集中的联结词的命题公式表示，则称这个联结词集为功能完备集。${\lnot,\land,\lor,\rightarrow,\leftrightarrow}$、${\lnot,\land,\lor}$、${\lnot,\rightarrow}$、${\downarrow}$ 都是功能完备集。</p>
<h3 id="冗余联结词"><a href="# 冗余联结词" class="headerlink" title="冗余联结词"></a>冗余联结词 </h3><p> 在一个联结词集中，如果某个联结词可以用集合中其他联结词来定义，则这个联结词称作冗余联结词</p>
<p>如果一个功能完备集不包含冗余联结词，则称这个功能完备集是极小的。</p>
<h3 id="功能完备集的证明"><a href="# 功能完备集的证明" class="headerlink" title="功能完备集的证明"></a>功能完备集的证明 </h3><p> 功能完备集的证明很简单：从一个已知的功能完备集中去掉冗余联结词，直到得到该功能完备集。</p>
<p>非功能完备集的证明比较复杂，没有统一的证明方法。</p>
<h2 id="命题演算形式系统"><a href="# 命题演算形式系统" class="headerlink" title="命题演算形式系统"></a>命题演算形式系统 </h2><h3 id="形式系统"><a href="# 形式系统" class="headerlink" title="形式系统"></a> 形式系统 </h3><p> 我们需要反应推理过程，需要严格化推理过程，需要像做计算一样进行推理，于是就有了形式系统。</p>
<p>形式系统是一个符号系统，系统中的概念由符号表示，推理过程即符号变换的过程。</p>
<p>形式系统应当包含以下要素：</p>
<ul>
<li>一群有限数量，可用于构建公式的符号集合</li>
<li>一套文法，说明了如何以上述符号构建形式良好的公式</li>
<li>一群公理模式的陈述，每个公理必须是公式</li>
<li>一群推理规则</li>
</ul>
<p>公理和推理规则确保系统内由正确的前提总能得到正确的推理结果。</p>
<h4 id="证明"><a href="# 证明" class="headerlink" title="证明"></a>证明 </h4><p> 公式序列 $A_1,A_2,\dots,A_m$ 称作 $A_m$ 的一个证明，如果 $A_i(1\le i\le m)$ 是公理，或者由 $A_{j1},A_{j2},\dots,A_{jk} (j1,\dots,jk &lt;i)$ 用推理规则推得。</p>
<p>当这样的证明存在时，称 $A_m$ 为系统的定理，记作 $\vdash <em> A_m$ （</em> 是形式系统的名称），或者简记为 $\vdash A_m$</p>
<h4 id="演绎"><a href="# 演绎" class="headerlink" title="演绎"></a>演绎 </h4><p> 设 $\Gamma$ 为一公式集合，公式序列 $A_1,A_2,\dots,A_m$ 称作 $A_m$ 的以 $\Gamma$ 为前提的演绎，如果 $A_i(1\le i\le m)$ 是 $\Gamma$ 中的公式（我们假设的前提），或是公理，或者由 $A_{j1},A_{j2},\dots,A_{jk} (j1,\dots,jk &lt;i)$ 用推理规则推得。</p>
<p>当有这样的演绎时，$A_m$ 称作 $\Gamma$ 的演绎结果，记作 $\Gamma\vdash <em> A_m$ （</em> 是形式系统的名称），或者简记为 $\Gamma\vdash A_m$ 。称 $\Gamma$ 和 $\Gamma$ 的成员为 $A_m$ 的前提。</p>
<p>证明是演绎在 $\Gamma$ 为空集时的特例。</p>
<h3 id="命题演算形式系统 -PC-Propostion-Calculus"><a href="# 命题演算形式系统 -PC-Propostion-Calculus" class="headerlink" title="命题演算形式系统 PC(Propostion Calculus)"></a>命题演算形式系统 PC(Propostion Calculus)</h3><p>我们将命题以及重言式变换演绎构造为形式系统，成为命题演算形式系统，简称 PC。</p>
<h4 id="PC- 的符号系统"><a href="#PC- 的符号系统" class="headerlink" title="PC 的符号系统"></a>PC 的符号系统</h4><ul>
<li>命题变元：$p,q,r,s,p_1,q_1,\dots$</li>
<li>命题常元：$\mathbf T\quad\mathbf F$</li>
<li>联结词：$\lnot,\rightarrow$ (去掉了其他的联结词)</li>
<li>括号</li>
<li>命题公式：规定了单个字符的合法组成方式（也即文法）</li>
</ul>
<h4 id="PC- 的公理"><a href="#PC- 的公理" class="headerlink" title="PC 的公理"></a>PC 的公理</h4><p>$A$，$B$，$C$ 表示任意的公式</p>
<ul>
<li>$A\rightarrow (B\rightarrow A)$</li>
<li>$(A\rightarrow (B\rightarrow C))\rightarrow ((A\rightarrow B)\rightarrow (A\rightarrow C))$</li>
<li>$(\lnot A\rightarrow\lnot B)\rightarrow (B\rightarrow A)$</li>
</ul>
<h4 id="PC- 的推理规则"><a href="#PC- 的推理规则" class="headerlink" title="PC 的推理规则"></a>PC 的推理规则</h4><p>$A$，$B$ 表示任意公式，PC 只有一条推理规则</p>
<ul>
<li>$A,A\rightarrow B/B$ （分离规则）</li>
</ul>
<h4 id="PC- 的性质"><a href="#PC- 的性质" class="headerlink" title="PC 的性质"></a>PC 的性质 </h4><h5 id="合理性"><a href="# 合理性" class="headerlink" title="合理性"></a> 合理性</h5><ul>
<li>如果公式 $A$ 是系统 PC 的定理，则 $A$ 是重言式。说白了就是如果 $A$ 是定理，则 $A$ 一定是成立的。任何一个定理都是由公式序列推理得来。也即，如果 $\vdash_{PC}A$ ，则 $\models A$</li>
</ul>
<ul>
<li>如果 $A$ 是公式集合 $\Gamma$ 的演绎结果，那么 $A$ 是 $\Gamma$ 的逻辑结果。即，如果 $\Gamma\vdash_{PC}A$，则 $\Gamma\models A$ </li>
</ul>
<p>这说明了 PC 的定理和演绎结果都存在推导过程，都是合乎逻辑的。</p>
<p>PC 中的三个公理都是重言式，并且 PC 的分离规则是「保真」的，就是如果 $A$ 为真，$A\rightarrow B$ 为真，总有 $B$ 为真。</p>
<p>因此，由公理和规则导出的定理都是重言式；由 $\Gamma$、公理和规则导出的公式，在 $\Gamma$ 中的公式都为真时也为真。</p>
<h5 id="一致性"><a href="# 一致性" class="headerlink" title="一致性"></a>一致性 </h5><p> 没有公式 $A$ 使得 $\vdash_{PC}A$ 和 $\vdash_{PC}\lnot A$ 同时成立，即不会出现自相矛盾。</p>
<p>PC 的合理性表明只要你是定理就一定是逻辑真理，那么根据矛盾律不可能存在 $A$ 和 $\lnot A$ 都是逻辑真理的情况。</p>
<h5 id="完备性"><a href="# 完备性" class="headerlink" title="完备性"></a>完备性 </h5><p> 如果公式 $A$ 是重言式，则 $A$ 一定是 PC 中的定理 （如果 $\models A$ ，则 $\vdash_{PC}A$ </p>
<p>如果公式 $A$ 是公式集合 $\Gamma$ 的逻辑结果，则 $A$ 一定是 $\Gamma$ 的演绎结果（如果 $\Gamma\models A$ ，则 $\Gamma\models_{PC}A$ </p>
<p>合乎逻辑的命题，在 PC 中一定能推导出来。</p>
<h3 id="PC- 中的证明"><a href="#PC- 中的证明" class="headerlink" title="PC 中的证明"></a>PC 中的证明 </h3><h4 id="证明定理：-vdash-PC-A-rightarrow-A"><a href="# 证明定理：-vdash-PC-A-rightarrow-A" class="headerlink" title="证明定理：$\vdash_{PC}A\rightarrow A$"></a> 证明定理：$\vdash_{PC}A\rightarrow A$</h4><p>$$\begin{array}{l}1.\quad (A\rightarrow (\color{red}{(A\rightarrow A)}\rightarrow\color{blue}{A}))\rightarrow((A\rightarrow\color{red}{(A\rightarrow A)})\rightarrow(A\rightarrow\color{blue}{A}))\quad 公理 2 \\2.\quad A\rightarrow (\color{red}{(A\rightarrow A)}\rightarrow A)\quad 公理 1 \\3.\quad (A\rightarrow (A\rightarrow A))\rightarrow (A\rightarrow A)\quad 对 1、2 使用分离规则 \\4.\quad A\rightarrow (A\rightarrow A)\quad 公理 1\\5.\quad A\rightarrow A\quad 对 3、4 使用分离规则 \end{array}$$</p>
<p>1、2、4 都是公理，不需要证明。上述 5 个公式序列即为证明。</p>
<h4 id="演绎 -A-B-rightarrow-A-rightarrow-C-vdash-B-rightarrow-C"><a href="# 演绎 -A-B-rightarrow-A-rightarrow-C-vdash-B-rightarrow-C" class="headerlink" title="演绎 ${A,B\rightarrow(A\rightarrow C)}\vdash B\rightarrow C$"></a>演绎 ${A,B\rightarrow(A\rightarrow C)}\vdash B\rightarrow C$</h4><p>$$\begin{array}{l}1.\quad A\quad 前提 \\2.\quad B\rightarrow (A\rightarrow C)\quad 前提 \\3.\quad A\rightarrow (B\rightarrow A)\quad 公理 1\\4.\quad B\rightarrow A\quad 对 1、3 用分离规则 \\5.\quad (B\rightarrow (A\rightarrow C))\rightarrow ((B\rightarrow A)\rightarrow(B\rightarrow C))\quad 公理 2\\6.\quad (B\rightarrow A)\rightarrow (B\rightarrow C)\quad 对 2、5 用分离规则 \\7.\quad B\rightarrow C\quad 对 4、6 用分离规则 \end{array}$$</p>
<h3 id="三个元定理"><a href="# 三个元定理" class="headerlink" title="三个元定理"></a>三个元定理 </h3><p> 三个元定理是为了让证明、演绎的过程更加简洁，快速。之所以叫元定理因为这是关于定理证明的定理。 </p>
<h4 id="演绎定理"><a href="# 演绎定理" class="headerlink" title="演绎定理"></a>演绎定理 </h4><p> 对任意公式集合 $\Gamma$ 和公式 $A，B$，有 $\Gamma\vdash A\rightarrow B$ 当且仅当 $\Gamma\cup{A}\vdash B$</p>
<p>当 $\Gamma=\varnothing$ 时，$\vdash A\rightarrow B$ 当且仅当 ${A}\vdash B$ ，或 $A\vdash B$ </p>
<p>证明必要性：</p>
<p>有 $A\rightarrow B$ ，加上 $A$ ，分离规则得到 $B$</p>
<p>证明充分性：</p>
<p>有 $B$ , 以及公理 $B\rightarrow (A\rightarrow B)$ ，分离规则得到 $A\rightarrow B$</p>
<h4 id="归谬定理"><a href="# 归谬定理" class="headerlink" title="归谬定理"></a>归谬定理 </h4><p> 对任何公式集合 $\Gamma$ 和公式 $A、B$ ，若 $\Gamma\cup{\lnot A}\vdash B$ ，$\Gamma\cup{\lnot A}\vdash\lnot B$，那么 $\Gamma\vdash A$</p>
<p>如果同一组前提能推导出相互矛盾的结果，说明这组前提之间相互不一致，也就是说总有一些前提是其余前提的对立面。</p>
<h4 id="穷举定理"><a href="# 穷举定理" class="headerlink" title="穷举定理"></a>穷举定理 </h4><p> 对任何公式集合 $\Gamma$ 和公式 $A、B$，若 $\Gamma\cup{\lnot A}\vdash B$，$\Gamma\cup{A}\vdash B$ 那么 $\Gamma\vdash B$ 。</p>
<p>如果一个前提能推出结论，这个前提的反面也能推出相同的结论，说明结论的成立与此前提是否成立无关。</p>
<h4 id="元定理简化证明"><a href="# 元定理简化证明" class="headerlink" title="元定理简化证明"></a>元定理简化证明 </h4><p> 证明 $\vdash\lnot\lnot A\rightarrow A$</p>
<p>$$\begin{array}{l}1.\quad \lnot\lnot A\rightarrow (\lnot A\rightarrow\lnot\lnot A)\quad 公理 1\\2.\quad \lnot\lnot A\vdash\lnot A\rightarrow\lnot\lnot A\quad 对 1 使用演绎定理 \\3.\quad{\lnot\lnot A,\lnot A}\vdash\lnot\lnot A\quad 对 2 再次使用演绎定理 \\4.\quad \lnot A\rightarrow (\lnot\lnot A\rightarrow\lnot A)\quad 公理 1\\5.\quad {\lnot A,\lnot\lnot A}\vdash \lnot A \quad 两次对 4 使用演绎原理 \\6.\quad {\lnot\lnot A}\vdash A\quad 根据 3、5 由归谬定理得出 \\7.\quad \vdash\lnot\lnot A\rightarrow A \quad 对 6 使用演绎定理 \end{array}$$</p>
<p>证明 $\vdash (A\rightarrow C)\rightarrow((B\rightarrow C)\rightarrow((\lnot A\rightarrow B)\rightarrow C))$</p>
<p>根据演绎定理，只需要证明 ${A\rightarrow C,B\rightarrow C,\lnot A\rightarrow B}\vdash C$</p>
<p>在左边添加 $A$ ，由 $A$ 和 $A\rightarrow C$ 根据分离规则得 $C$</p>
<p>在左边添加 $\lnot A$ ，由 $\lnot A\rightarrow B$ 、$\lnot A$、$B\rightarrow C$ 根据分离规则得 $C$ </p>
<p>因此，根据穷举定理证明 ${A\rightarrow C, B\rightarrow C, \lnot A\rightarrow C}\vdash C$</p>
<h3 id="定理判定问题"><a href="# 定理判定问题" class="headerlink" title="定理判定问题"></a>定理判定问题 </h3><p> 形式系统定义就是符号串集合的构造性定义。</p>
<blockquote>
<p>所谓构造性定义，就是提供一些规则从无到有，从少到多生成整个符号串集合</p>
<p>符号体系规定了符号串可能包含的字符，例如命题变元、常元和公式定理</p>
<p>公理规定了符号串的模式，例如 PC 中的公理，只要是符合公理模式的命题公式必定属于符号串集合中</p>
<p>推理规则规定了从集合中已知符号变换生成集合中其他符号串的方法</p>
</blockquote>
<p>因此，形式系统中的定理就是集合中的符号串，定理的证明过程就是符号串的构造过程，这个过程必须在有限步内结束。</p>
<p>能否单靠形式系统本身的公理和推理规则在有限步骤内判断一个符号串是否在符号串集合中？</p>
<p>仅靠形式系统本身的公理和推理规则难以保证在有限步骤内判断一个符号串是否在符号串集合中的。</p>
<p>解决方法就是依靠形式系统的同构，来判定。例如 PC 系统可以利用同构：真值函数运算系统，只需要用真值表判定命题公式对应的真值函数是否重言式，即可判定是否是 PC 中的定理。</p>
<blockquote>
<p>同构，意思就是结构是相同的，只是使用的符号不同</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;# 概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;../images/propostion_01.png&quot; alt=&quot;概览图&quot;&gt;&lt;/p&gt;
&lt;h
    
    </summary>
    
      <category term="Mathematical Logic" scheme="http://blog.freeabyss.com/categories/Mathematical-Logic/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="article" scheme="http://blog.freeabyss.com/tags/article/"/>
    
  </entry>
  
  <entry>
    <title>数理逻辑简介 1</title>
    <link href="http://blog.freeabyss.com/Mathematical-Logic/Math-DL-01-%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E7%AE%80%E4%BB%8B.html"/>
    <id>http://blog.freeabyss.com/Mathematical-Logic/Math-DL-01-数理逻辑简介.html</id>
    <published>2017-03-25T12:16:13.000Z</published>
    <updated>2017-03-25T13:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数理逻辑由来"><a href="# 数理逻辑由来" class="headerlink" title="数理逻辑由来"></a>数理逻辑由来 </h2><p> 说起数理逻辑就要先提下逻辑学。逻辑学是探索、阐述和确立有效 <strong> 推理规则 </strong> 的学科，最早由古希腊学者亚里士多德创立。 亚里士多德最重要的工作是提出三段论学说。一个三段论就是包括有大前提、小前提和结论三部分的论证。 </p>
<p>逻辑学还是以自然语言来表述，可能会因为自然语言的 <strong> 模糊性 </strong> 损害其准确性和权威。在十七世纪的时候，就有人提出利用计算的方法来代替人们思维中的逻辑推理过程。莱布尼茨就曾设想能不能创造一种「通用的科学语言」，可以把推理过程象数学一样利用公式来进行计算，从而得出正确结论。由于当时的条件，他的想法没有实现。</p>
<p>1847 年，英国数学家布尔 G.Boole 发表了《逻辑的数学分析》，建立了「布尔代数」。布尔创造了一套符号系统，利用符号来表示逻辑中的各种概念。还建立了一系列的运算法则，利用代数的方法研究逻辑问题，初步奠定了 <strong> 数理逻辑 </strong> 的基础。</p>
<p>1884 年，德国数学家弗雷格在《数论基础》一书中引入了 <strong> 量词 </strong> 的符号，使得数理逻辑的符号系统更加完备。</p>
<p>数理逻辑的最基本的理论基础逐步形成，成为一门独立的学科。  </p>
<p>数理逻辑就是使用数学的方式来研究关于推理、证明等问题的学科。</p>
<h2 id="数理逻辑的分支"><a href="# 数理逻辑的分支" class="headerlink" title="数理逻辑的分支"></a>数理逻辑的分支 </h2><p> 目前数理逻辑有四大分支，分别是：</p>
<ul>
<li>公理集合论：该分支是由于罗素的 <strong> 逻辑悖论</strong>，促使很多数学家去研究集合论的无矛盾性问题产生的。</li>
<li>证明论：为了研究数学系统的无矛盾性问题，需要以数学理论体系的概念、命题、证明等作为研究对象，研究数学系统的逻辑结果和证明的规律，这样产生的。</li>
<li>递归论：主要研究可计算性的理论，它和计算机的发展和应用有密切的关系</li>
<li>模型论：主要是研究形式系统和数学模型之间的关系。</li>
</ul>
<p><strong>命题演算 </strong> 和<strong>谓词演算 </strong> 是各分支的共同基础部分。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数理逻辑由来&quot;&gt;&lt;a href=&quot;# 数理逻辑由来&quot; class=&quot;headerlink&quot; title=&quot;数理逻辑由来&quot;&gt;&lt;/a&gt;数理逻辑由来 &lt;/h2&gt;&lt;p&gt; 说起数理逻辑就要先提下逻辑学。逻辑学是探索、阐述和确立有效 &lt;strong&gt; 推理规则 &lt;/stron
    
    </summary>
    
      <category term="Mathematical Logic" scheme="http://blog.freeabyss.com/categories/Mathematical-Logic/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="article" scheme="http://blog.freeabyss.com/tags/article/"/>
    
  </entry>
  
  <entry>
    <title>Mac 下安装 Node.js</title>
    <link href="http://blog.freeabyss.com/Node/JavaScript-node-Mac%20%E5%AE%89%E8%A3%85%20Node.js%20.html"/>
    <id>http://blog.freeabyss.com/Node/JavaScript-node-Mac 安装 Node.js .html</id>
    <published>2017-03-25T11:47:43.000Z</published>
    <updated>2017-03-26T01:19:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h2><p> 安装 Node.js （以下简称 node）有很多种方式。在 Mac 下常用的方式是使用 Homebrew 进行安装。不过由于 node 更新频繁，在开发过程中很有可能会有切换 node 版本的需求，因此建议使用 nvm 安装管理 node。Homebrew 上面虽然有 nvm 但是官方不建议使用 Homebrew 进行安装。我也用过 Homebrew 安装过，不过容易出问题，最终又卸载了。 </p>
<p>本文包括两方面内容： </p>
<ul>
<li>安装 nvm</li>
<li>使用 nvm 管理 node 版本</li>
</ul>
<h2 id="安装 -nvm"><a href="# 安装 -nvm" class="headerlink" title="安装 nvm"></a>安装 nvm</h2><p>如果用过 Homebrew 安装过 nvm 建议您卸载了，<code>brew uninstall nvm</code></p>
<p>详细的安装流程可以参阅官方文档 <a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a></p>
<p>安装命令如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash</div></pre></td></tr></table></figure>
<p>安装完毕后，不需要额外的配置即可使用 ，以下内容会被自动的添加到 profile 文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</div><div class="line">[-s &quot;$NVM_DIR/nvm.sh&quot;] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</div></pre></td></tr></table></figure>
<h2 id="使用 -nvm- 管理 -Node-js"><a href="# 使用 -nvm- 管理 -Node-js" class="headerlink" title="使用 nvm 管理 Node.js"></a>使用 nvm 管理 Node.js</h2><p>nvm 切换 node 版本的原理无非通过是修改环境变量，指向不同版本的 node 所在的路径。</p>
<p>以下是常有的 nvm 命令，更多命令参考 <a href="https://github.com/creationix/nvm/blob/master/README.markdown" target="_blank" rel="external">nvm github 地址</a></p>
<p><code>nvm ls-remote</code> 查看可安装的版本</p>
<p><code>nvm install &lt;version&gt;</code> 安装指定版本的 node</p>
<p><code>nvm ls</code>  列出目前安装的版本</p>
<p><code>nvm use &lt;version&gt;</code> 切换版本，<code>use</code>  命令只对当前 shell 窗口有效</p>
<p><code>nvm alias default &lt;version&gt;</code> 设置默认的 node 版本，对所有 shell 窗口有效</p>
<p><code>nvm install node</code>  安装最新的 node</p>
<p><code>nvm use node</code>  使用最新的 node</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;# 前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言 &lt;/h2&gt;&lt;p&gt; 安装 Node.js （以下简称 node）有很多种方式。在 Mac 下常用的方式是使用 Homebrew 进行安装。不过由于 nod
    
    </summary>
    
      <category term="Node" scheme="http://blog.freeabyss.com/categories/Node/"/>
    
    
      <category term="JavaScript" scheme="http://blog.freeabyss.com/tags/JavaScript/"/>
    
      <category term="Node" scheme="http://blog.freeabyss.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 树的基本概念 38</title>
    <link href="http://blog.freeabyss.com/Math/Math-DM-38-%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html"/>
    <id>http://blog.freeabyss.com/Math/Math-DM-38-树的基本概念.html</id>
    <published>2017-03-21T12:13:04.000Z</published>
    <updated>2017-03-21T13:13:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="# 概述" class="headerlink" title="概述"></a>概述 </h2><p><strong> 树</strong>是没有简单回路的连通无向图。 因为树没有简单回路，所以树不含多重边或环，因此任何树必然是简单图。      </p>
<p>另一个定义是：一个无向图是树当且仅当它在每对顶点之间存在唯一简单通路。       </p>
<h3 id="一些常用的术语"><a href="# 一些常用的术语" class="headerlink" title="一些常用的术语"></a>一些常用的术语 </h3><p><strong> 根树 </strong> 是指定一个顶点作为根并且每条边的方向都离开根的树。    </p>
<p>若 $u$ 是 $T$ 里非根的顶点，则 $u$ 的 <strong> 父母 </strong> 是使得从 $u$ 到 $v$ 存在有向边的唯一的顶点 $u$ 。当 $u$ 是 $v$ 的父母时，$v$ 称为 $u$ 的 <strong> 子女 </strong>。具有相同父母的顶点称为<strong> 兄弟 </strong>。非根顶点的<strong> 祖先 </strong> 是从根到该顶点的通路上的顶点，不包括该顶点自身，但包括根。顶点 $v$ 的后代是以 $v$ 作为祖先的顶点。树的顶点若没有子女称为 <strong> 树叶 </strong>。有子女的顶点称为<strong> 内点</strong>。        </p>
<p>根树的 <strong> 层数 </strong> 是从根到任意顶点的最大通路的长度。   </p>
<p>若跟树的每个内点都有不超过 $m$ 个子女，则称它为 $m$ 元树。若该树的每个内点都恰好有 $m$ 个子女，则称它为 <strong> 正则 </strong> $m$ <strong> 元树 </strong> 。把 $m=2$ 的正则 $m$ 元树称为<strong> 二叉树</strong>。</p>
<blockquote>
<p>注意，在计算机科学中，二叉树的定义是每个内点不超过 2 个子女的树，也即 2 元树。</p>
</blockquote>
<h2 id="树的性质"><a href="# 树的性质" class="headerlink" title="树的性质"></a>树的性质 </h2><p> 带有 $n$ 个顶点的树含有 $n-1$ 条边。     </p>
<p>带有 $i$ 个内点的正则 $m$ 元树含有 $n=mi+1$ 个顶点。    </p>
<p>一个正则 $m$ 元树若带有      </p>
<ul>
<li>$n$ 个顶点，则带有 $i=(n-1)/m$ 个内点和 $l=[(m-1)n+1]/m$ 个树叶； </li>
<li>$i$  个内点，则带有 $n=mi+1$ 个顶点和 $l=(m-1)i+1$ 个树叶； </li>
<li>$l$  个树叶，则带有 $n=(ml-1)/(m-1)$ 个顶点和 $i=(l-1)/(m-1)$ 个内点。    </li>
</ul>
<p>若一颗高度为 $h$ 的 $m$ 元树的所有顶点都在 $h$ 层或 $h-1$ 层，则这棵树是平衡的。<br>在高度为 $h$ 的 $m$ 元树里至多有 $m^h$ 个树叶。      </p>
<p>若一个高度为 $h$ 的 $m$ 元树带有 $l$ 个树叶，则 $h\ge\lceil log_ml\rceil$。 若这个 $m$ 元树势正则和平衡的，则 $h=\lceil log_ml\rceil$ 。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;# 概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述 &lt;/h2&gt;&lt;p&gt;&lt;strong&gt; 树&lt;/strong&gt;是没有简单回路的连通无向图。 因为树没有简单回路，所以树不含多重边或环，因此任何树必然是简单图。 
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="tree" scheme="http://blog.freeabyss.com/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>Java 浅析序列化</title>
    <link href="http://blog.freeabyss.com/Java/Java-Java-%E5%BA%8F%E5%88%97%E5%8C%96.html"/>
    <id>http://blog.freeabyss.com/Java/Java-Java-序列化.html</id>
    <published>2017-03-18T06:44:26.000Z</published>
    <updated>2017-03-19T14:42:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h2><p> 本篇文章从以下几个方面，讲述 Java 序列化相关的内容： </p>
<blockquote>
<ul>
<li>什么是序列化？</li>
<li>如何实现序列化？</li>
<li>修改默认的序列化机制</li>
<li>多个对象共享一个引用时，序列化和反序列化会有什么结果？</li>
<li>如何解决兼容问题？</li>
<li>序列化应用时需要注意的问题</li>
<li>父类的序列化问题</li>
<li>安全问题</li>
</ul>
</blockquote>
<h2 id="什么是序列化"><a href="# 什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化 </h2><p><strong> 序列化 </strong> 是指将对象表示为一个字节序列的过程，该字节序列包含对象所存储的数据、数据的类型以及对象的类型信息。 <strong>反序列化 </strong> 是将字节序列转化为对象的过程。<br>序列化是对对象的持久化，将对象序列化后可以存入文件中，也可以通过网络传递到远程服务器中。         </p>
<h2 id="实现序列化"><a href="# 实现序列化" class="headerlink" title="实现序列化"></a>实现序列化 </h2><p> 在实现序列化的过程中，需要用到三个类 <code>ObjectInputStream</code>、<code>ObjectOutputStream</code> 和<code>Serializable</code>。首先，让需要序列化的对象所属类实现 <code>Serializable</code> 接口，该接口不需要实现任何方法，是典型的标记接口。 然后使用 <code>ObjectInputStream</code>、<code>ObjectOutputStream</code> 进行读写。   </p>
<script src="//gist.github.com/3d8ae4af25273ee8fec1c10c5c0002a2.js"></script>
<p>当存储一个对象时，这个对象所属的类也必须存储，这个类的描述包含 </p>
<ul>
<li>类名。</li>
<li>序列化的版本唯一的 ID，它是通过对类、超类、接口、域类型和方法签名按照规范方式排序，然后应用 SHA 算法获得，并且只取前 8 位。它相当于一个类的指纹，假如类中存在 <code>serialVersionUID</code> 字段，则用它作为类的指纹。     </li>
<li>描述序列化方法的标志集。</li>
<li>对数据域的描述。  </li>
</ul>
<p>静态变量和被 <code>transient</code> 修饰的变量将不会被序列化。除非超类也实现了 <code>Serializable</code> 接口，否则超类的数据域不会被序列化。   </p>
<h2 id="修改默认的序列化机制"><a href="# 修改默认的序列化机制" class="headerlink" title="修改默认的序列化机制"></a>修改默认的序列化机制 </h2><p>Java 提供了三种方式，用以修改默认的序列化机制。<br> 考虑以下这种情况，某些数据域，例如只对本地方法有意义的存储文件句柄，这种信息在重新加载或传送到其他机器上时都是没有用处的，甚至会引起程序崩溃。因此为了防止这种情况，使用 <code>transient</code> 修饰符，被该修饰符修饰后的数据域将被序列化机制跳过。       </p>
<p>另外一种情况是，类中的某些数据域没有实现 <code>Serializable</code> 接口，却又要将其序列化，这时就需要先将其标记为 <code>transient</code> 避免抛出 <code>NotSerializableException</code>，然后通过重写<code>readObject</code> 和<code>writeObject</code>方法，自定义序列化。这种两个方法是私有的，并且只能被序列化机制调用。   </p>
<p>下面是一个典型示例，在 <code>java.awt.geom</code> 包中有大量的类都是不可序列化的，例如<code>Point2D.Double</code>，现在要序列化一个包含该类型字段的类，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LabeledPoint</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String label;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> Point2D.Double point;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</div><div class="line">        in.defaultReadObject();</div><div class="line">       	<span class="keyword">double</span> x = in.readDouble();</div><div class="line">       	<span class="keyword">double</span> y = in.readDouble();</div><div class="line">       	point = <span class="keyword">new</span> Point2D.Double(x, y);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        out.defaultWriteObject();</div><div class="line">        out.writeDouble(point.getX());</div><div class="line">        out.writeDouble(point.getY());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>defaultWriteObject</code>和 <code>defaultReadObject</code> 是特殊的方法，只能在序列化类的 <code>writeObject</code> 和<code>readObject</code>方法中被调用。<code>defaultWriteObject</code>表示使用默认的序列化机制，<code>defaultReadObject</code>反之。这两个方法也可以不调用，这样就跟下面讲的 <code>Externalizable</code> 接口差不多。      </p>
<p>除了重写 <code>readObject</code> 和<code>writeObject</code>方法修改默认的序列化机制外，还可使用 <code>Externalizable</code> 接口，自定义序列化机制。     </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String title;</div><div class="line">    <span class="keyword">private</span> String bonus;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        out.writeUTF(title);</div><div class="line">        out.writeUTF(bonus);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">        title = in.readUTF();</div><div class="line">        bonus = in.readUTF();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Externalizable 和 Serializable 的不同"><a href="#Externalizable 和 Serializable 的不同" class="headerlink" title="Externalizable 和 Serializable 的不同"></a><code>Externalizable</code>和 <code>Serializable</code> 的不同 </h3><p><code>Externalizable</code> 和<code>Serializable</code>最大的不同就是，<code>Externalizable</code>会调用类的无参构造函数来创建对象，<code>Serializable</code>则不然。  另外就是 <code>readObject</code> 和<code>writeObject</code>只能被序列化机制调用，而 <code>readExternal</code> 和<code>writeExternal</code>方法是公共的。   </p>
<h2 id="序列化中遇到的问题"><a href="# 序列化中遇到的问题" class="headerlink" title="序列化中遇到的问题"></a>序列化中遇到的问题 </h2><p> 在序列化中，有一个重要的情况需要考虑：当一个对象被多个对象共享，作为它们各种状态的一部分时，会发生什么情况？ </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Employee secretary;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Employee tony = <span class="keyword">new</span> Employee();</div><div class="line">        tony.setName(<span class="string">"Tony"</span>);</div><div class="line">        tony.setSalary(<span class="number">10000</span>);</div><div class="line">        tony.setHireDay(<span class="keyword">new</span> Date());</div><div class="line"></div><div class="line">        Manager harry = <span class="keyword">new</span> Manager();</div><div class="line">        harry.setSalary(<span class="number">1000</span>);</div><div class="line">        harry.setName(<span class="string">"Harry"</span>);</div><div class="line">        harry.setSecretary(tony);</div><div class="line"></div><div class="line">        Manager carl = <span class="keyword">new</span> Manager();</div><div class="line">        carl.setName(<span class="string">"Carl"</span>);</div><div class="line">        carl.setSalary(<span class="number">10000</span>);</div><div class="line">        carl.setSecretary(tony);</div><div class="line"></div><div class="line">        ByteArrayOutputStream byteArr = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">        <span class="keyword">try</span> (ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(byteArr)) &#123;</div><div class="line">            out.writeObject(harry);</div><div class="line">            out.writeObject(carl);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> (ByteArrayInputStream input = <span class="keyword">new</span> ByteArrayInputStream(byteArr.toByteArray());</div><div class="line">             ObjectInputStream objInput = <span class="keyword">new</span> ObjectInputStream(input)) &#123;</div><div class="line">            Manager harry1 = (Manager) objInput.readObject();</div><div class="line">            Manager carl1 = (Manager) objInput.readObject();</div><div class="line">            <span class="comment">// out true</span></div><div class="line">            System.out.println(harry1.getSecretary() == carl1.getSecretary());</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过序列化后，两个对象依然共享同一对象。造成这种现象的原因是：每个对象都是用一个序列号（serial number，即前面提到的「指纹」）保存的，这也是这种机制之所以被称为对象序列化的原因。 下面是其算法：    </p>
<ul>
<li>对你遇到的每一个对象引用都关联一个序列号。    </li>
<li>对于每个对象，当第一次遇到时，保存其对象数据到流中。    </li>
<li>如果某个对象之前已经被保存过，那么只写出「与之前保存过的序列号为 $x$ 的对象相同」。 在读回对象时，整个过程是反过来的。   </li>
<li>当遇到「与之前保存过的序列号为 $x$ 的对象相同」标记时，获取与这个顺序号相关联的对象引用。   </li>
</ul>
<blockquote>
<p>因为保存原生的内存地址毫无意义，因此序列化用序列号代替了内存地址。   </p>
</blockquote>
<h2 id="如何解决兼容问题"><a href="# 如何解决兼容问题" class="headerlink" title="如何解决兼容问题"></a>如何解决兼容问题 </h2><p> 如果使用序列化保存对象，就需要考虑版本问题，修改后的类能否读入旧文件？或者反之旧版本能否读入新版本产生的文件。      </p>
<p>这时候就体现到 <code>serialVersionUID</code> 字段的重要性来了。假设将 SHA 指纹作为序列化版本的唯一 ID 的话，无论类的定义产生了什么样的变化，它的 SHA 指纹也会跟着变化，而我们都知道对象流将拒绝读入具有不同指纹的对象。为了保持兼容性，我们必须使用 <code>serialVersionUID</code> 常量作为序列化版本的唯一 ID。      </p>
<p>如果这个类只有方法发生了变化，那么在读入新对象数据时是不会有任何问题的。但是，如果数据域产生了变化，那么就有可能会有问题，不过对象流将尽力将流对象转化成这个类的当前版本。   </p>
<p>对象流会将这个类当前版本的数据域与流中版本的数据域进行比较，当然，对象流只会考虑非静态和非 <code>transient</code> 的数据域。    </p>
<ul>
<li>如果名字匹配而类型不匹配，那么对象流不会尝试将一种类型转换成另一种类型，因为这两个对象不兼容。   </li>
<li>如果流中对象具有在当前版本中所没有的数据域，那么对象流会忽略这些额外的数据。    </li>
<li>如果当前版本具有在流中对象所没有的数据域，那么这些新添加的域将被设置成它们的默认值。   </li>
</ul>
<p>这种丢弃数据域或者将数据域设置为 <code>null</code> 有可能会产生 bug，建议设计者重写 <code>readObject</code> 方法来修订版本不兼容问题。   </p>
<h2 id="序列化应用时需要注意的问题"><a href="# 序列化应用时需要注意的问题" class="headerlink" title="序列化应用时需要注意的问题"></a>序列化应用时需要注意的问题 </h2><h3 id="序列化单例和类型安全的枚举"><a href="# 序列化单例和类型安全的枚举" class="headerlink" title="序列化单例和类型安全的枚举"></a> 序列化单例和类型安全的枚举 </h3><p> 如果你使用 Java 语言的 <code>enum</code> 结构，那么不用担心序列化，它能够正常工作。但考虑以下风格的代码：    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orientation</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Orientation HORIZONTAL = <span class="keyword">new</span> Orientation(<span class="number">1</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Orientation VERTICAL = <span class="keyword">new</span> Orientation(<span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Orientation</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种风格的代码在 <code>enum</code> 之前很常见，这个类的构造器是私有的，你不可能创建除 <code>HORIZONTAL</code> 和<code>VERTICAL</code>之外的对象，因此你可以使用 <code>==</code> 操作符来测试对象的等同性。      </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (orientation == Orientation.HORIZONTAL) ...</div></pre></td></tr></table></figure>
<p>当我们序列化这样的类时，既是构造器是私有的，序列化机制也可以创建新的对象（序列化机制不通过构造器创建对象），因此上述代码就会产生 bug。    </p>
<p>为了解决这个问题，我们需要定义另外一种称为 <code>readResolve</code> 的特殊序列化方法。该方法会在对象被序列化之后被调用。它必须返回一个对象，而该对象之后会成为 <code>readObject</code> 的返回值。因此我们可以这么做：    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value == <span class="number">1</span>) <span class="keyword">return</span> HORIZONTAL;</div><div class="line">    <span class="keyword">if</span> (value == <span class="number">2</span>) <span class="keyword">return</span> VERTICAL;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请记住向遗留代码中所有类型安全的枚举以及向所有支持单例设计模式的类中添加 <code>readResolve</code> 方法。 </p>
<h3 id="使用序列化 clone 对象"><a href="# 使用序列化 clone 对象" class="headerlink" title="使用序列化 clone 对象"></a>使用序列化 clone 对象 </h3><p> 序列化机制有一种很有趣的用法，即提供了一种 <code>clone</code> 对象的简便途径，只需要将对象序列化到输出流中，并且将其读回。这种方式虽然方便，但性能比显式地构建新对象的方式慢的多。  </p>
<h2 id="父类的序列化问题"><a href="# 父类的序列化问题" class="headerlink" title="父类的序列化问题"></a>父类的序列化问题 </h2><p> 一个子类实现了 <code>Serializable</code> 接口，而它的父类没有实现 <code>Serializable</code> 接口，那么序列化时父类所属的数据域并不会被序列化。<strong>要想父类也序列化，就需要让父类也实现 <code>Serializable</code> 接口</strong>。     </p>
<p>有一点非常重要，如果父类没有实现 <code>Serializable</code> 接口的话，就 <strong> 需要有默认的无参的构造函数 </strong>。这是因为在父类没有实现<code>Serializable</code> 接口时，虚拟机不会序列化父对象，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不列外。  </p>
<h2 id="安全问题"><a href="# 安全问题" class="headerlink" title="安全问题"></a>安全问题 </h2><p> 序列化后的字节序列并没有加密，若被黑客窃取了这部分数据，很容易的解析出数据域里的内容。 一个解决方案就是重写 <code>writeObject</code> 方法，对敏感内容加密后写入对象流，然后在 <code>readObject</code> 中解密。   </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;# 前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言 &lt;/h2&gt;&lt;p&gt; 本篇文章从以下几个方面，讲述 Java 序列化相关的内容： &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;什么是序列化？&lt;/l
    
    </summary>
    
      <category term="Java" scheme="http://blog.freeabyss.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.freeabyss.com/tags/Java/"/>
    
      <category term="IO" scheme="http://blog.freeabyss.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 图着色 37</title>
    <link href="http://blog.freeabyss.com/Math/Math-DM-37-%E5%9B%BE%E7%9D%80%E8%89%B2.html"/>
    <id>http://blog.freeabyss.com/Math/Math-DM-37-图着色.html</id>
    <published>2017-03-01T13:55:38.000Z</published>
    <updated>2017-03-06T13:57:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图着色"><a href="# 图着色" class="headerlink" title="图着色"></a>图着色 </h2><p> 在图论中，有许多与地图区域着色相关的理论成果。当为一个地图着色时，具有公共边界的两个区域在传统上指定为不同的颜色。<br>平面里的每幅地图都可以表示成一个图，为了建立这种对应关系，地图的每个区域都表示成一个顶点，若两个顶点所表示的区域具有公共边界。则用边连接两个顶点。只相交于一个点的两个区域不算事相邻的。这样所得到的图称为这个地图的对偶图。这样区域着色的问题就等价于给对偶图的顶点着色，使没有两个相邻的顶点具有相同的颜色的问题。    </p>
<p>简单图的着色是对该图的每个顶点都指定一种颜色，使得没有两个相邻的顶点颜色相同。    </p>
<p>图的色数是着色这个图所需要的最少颜色数。    </p>
<h3 id="一些结论"><a href="# 一些结论" class="headerlink" title="一些结论"></a>一些结论</h3><ul>
<li><strong>四色定理</strong> 平面图的色数不超过 4。    </li>
</ul>
<blockquote>
<p>证明一个图的色数为 <code>n</code> 需要做两件事情。首先必须证明：用 $n$ 种颜色可以着色这个图并且构造出这样的着色。其次证明：用少于 $n$ 种颜色不能着色这个图。    </p>
</blockquote>
<ul>
<li>$K_n$ 的色数是 $n$。 该结论与四色定理并不矛盾，因为 $n\ge 5$ 时，$K_n$ 不是可平面图。    </li>
<li>完全偶图 $K_{m,n}$ 只需要两种颜色。      </li>
<li>圈图 $C_n$ 的色数分两种情况，当 $n$ 为偶数时需要两种颜色，当 $n$ 为奇数时需要三种颜色。    </li>
</ul>
<h3 id="算法复杂度"><a href="# 算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度 </h3><p> 已知最好的求图的色数的算法具有指数的最坏情形时间复杂性。即使求色数的近似值也是很难的。</p>
<h3 id="图着色的应用"><a href="# 图着色的应用" class="headerlink" title="图着色的应用"></a>图着色的应用 </h3><p> 图着色在与调度和分配相关的问题中具有多种应用。   </p>
<h4 id="安排期末考试"><a href="# 安排期末考试" class="headerlink" title="安排期末考试"></a>安排期末考试 </h4><p> 安排一场期末考试，使得没有学生要同时考两门。<br>用图模型来解决： 用顶点表示科目，若有学生要考两门，则在表示考试科目的两个顶点之间有边。用不同的颜色表示期末考试的时间段。那么考试所需的时间段就是色数。    </p>
<h4 id="变址寄存器"><a href="# 变址寄存器" class="headerlink" title="变址寄存器"></a>变址寄存器 </h4><p> 在有效的编译器中，当把频繁地使用的变量暂时保存在中央处理单元的变址寄存器里，而不是保存在常规内存时，可以加速循环的执行。对于给定的循环来说，需要多少个变址寄存器？<br>可以用图着色模型来讨论这个问题。为了建立这个模型，设图的每个顶点表示循环里的一个变量。若在循环执行期间两个顶点所表示的变量必须同时保存在变址寄存器里，则在这两个顶点之间有边。所以，这个图的色数就给出所需要的变址寄存器数，因为当表示变量的顶点在图中相邻时，就必须给这些变量分配不同的寄存器。    </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图着色&quot;&gt;&lt;a href=&quot;# 图着色&quot; class=&quot;headerlink&quot; title=&quot;图着色&quot;&gt;&lt;/a&gt;图着色 &lt;/h2&gt;&lt;p&gt; 在图论中，有许多与地图区域着色相关的理论成果。当为一个地图着色时，具有公共边界的两个区域在传统上指定为不同的颜色。&lt;br&gt;平面
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="graph" scheme="http://blog.freeabyss.com/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 可平面图 36</title>
    <link href="http://blog.freeabyss.com/Math/Math-DM-36-%E5%8F%AF%E5%B9%B3%E9%9D%A2%E5%9B%BE.html"/>
    <id>http://blog.freeabyss.com/Math/Math-DM-36-可平面图.html</id>
    <published>2017-03-01T13:22:27.000Z</published>
    <updated>2017-03-04T07:55:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可平面图"><a href="# 可平面图" class="headerlink" title="可平面图"></a>可平面图 </h2><p> 若可以在平面里画出一个图而边没有任何交叉（其中边的交叉是表示边的直线或弧线在它们的公共端点以外的地方相交），则这个图是可平面的。这种画法称为这个图的平面表示。即使通常带交叉地画出了一个图，这个图也仍然可能是可平面的，这是因为有可能以不同的方式来不带交叉地画出这个图。     </p>
<h3 id="欧拉公式"><a href="# 欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式 </h3><p> 设 $G$ 是带 $e$ 条边和 $v$ 个顶点的连通可平面简单图。设 $r$ 是 $G$ 的可平面表示里的面数，则 $r=e-v+2$。      </p>
<p>若 $G$ 是带 $e$ 条边和 $z$ 个顶点的连通可平面简单图，其中 $v\ge 3$，则 $e\le 3v-6$。    </p>
<p>若 $G$ 是连通简单可平面简单图，则 $G$ 有度数不超过 5 的顶点。    </p>
<p>若连通可平面简单图有 $e$ 条边和 $v$ 个顶点，$v\ge 3$ 并且没有长度为 3 的回路，则 $e\le 2v-4$。  </p>
<h3 id="库拉图斯基定理"><a href="# 库拉图斯基定理" class="headerlink" title="库拉图斯基定理"></a>库拉图斯基定理 </h3><p> 若一个图是可平面的，则通过删除一条边 ${u,v}$ 并且添加一个新顶点 $w$ 和两条边 ${u,w}$ 与 ${w,v}$，所获得的任何图也是可平面的。这样的操作称为 <strong> 初等细分 </strong>。若可以从相同的图通过一系列初等细分来获得图 $G_1=(\mathbf V_1,\mathbf E_1)$ 和图 $G_2=(\mathbf V_2,\mathbf E_2)$，则它们称为是<strong> 同胚 </strong> 的。      </p>
<p><strong>库拉图斯基定理</strong>&ensp;&ensp; 一个图是非可平面的当且仅当它包含一个同胚于 $K_{3,3}$ 或 $K_5$ 的子图。     </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;可平面图&quot;&gt;&lt;a href=&quot;# 可平面图&quot; class=&quot;headerlink&quot; title=&quot;可平面图&quot;&gt;&lt;/a&gt;可平面图 &lt;/h2&gt;&lt;p&gt; 若可以在平面里画出一个图而边没有任何交叉（其中边的交叉是表示边的直线或弧线在它们的公共端点以外的地方相交），则这个图是
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="graph" scheme="http://blog.freeabyss.com/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 最短通路问题 35</title>
    <link href="http://blog.freeabyss.com/Math/Math-DM-35-%E6%9C%80%E7%9F%AD%E9%80%9A%E8%B7%AF%E9%97%AE%E9%A2%98.html"/>
    <id>http://blog.freeabyss.com/Math/Math-DM-35-最短通路问题.html</id>
    <published>2017-02-27T13:32:16.000Z</published>
    <updated>2017-03-05T01:22:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最短通路"><a href="# 最短通路" class="headerlink" title="最短通路"></a>最短通路 </h2><p> 带权图是指给每条边赋上一个数的图。带权图可以为以下问题建模：城市之间的距离，计算机之间的通信成本等等。   </p>
<p>与带权图有关的其中一个问题就是，求两个顶点之间长度最短的通路，这里的长度指的是这条通路上各边的权的总和。   </p>
<h3 id="最短通路算法"><a href="# 最短通路算法" class="headerlink" title="最短通路算法"></a>最短通路算法 </h3><p> 最短通路有几个不同的解法，这里给出迪克斯特拉算法。迪克斯特拉算法是求解无向带权图的最短通路算法，其中所有的权都是正数，可以很容易地将它修改后来解决有向图里的最短通路问题。    </p>
<h4 id="迪克斯特拉算法细节"><a href="# 迪克斯特拉算法细节" class="headerlink" title="迪克斯特拉算法细节"></a>迪克斯特拉算法细节 </h4><p> 它首先用 $0$ 标记 $a$ ，用 $\infty$ 标记其余的顶点。用记号 $L_0(a)=0$ 和 $L_0(v)=\infty$ 表示在没有发生任何迭代之前的这些标记，下标 0 表示第 0 次迭代。这些表示是从 $a$ 到这些顶点的最短通路的长度，其中这些通路只包含顶点 $a$ 。因为不存在从 $a$ 到其他顶点的这种通路，所以 $\infty$ 是 $a$ 与这样的顶点之间的最短通路的长度。<br>迪克斯特拉算法是通过形成特殊顶点的集合来进行的。设 $S_k$ 表示在标记过程 $k$ 次迭代之后的特殊顶点集。首先让 $S_0=\varnothing$ 。集合 $S_k$ 是通过把不属于 $S_{k-1}$ 的带最小标记的顶点 $u$ 添加到 $S_{k-1}$ 里形成的。一旦把 $u$ 添加到 $S_k$ 里，就更新所有不属于 $S_k$ 的顶点的标记，使得顶点 $v$ 在第 $k$ 个阶段的标记 $L_k(v)$ 是只包含 $S_k$ 里顶点的、从 $a$ 到 $v$ 的最短通路的长度。<br>设 $v$ 是不属于 $S_k$ 的一个顶点。为了更新 $v$ 的标记，注意 $L_k(v)$ 是只包含 $S_k$ 里顶点的从 $a$ 到 $v$ 的最短通路的长度。当利用下面的观察结果时，就可以有效地完成这个更新：只包含 $S_k$ 里顶点的从 $a$ 到 $v$ 的最短通路，要么是只包含 $S_{k-1}$ 里顶点的从 $a$ 到 $v$ 的最短通路，要么是在第 $k-1$ 阶段加上边 $(u,v)$ 的从 $a$ 到 $u$ 的最短通路。换句话说 $L_k(a,v)=min{L_{k-1}(a,v),L_{k-1}(a,u)+w(u,v)}$<br>这个过程这样迭代：相继添加顶点到特殊顶点集里，直到添加 $z$ 为止。当把 $z$ 添加到特殊顶点集里时，它的标记就是从 $a$ 到 $z$ 的最短通路的长度。<br>$$<br>\begin{array}{l}<br>\mathbf {procedure} \;\mathcal {Dijkstra} (G: 所有权都为正数的带权连通简单图)\ <br>{G 带有顶点 a=v_0,v_1,\dots,v_n=z 和权 w(v_i,v_j), 其中若 {v_i,v_j} 不是 G 里的边，则 w(v_i,v_j)=\infty} \\<br>\mathbf {for}\; i:=1\;\mathbf {to}\;n \\<br>\qquad L(v_i):=\infty \\<br>L(a) :=0 \\<br>S:=\varnothing \\<br>{现在初始化标记，使得 a 的标记为 0 而所有其余标记为 \infty，S 是空集合} \\<br>\mathbf {while}\; z\notin S\\<br>\mathbf {begin}<br>\qquad a:= 不属于 S 的 L(u)最小的一个顶点 \ <br>\qquad S:=S\cup{u} \\<br>\qquad\mathbf {for}\; 所有不属于 S 的顶点 v\\<br>\qquad\qquad\mathbf {if}\; L(u)+w(u,v)&lt;L(v)\quad\mathbf {then}\; L(v):=L(u)+w(u,v)\\<br>\qquad {这样就给 S 里添加带最小标记的顶点，并且更新不在 S 里的顶点的标记} \\<br>\mathbf {end}{L(z)= 从 a 到 z 的最短通路的长度}<br>\end{array}<br>$$</p>
<h4 id="验证迪克斯拉特算法的正确性"><a href="# 验证迪克斯拉特算法的正确性" class="headerlink" title="验证迪克斯拉特算法的正确性"></a>验证迪克斯拉特算法的正确性 </h4><p> 下面用归纳论证来证明迪克斯特拉算法的正确性。用下列断言作为归纳假设：在第 $k$ 次迭代里   </p>
<ol>
<li>$S$ 里的顶点 $v(v=0)$ 的标记是从 $a$ 到这个顶点的最短通路的长度。    </li>
<li>不在 $S$ 里的顶点的标记是 (这个顶点自身除外) 只包含 $S$ 里顶点的、从 $a$ 到这个顶点的最短通路的长度</li>
</ol>
<p>当 $k=0$ 时，在没有执行任何迭代之前，$S={a}$，所以从 $a$ 到除 $a$ 外的顶点的最短通路的长度是 $\infty$。设 $v$ 是在第 $k+1$ 次迭代里添加到 $S$ 里的顶点，使得 $v$ 是在第 $k$ 次迭代结束时带最小标记的不在 $S$ 的顶点。<br>根据归纳假设，可以看出在第 $k+1$ 次迭代之前，$S$ 里的顶点都用从 $a$ 出发的最短通路的长度来标记。另外，必须用从 $a$ 到 $v$ 的最短通路的长度来标记 $v$。假如情况不是这样，那么在第 $k$ 次迭代结束时，就可能存在包含不在 $S$ 里的顶点的、长度小于 $L_k(v)$ 的通路（因为 $L_k(v)$ 是在第 $k$ 次迭代之后，只包含 $S$ 里顶点的、从 $a$ 到 $v$ 的最短通路的长度）。设 $u$ 是在这样的通路里不属于 $S$ 的第一个顶点。则存在一条只包含 $S$ 里顶点的、从 $a$ 到 $u$ 的长度小于 $L_k(v)$ 的通路。这与对 $v$ 的选择相矛盾。因此，在第 $k+1$ 次迭代结束时 (1) 成立。<br>设 $u$ 时在第 $k+1$ 次迭代之后不属于 $S$ 的一个顶点。只包含 $S$ 里顶点的从 $a$ 到 $u$ 的最短通路要么包含 $v$、要么不包含 $v$。若它不包含 $v$，则根据归纳假设，它的长度是 $L_k(u)$。若它确实包含 $v$，则它必然是这样组成的：一条只包含 $S$ 里除 $v$ 之外的顶点的、从 $a$ 到 $v$ 的、具有最短可能长度的通路，后面接着从 $v$ 到 $u$ 的边。在这种情形里它的长度是 $L_k(v)+w(v,u)$。这样就证明了 (2) 为真，因为 $L_{k+1}(u)=min{L_k(u),L_k(v)+w(v,u)}$。</p>
<h4 id="算法复杂度"><a href="# 算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度 </h4><p> 迪克斯特拉算法使用 $O(n^2)$ 次运算来求出连通简单无向带权图里两个顶点之间最短通路的长度。    </p>
<h2 id="旅行商问题"><a href="# 旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题 </h2><p> 旅行商问题是求最短回路，即求完全图里总权数最小的哈密顿回路。<br>旅行商问题同哈密顿回路一样，没有有效的算法，目前解决问题的实际方法是使用近似算法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;最短通路&quot;&gt;&lt;a href=&quot;# 最短通路&quot; class=&quot;headerlink&quot; title=&quot;最短通路&quot;&gt;&lt;/a&gt;最短通路 &lt;/h2&gt;&lt;p&gt; 带权图是指给每条边赋上一个数的图。带权图可以为以下问题建模：城市之间的距离，计算机之间的通信成本等等。   &lt;/p&gt;

    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="graph" scheme="http://blog.freeabyss.com/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>The server time zone value &#39;CST&#39; is unrecognized or represents more than one time zone.</title>
    <link href="http://blog.freeabyss.com/MySQL/MySQL-ERROR-01.html"/>
    <id>http://blog.freeabyss.com/MySQL/MySQL-ERROR-01.html</id>
    <published>2017-02-26T09:03:15.000Z</published>
    <updated>2017-02-26T09:04:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="错误代码"><a href="# 错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The server time zone value &apos;CST&apos; is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.</div></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="# 解决方案" class="headerlink" title="解决方案"></a>解决方案 </h2><p> 连接时，指定时区    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jdbc:mysql://localhost:3306/blog?serverTimezone=UTC</div></pre></td></tr></table></figure>
<h2 id="环境"><a href="# 环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>jdk.18</li>
<li>mysql-connector-java 6.0.2</li>
<li>jetty</li>
<li>idea 15</li>
<li>mysql 5.7.11</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;错误代码&quot;&gt;&lt;a href=&quot;# 错误代码&quot; class=&quot;headerlink&quot; title=&quot;错误代码&quot;&gt;&lt;/a&gt;错误代码&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.freeabyss.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.freeabyss.com/tags/MySQL/"/>
    
      <category term="error" scheme="http://blog.freeabyss.com/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>常用的正则表达式</title>
    <link href="http://blog.freeabyss.com/Regular/Regular-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
    <id>http://blog.freeabyss.com/Regular/Regular-常用的正则表达式.html</id>
    <published>2017-02-26T07:28:46.000Z</published>
    <updated>2017-03-14T14:34:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="匹配 HTML 标签"><a href="# 匹配 HTML 标签" class="headerlink" title="匹配 HTML 标签"></a> 匹配 HTML 标签 </h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:<span class="string">".*?"</span>|<span class="string">'.*?'</span>|[\\^<span class="string">'"&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;</span></div></pre></td></tr></table></figure>
<h3 id="抽取注释"><a href="# 抽取注释" class="headerlink" title="抽取注释"></a> 抽取注释 </h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;!--(.*?)--&gt;</div></pre></td></tr></table></figure>
<h3 id="查找 -CSS- 属性"><a href="# 查找 -CSS- 属性" class="headerlink" title="查找 CSS 属性"></a> 查找 CSS 属性 </h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^\\s*[a-zA-Z\\-]+\\s*[:]&#123;1&#125;\\s[a-zA-Z0-9\\s.#]+[;]&#123;1&#125;</div></pre></td></tr></table></figure>
<h3 id="提取网页中所有图片信息"><a href="# 提取网页中所有图片信息" class="headerlink" title="提取网页中所有图片信息"></a> 提取网页中所有图片信息 </h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\<span class="string">"\\']&#123;0,1&#125;([^\\"</span>\\<span class="string">'\\ &gt;]*)</span></div></pre></td></tr></table></figure>
<h3 id="提取 -html- 中的超链接"><a href="# 提取 -html- 中的超链接" class="headerlink" title="提取 html 中的超链接"></a> 提取 html 中的超链接 </h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="xml"><span class="tag">&lt;<span class="name">a\\s*(?!.*\\brel=)[^</span>&gt;</span>]*)(href="https?:\\/\\/)((?!(?:(?:www\\.)?'.implode('|(?:www\\.)?', $follow_list).'))[^"]+)"((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;</span></div></pre></td></tr></table></figure>
<h3 id="抽取网页中的颜色代码"><a href="# 抽取网页中的颜色代码" class="headerlink" title="抽取网页中的颜色代码"></a> 抽取网页中的颜色代码 </h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$</div></pre></td></tr></table></figure>
<h3 id="验证 -windows- 下文件路径和扩展名"><a href="# 验证 -windows- 下文件路径和扩展名" class="headerlink" title="验证 windows 下文件路径和扩展名"></a> 验证 windows 下文件路径和扩展名 </h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?<span class="string">"&lt;&gt;|]+\\.txt(l)?$</span></div></pre></td></tr></table></figure>
<h3 id="提取 -URL- 链接"><a href="# 提取 -URL- 链接" class="headerlink" title="提取 URL 链接"></a> 提取 URL 链接 </h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^(f|ht)&#123;<span class="number">1</span>&#125;(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?</div></pre></td></tr></table></figure>
<h3 id="校验 IP 地址"><a href="# 校验 IP 地址" class="headerlink" title="校验 IP 地址"></a> 校验 IP 地址 </h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ip-v4</span></div><div class="line">\\b(?:(?:<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>][<span class="number">0</span><span class="number">-9</span>]|[<span class="number">01</span>]?[<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]?)\\.)&#123;<span class="number">3</span>&#125;(?:<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>][<span class="number">0</span><span class="number">-9</span>]|[<span class="number">01</span>]?[<span class="number">0</span><span class="number">-9</span>][<span class="number">0</span><span class="number">-9</span>]?)\\b</div><div class="line"><span class="comment">// ip-v6</span></div><div class="line">(([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">7</span>,<span class="number">7</span>&#125;[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">7</span>&#125;:|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">6</span>&#125;:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">5</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">5</span>&#125;|[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:((:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">6</span>&#125;)|:((:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">7</span>&#125;|:)|fe80:(:[<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">0</span>,<span class="number">4</span>&#125;)&#123;<span class="number">0</span>,<span class="number">4</span>&#125;%[<span class="number">0</span><span class="number">-9</span>a-zA-Z]&#123;<span class="number">1</span>,&#125;|::(ffff(:<span class="number">0</span>&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;:)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;((<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])\\.)&#123;<span class="number">3</span>,<span class="number">3</span>&#125;(<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])|([<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:((<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])\\.)&#123;<span class="number">3</span>,<span class="number">3</span>&#125;(<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span><span class="number">-9</span>]))</div></pre></td></tr></table></figure>
<h3 id="判断 -IE- 的版本"><a href="# 判断 -IE- 的版本" class="headerlink" title="判断 IE 的版本"></a> 判断 IE 的版本 </h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^.*MSIE [<span class="number">5</span><span class="number">-8</span>](?:\\.[<span class="number">0</span><span class="number">-9</span>]+)?(?!.*Trident\\/[<span class="number">5</span><span class="number">-9</span>]\\<span class="number">.0</span>).*$</div></pre></td></tr></table></figure>
<h3 id="校验手机号"><a href="# 校验手机号" class="headerlink" title="校验手机号"></a> 校验手机号 </h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^(<span class="number">13</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">14</span>[<span class="number">5</span>|<span class="number">7</span>]|<span class="number">15</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>]|<span class="number">18</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>])\\d&#123;<span class="number">8</span>&#125;$</div></pre></td></tr></table></figure>
<h3 id="校验金额"><a href="# 校验金额" class="headerlink" title="校验金额"></a> 校验金额 </h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^[<span class="number">0</span><span class="number">-9</span>]+(.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;)?$</div></pre></td></tr></table></figure>
<h3 id="校验身份证号码"><a href="# 校验身份证号码" class="headerlink" title="校验身份证号码"></a> 校验身份证号码 </h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 15 位 </span></div><div class="line">^[<span class="number">1</span><span class="number">-9</span>]\\d&#123;<span class="number">7</span>&#125;((<span class="number">0</span>\\d)|(<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>]))(([<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>]\\d)|<span class="number">3</span>[<span class="number">0</span><span class="number">-1</span>])\\d&#123;<span class="number">3</span>&#125;$</div><div class="line"><span class="comment">// 18 位 </span></div><div class="line">^[<span class="number">1</span><span class="number">-9</span>]\\d&#123;<span class="number">5</span>&#125;[<span class="number">1</span><span class="number">-9</span>]\\d&#123;<span class="number">3</span>&#125;((<span class="number">0</span>\\d)|(<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>]))(([<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>]\\d)|<span class="number">3</span>[<span class="number">0</span><span class="number">-1</span>])\\d&#123;<span class="number">3</span>&#125;([<span class="number">0</span><span class="number">-9</span>]|X)$</div></pre></td></tr></table></figure>
<h3 id="校验日期"><a href="# 校验日期" class="headerlink" title="校验日期"></a> 校验日期 </h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^(?:(?!<span class="number">0000</span>)[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">4</span>&#125;-(?:(?:<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>])-(?:<span class="number">0</span>[<span class="number">1</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">2</span>[<span class="number">0</span><span class="number">-8</span>])|(?:<span class="number">0</span>[<span class="number">13</span><span class="number">-9</span>]|<span class="number">1</span>[<span class="number">0</span><span class="number">-2</span>])-(?:<span class="number">29</span>|<span class="number">30</span>)|(?:<span class="number">0</span>[<span class="number">13578</span>]|<span class="number">1</span>[<span class="number">02</span>])<span class="number">-31</span>)|(?:[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">2</span>&#125;(?:<span class="number">0</span>[<span class="number">48</span>]|[<span class="number">2468</span>][<span class="number">048</span>]|[<span class="number">13579</span>][<span class="number">26</span>])|(?:<span class="number">0</span>[<span class="number">48</span>]|[<span class="number">2468</span>][<span class="number">048</span>]|[<span class="number">13579</span>][<span class="number">26</span>])<span class="number">00</span>)<span class="number">-02</span><span class="number">-29</span>)$</div></pre></td></tr></table></figure>
<h3 id="校验 -mail 地址"><a href="# 校验 -mail 地址" class="headerlink" title="校验 mail 地址"></a> 校验 mail 地址 </h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?</div></pre></td></tr></table></figure>
<h3 id="由数字、26- 个英文字母或下划线组成的字符串"><a href="# 由数字、26- 个英文字母或下划线组成的字符串" class="headerlink" title="由数字、26 个英文字母或下划线组成的字符串"></a> 由数字、26 个英文字母或下划线组成的字符串 </h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^\\w+$</div></pre></td></tr></table></figure>
<h3 id="校验中文"><a href="# 校验中文" class="headerlink" title="校验中文"></a> 校验中文 </h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^[\\u4e00-\\u9fa5]&#123;<span class="number">0</span>,&#125;$</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;匹配 HTML 标签&quot;&gt;&lt;a href=&quot;# 匹配 HTML 标签&quot; class=&quot;headerlink&quot; title=&quot;匹配 HTML 标签&quot;&gt;&lt;/a&gt; 匹配 HTML 标签 &lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;
    
    </summary>
    
      <category term="Regular" scheme="http://blog.freeabyss.com/categories/Regular/"/>
    
    
      <category term="Regular" scheme="http://blog.freeabyss.com/tags/Regular/"/>
    
  </entry>
  
  <entry>
    <title>Window 下将脚本注册成服务</title>
    <link href="http://blog.freeabyss.com/Window/Window-Window%E4%B8%8B%E5%B0%86%E8%84%9A%E6%9C%AC%E6%88%96%E7%A8%8B%E5%BA%8F%E6%B3%A8%E5%86%8C%E6%88%90%E6%9C%8D%E5%8A%A1.html"/>
    <id>http://blog.freeabyss.com/Window/Window-Window下将脚本或程序注册成服务.html</id>
    <published>2017-02-26T07:08:52.000Z</published>
    <updated>2017-02-26T08:59:54.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li> 下载微软系统小工具 instsrv.exe 和 srvany.exe 至 C:\Windows\System32。<a href="https://www.microsoft.com/en-us/download/details.aspx?id=17657" target="_blank" rel="external"> 下载地址 </a>    </li>
<li> 运行 Dos 命令代码：instsrv ServiceName C:\Windows\System32\srvany.exe<br> (ServiceName 即你自己定义的服务名称，可以是要作为系统服务启动的应用程序的名称。) </li>
<li> 打开注册表，定位到下面的路径。<br> HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\ServiceName<br> (同样的 ServiceName 是你刚才安装服务时自定义的服务名称。)<br> 如果该服务名下没有 Parameters 项目，则对服务名称项目右击新建项，名称为 Parameters，然后定位到 Parameters 项，新建以下几个字符串值。<br> 名称 Application 值为你要作为服务运行的 BAT 文件地址。<br> 名称 AppDirectory 值为你要作为服务运行的 BAT 文件所在文件夹路径。<br> 名称 AppParameters 值为你要作为服务运行的 BAT 文件启动所需要的参数。     </li>
</ol>
<p> 注：instsrv ServiceName remove 命令可删除服务。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt; 下载微软系统小工具 instsrv.exe 和 srvany.exe 至 C:\Windows\System32。&lt;a href=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=17657&quot; 
    
    </summary>
    
      <category term="Window" scheme="http://blog.freeabyss.com/categories/Window/"/>
    
    
      <category term="Window" scheme="http://blog.freeabyss.com/tags/Window/"/>
    
      <category term="Service" scheme="http://blog.freeabyss.com/tags/Service/"/>
    
  </entry>
  
  <entry>
    <title>Maven 的自动部署配置</title>
    <link href="http://blog.freeabyss.com/Maven/Maven-Maven%E7%9A%84%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE.html"/>
    <id>http://blog.freeabyss.com/Maven/Maven-Maven的自动部署配置.html</id>
    <published>2017-02-25T12:51:51.000Z</published>
    <updated>2017-02-25T12:53:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="# 简介" class="headerlink" title="简介"></a>简介 </h2><p> 利用 Maven 的 <code>tomcat7-maven-plugin</code> 插件，可以仅仅使用一行命令就可以将项目部署到本地或者远程的 Tomcat 上。<br>插件的名称虽然带有 <code>tomcat7</code>，但经过我实际测验 Tomcat8 中也可以使用。<br> 完成自动部署需要两步，首先是 Tomcat 的配置，其次是 pom 文件的配置。 </p>
<h2 id="配置 Tomcat"><a href="# 配置 Tomcat" class="headerlink" title="配置 Tomcat"></a>配置 Tomcat</h2><p> 在 Tomcat 目录下的 <code>conf/tomcat-users.xml</code> 文件中添加以下代码   </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager-gui"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager-script"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"admin"</span> <span class="attr">password</span>=<span class="string">"password"</span> <span class="attr">roles</span>=<span class="string">"manager-script"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"password"</span> <span class="attr">roles</span>=<span class="string">"manager-gui"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p><code>username</code>和 <code>password</code> 可以随意更改。    </p>
<p>在 <code>conf/context.xml</code> 添加以下代码     </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">pathname</span>=<span class="string">"/manager"</span> <span class="attr">debug</span>=<span class="string">"0"</span> <span class="attr">privileged</span>=<span class="string">"true"</span> <span class="attr">docBase</span>=<span class="string">"$&#123;catalina.home&#125;/webapps/manager"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>在 <code>conf/Catalina/localhost/</code> 目录下创建 <code>manager.xml</code> 文件，并填充以下内容:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">privileged</span>=<span class="string">"true"</span> <span class="attr">antiResourceLocking</span>=<span class="string">"false"</span> <span class="attr">docBase</span>=<span class="string">"$&#123;catalina.home&#125;/webapps/manager"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.RemoteAddrValve"</span> <span class="attr">allow</span>=<span class="string">"^.*$"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></div></pre></td></tr></table></figure></p>
<ol>
<li>验证配置是否正确，启动 Tomcat，打开浏览器，输入地址是 <code>http://localhost:8080/manager/html</code>（假设 Tomcat 地址是<code>locahost:8080</code>）。然后输入<code>root</code> 的登录名和密码，成功登入就说明配置成功。 <h2 id="配置 pom-xml"><a href="# 配置 pom-xml" class="headerlink" title="配置 pom.xml"></a>配置 pom.xml</h2>在 <code>pom.xml</code> 文件中添加以下代码，如果是多模块项目，则在 web 模块所在的 <code>pom.xml</code> 添加。    </li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://serverip:port/manager/text<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">password</span>&gt;</span>password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">update</span>&gt;</span>true<span class="tag">&lt;/<span class="name">update</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">path</span>&gt;</span>/webapp<span class="tag">&lt;/<span class="name">path</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="启动部署"><a href="# 启动部署" class="headerlink" title="启动部署"></a>启动部署 </h2><p> 第一次部署输入以下命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn tomcat7:deploy</div></pre></td></tr></table></figure>
<p>以后每次部署，可以输入以下命令 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn tomcat7:redeploy</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;# 简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介 &lt;/h2&gt;&lt;p&gt; 利用 Maven 的 &lt;code&gt;tomcat7-maven-plugin&lt;/code&gt; 插件，可以仅仅使用一行命令就可以将项目部署到
    
    </summary>
    
      <category term="Maven" scheme="http://blog.freeabyss.com/categories/Maven/"/>
    
    
      <category term="Java" scheme="http://blog.freeabyss.com/tags/Java/"/>
    
      <category term="Maven" scheme="http://blog.freeabyss.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 欧拉回路和哈密顿通路 34</title>
    <link href="http://blog.freeabyss.com/Math/Math-DM-34-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E5%92%8C%E5%93%88%E5%AF%86%E9%A1%BF%E9%80%9A%E8%B7%AF.html"/>
    <id>http://blog.freeabyss.com/Math/Math-DM-34-欧拉回路和哈密顿通路.html</id>
    <published>2017-02-25T08:31:37.000Z</published>
    <updated>2017-02-26T06:07:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="欧拉回路"><a href="# 欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路 </h2><p> 图 $G$ 的欧拉回路是包含着 $G$ 的每一条边的封闭路线。图 $G$ 里的欧拉通路是包含着 $G$ 的每一条边的路线。<br>欧拉回路和欧拉通路都是恰好包含图的每一条边且不重复，唯一的区别就是，欧拉回路回到原点，而欧拉通路不必回到原点。       </p>
<blockquote>
<p>通路 (path) 等同于路径 (walk)，回路(circuit) 等同于封闭路径(close walk)。是同一概念的不同术语。</p>
</blockquote>
<p>连通多重图具有欧拉回路当且仅当它的每个顶点都有偶数度。    </p>
<blockquote>
<p>假设一条欧拉回路从 $a$ 开始，开始时它为 $deg(a)$ 贡献一度，结束时为 $deg(a)$ 贡献一度，而每次经过 $a$ 以及其余的顶点时都贡献 2 度。    </p>
</blockquote>
<p>连通多重图具有欧拉通路但无欧拉回路，当且仅当它恰好有 2 个奇数度顶点。     </p>
<blockquote>
<p>假设多重图有从 $a$ 到 $b$ 的欧拉通路，但不是欧拉回路。通路的第一条边为 $a$ 贡献 1 度，此后每次经过 $a$ 都贡献 2 度。通路的最后一条边为 $b$ 的度贡献 1 度，此前每次经过 $b$ 都贡献 2 度，因此 $a$ 和 $b$ 必定是奇数度。    </p>
</blockquote>
<h3 id="构造欧拉回路"><a href="# 构造欧拉回路" class="headerlink" title="构造欧拉回路"></a>构造欧拉回路</h3><p>$$\begin{array}{l}<br>\mathbf {procedure}\;\mathcal Euler(G: 所有顶点有偶数度的连通多重图) \\<br>circuit \; :=\; 在 G 里任选的顶点开始，连续地加入边所形成的回到该顶点的回路 \\<br>H\; :=\; 删除这条回路的边之后的 G \ <br>\mathbf {while}\; H\; 还有边 \\<br>\mathbf {begin} \\<br>\quad subcircuit\; :=\; 在既是 H 里的顶点也是 circuit 的边的端点处开始的 H 里的一条回路 \\<br>\quad H\; :=\; 删除 subcircuit 的边和所有孤立点之后的 H \\<br>\quad circuit\; :=\; 在适当顶点上插入 subcircuit 之后的 circuit\\<br>\mathbf {end}(circuit 是欧拉回路)<br>\end{array}$$</p>
<h2 id="哈密顿通路"><a href="# 哈密顿通路" class="headerlink" title="哈密顿通路"></a>哈密顿通路 </h2><p> 在图 $G=(\mathbf V,\mathbf E)$ 里，若 $\mathbf V={x_0,x_1,\dots,x_{n-1},x_n}$ 并且对 $0\le i\lt j\le n$ 来说有 $x_j\neq x_i$，则通路 $x_0,x_1,\dots,x_{n-1},x_n$ 称为哈密顿通路。$x_0,x_1,\dots,x_{n-1},x_n,x_0$ 称为哈密顿回路。    </p>
<h3 id="求解哈密顿通路"><a href="# 求解哈密顿通路" class="headerlink" title="求解哈密顿通路"></a>求解哈密顿通路 </h3><p> 目前没有已知的简单的充要条件来判定哈密顿回路的存在性。不过有很多定理对哈密顿的存在性提供了充分条件，另外，某些性质可以用来证明一个图没有哈密顿回路。    </p>
<p>带有一个顶点的图是没用哈密顿回路的。<br>图的边越多存在哈密顿回路的可能性就越大，尤其是每个顶点都加入边时。     </p>
<h3 id="狄拉克定理"><a href="# 狄拉克定理" class="headerlink" title="狄拉克定理"></a>狄拉克定理 </h3><p> 如果 $G$ 是带 $n$ 个顶点的连通简单图，其中 $n\gt 3$，并且 $G$ 中每个顶点的度都至少为 $n/2$，则 $G$ 有哈密顿回路。    </p>
<h3 id="奥尔定理"><a href="# 奥尔定理" class="headerlink" title="奥尔定理"></a>奥尔定理 </h3><p> 如果 $G$ 是带 $n$ 个顶点的连通简单图，其中 $n\gt 3$，并且对于 $G$ 中每一对不相邻的顶点 $u$ 和 $v$ 来说，都有 $deg(u)+deg(v)\gt n$，则 $G$ 有哈密顿回路。   </p>
<h3 id="算法复杂度"><a href="# 算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度 </h3><p> 已知最好的求一个图里的哈密顿回路或判定这样的回路不存在的算法具有指数的最坏情形复杂性（相对于顶点数来讲）。找到具有多项式最坏情形时间复杂性的解决算法是 NP 复杂的。     </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;欧拉回路&quot;&gt;&lt;a href=&quot;# 欧拉回路&quot; class=&quot;headerlink&quot; title=&quot;欧拉回路&quot;&gt;&lt;/a&gt;欧拉回路 &lt;/h2&gt;&lt;p&gt; 图 $G$ 的欧拉回路是包含着 $G$ 的每一条边的封闭路线。图 $G$ 里的欧拉通路是包含着 $G$ 的每一条边的路
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="graph" scheme="http://blog.freeabyss.com/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 图的连通性 33</title>
    <link href="http://blog.freeabyss.com/Math/Math-DM-33-%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7.html"/>
    <id>http://blog.freeabyss.com/Math/Math-DM-33-图的连通性.html</id>
    <published>2017-02-25T06:46:18.000Z</published>
    <updated>2017-02-25T08:31:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="连通性"><a href="# 连通性" class="headerlink" title="连通性"></a>连通性 </h2><h3 id="定义和相关术语"><a href="# 定义和相关术语" class="headerlink" title="定义和相关术语"></a> 定义和相关术语 </h3><h4 id="无向图定义"><a href="# 无向图定义" class="headerlink" title="无向图定义"></a> 无向图定义 </h4><p> 设 $n$ 是非负整数且 $G$ 是无向图。在 $G$ 中从 $u$ 到 $v$ 的长度为 $n$<strong>路径 </strong> 是 $G$ 的 $n$ 条边 $e_1,\dots,e_n$ 的序列，使得 $f(e_1)={x_0,x_1},f(e_2)={x_1,x_2},\dots,f(e_n)={x_{n-1},x_n}$，其中 $x_0=u$ 而 $x_n=v$。当这个图是简单图时，就用顶点序列 $x_0,x_1,\dots,x_n$ 表示这条路径。<br>若一条路径在相同的顶点上开始和结束，即 $u=v$ 且长度大于 0，则它是一条 <strong> 封闭路径 </strong>。<br> 若通路径不包含重复的相同边，则它是 <strong> 路线 </strong> 。<br> 当没有必要区分多重边时，就用顶点序列 $x_0,x_1,\dots,x_n$ 表示路径。<br>通路表示没有重复顶点的路径。       </p>
<blockquote>
<p>路径 (walk)、通路(path)，、封闭路径(closed walk)、回路(circuit)、路线(trail)<br> 上面定义的概念，有很多不同的术语， 因此需要注意以下几点： </p>
<ul>
<li>是否起始和终止于相同的顶点</li>
<li>是否有重复的相同边      </li>
<li>是否有重复的顶点   </li>
</ul>
</blockquote>
<h4 id="有向图定义"><a href="# 有向图定义" class="headerlink" title="有向图定义"></a>有向图定义 </h4><p> 在有向图 $G$ 中从 $a$ 到 $b$ 的一条路径是 $G$ 中一条或多条边的序列 $(x_0,x_1),(x_1,x_2),(x_2,x_3),\dots,(x_{n-1},x_n)$，其中 $x_0=a,x_n=b$。</p>
<h3 id="无向图的连通性"><a href="# 无向图的连通性" class="headerlink" title="无向图的连通性"></a>无向图的连通性 </h3><p> 若无向图每一对不同的顶点之间都有路径，则该图称为 <strong> 连通 </strong> 的。     </p>
<p>不连通的图是 2 个或 2 个以上连通子图之并，每一对子图都没有公共的顶点。这些不相交的连通子图称为图的连通分支。     </p>
<p>删除一个顶点和它所关联的边，就产生带有比原图更多的连通分支的子图。把这样的顶点称为割点。    </p>
<p>把一旦删除就产生带有比原图更多的连通分支的子图的边称为割边或桥。    </p>
<h4 id="连通无向图的每一对不同顶点之间都存在路线"><a href="# 连通无向图的每一对不同顶点之间都存在路线" class="headerlink" title="连通无向图的每一对不同顶点之间都存在路线"></a>连通无向图的每一对不同顶点之间都存在路线 </h4><p> 证： 设 $u$ 和 $v$ 是连通无向图 $G=(\mathbf V,\mathbf E)$ 的两个不同的顶点。因为 $G$ 是连通的，所以 $u$ 和 $v$ 之间至少有 1 条路径。设 $x_0,x_1,\dots,x_n$ 是长度最短的路径的顶点序列，其中 $x_0=u$ 而 $x_n=v$。这条长度最短的路径是路线。假设它不是路线，则对满足 $0\le i\lt j$ 的某个 $i$ 和 $j$ 来说，有 $x_i=x_j$。这意味着通过删除顶点序列 $x_i,\dots,x_{j-1}$ 所对应的边，就获得了 带有顶点序列 $x_0,x_1,\dots,x_{i-1},x_j,\dots,x_n$ 的从 $u$ 到 $v$ 的更短的路线。     </p>
<h3 id="有向图的连通性"><a href="# 有向图的连通性" class="headerlink" title="有向图的连通性"></a>有向图的连通性 </h3><p> 在有向图里有两种连通性的概念。若任意两顶点之间都有路径，则该有向图是 <strong> 弱连通性 </strong> 的。若任意两顶点 $a$ 和 $b$，其中从 $a$ 到 $b$ 和从 $b$ 到 $a$ 都有路径，则该图是 <strong> 强连通性</strong>。    </p>
<p>$G$ 的子图是强连通图，则称为 $G$ 的强连通分支或强分枝。    </p>
<h3 id="顶点之间的路径数"><a href="# 顶点之间的路径数" class="headerlink" title="顶点之间的路径数"></a>顶点之间的路径数 </h3><p> 设 $G$ 是带有相对于顶点顺序 $v_1,v_2,\dots,v_n$ 的邻接矩阵 $\mathbf A$ 的图（允许带有无向、有向、多重边、环）。从 $v_i$ 到 $v_j$ 的长度为 $r$ 的不同路径数目等于 $\mathb A^r$ 的第 $(i,j)项，其中 $r$ 是正整数。    </p>
<h2 id="路径和同构"><a href="# 路径和同构" class="headerlink" title="路径和同构"></a>路径和同构 </h2><p> 有多种方式可以利用路径和封闭路径来帮助判定两个图是否同构。例如，具有特定长度的路线的存在性，就是一种可以用来证明两个图是不同构的有用的不变量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;连通性&quot;&gt;&lt;a href=&quot;# 连通性&quot; class=&quot;headerlink&quot; title=&quot;连通性&quot;&gt;&lt;/a&gt;连通性 &lt;/h2&gt;&lt;h3 id=&quot;定义和相关术语&quot;&gt;&lt;a href=&quot;# 定义和相关术语&quot; class=&quot;headerlink&quot; title=&quot;定义和相
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="graph" scheme="http://blog.freeabyss.com/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 图的同构 32</title>
    <link href="http://blog.freeabyss.com/Math/Math-DM-32-%E5%9B%BE%E7%9A%84%E5%90%8C%E6%9E%84.html"/>
    <id>http://blog.freeabyss.com/Math/Math-DM-32-图的同构.html</id>
    <published>2017-02-25T04:02:03.000Z</published>
    <updated>2017-02-25T06:46:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同构"><a href="# 同构" class="headerlink" title="同构"></a>同构 </h2><p> 设 $G_1=(\mathbf V_1,\mathbf E_1)$ 和 $G_2=(\mathbf V_2,\mathbf E_2)$ 是简单图，若从 $\mathbf V_1$ 到 $\mathbf V_2$ 存在一对一的映射 $f$，且 $f$ 具有如下性质：对 $\mathbf V_1$ 里的所有的 $a$ 和 $b$ 来说，$a$ 和 $b$ 在 $G_1$ 里相邻当且仅当 $f(a)$ 和 $f(b)$ 在 $G_2$ 里相邻，就说 $G_1$ 和 $G_2$ 是同构的。这样的函数 $f$ 称为同构。简单来讲，当两个简单图同构时，两个图的顶点之间具有保持相邻关系的一一对应。      </p>
<p>判断两个简单图是否同构常常是一件困难的事情。在两个带有 $n$ 个顶点的简单图顶点集之间有 $n!$ 钟可能的一一对应。若 $n$ 太大，则通过检验每一种对应来看它是否保持相邻关系是不可能的。      </p>
<h3 id="判断同构的方法"><a href="# 判断同构的方法" class="headerlink" title="判断同构的方法"></a>判断同构的方法 </h3><p> 同构的简单图必然具有相同的顶点数、边数和顶点的度，这些被称为同构下的不变量。这些量有任何不同，则两个图就不是同构的，不过即使，这些量都是相同的，也不一定意味着两个图同构。目前没有已知的用来判定简单是否同构的不变量集。    </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;同构&quot;&gt;&lt;a href=&quot;# 同构&quot; class=&quot;headerlink&quot; title=&quot;同构&quot;&gt;&lt;/a&gt;同构 &lt;/h2&gt;&lt;p&gt; 设 $G_1=(\mathbf V_1,\mathbf E_1)$ 和 $G_2=(\mathbf V_2,\mathbf E_2)$
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="graph" scheme="http://blog.freeabyss.com/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 图的表示 31</title>
    <link href="http://blog.freeabyss.com/Math/Math-DM-31-%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA.html"/>
    <id>http://blog.freeabyss.com/Math/Math-DM-31-图的表示.html</id>
    <published>2017-02-23T13:06:27.000Z</published>
    <updated>2017-02-23T13:48:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的表示"><a href="# 图的表示" class="headerlink" title="图的表示"></a>图的表示 </h2><p> 图有很多种表示方式，本章介绍两种表示方法，一种是邻接表，一种是邻接矩阵。     </p>
<h3 id="邻接表"><a href="# 邻接表" class="headerlink" title="邻接表"></a>邻接表 </h3><p> 邻接表可以用来表示不带多重边的图，它规定了每个顶点相邻的顶点       </p>
<h4 id="简单表的邻接表"><a href="# 简单表的邻接表" class="headerlink" title="简单表的邻接表"></a>简单表的邻接表</h4><table>
<thead>
<tr>
<th style="text-align:left">顶点</th>
<th style="text-align:left">相邻的顶点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">b,c,e</td>
</tr>
<tr>
<td style="text-align:left">b</td>
<td style="text-align:left">a</td>
</tr>
<tr>
<td style="text-align:left">c</td>
<td style="text-align:left">a,d,e</td>
</tr>
<tr>
<td style="text-align:left">d</td>
<td style="text-align:left">c,e</td>
</tr>
<tr>
<td style="text-align:left">e</td>
<td style="text-align:left">a,c,d</td>
</tr>
</tbody>
</table>
<h4 id="有向图的邻接表"><a href="# 有向图的邻接表" class="headerlink" title="有向图的邻接表"></a>有向图的邻接表</h4><table>
<thead>
<tr>
<th style="text-align:left">起点</th>
<th style="text-align:left">终点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">b,c,d,e</td>
</tr>
<tr>
<td style="text-align:left">b</td>
<td style="text-align:left">b,d</td>
</tr>
<tr>
<td style="text-align:left">c</td>
<td style="text-align:left">a,c,e</td>
</tr>
<tr>
<td style="text-align:left">d</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">e</td>
<td style="text-align:left">b,c,d</td>
</tr>
</tbody>
</table>
<h3 id="邻接矩阵"><a href="# 邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵 </h3><h4 id="基于顶点的相邻关系"><a href="# 基于顶点的相邻关系" class="headerlink" title="基于顶点的相邻关系"></a> 基于顶点的相邻关系 </h4><p> 假设 $G=(\mathbf V,\mathbf E)$ 是简单图，其中 $\mid\mathbf V\mid=m$。假设把 $G$ 的顶点任意地排列成 $v_1,v_2,\dots,v_n$。对这个顶点表来说，$G$ 的邻接矩阵 $\mathbf A$ 是一个 $n\times n$ 的 $0-1$ 矩阵，它满足这样的性质：当 $v_i$ 和 $v_j$ 相邻时第 $(i,j)$ 项是 1，当 $v_i$ 和 $v_j$ 不相邻时第 $(i,j)$ 项是 0。      </p>
<p>图的邻接矩阵依赖于所选择顶点的顺序。因此带 $n$ 个顶点的图有 $n!$ 个不同的邻接矩阵，因为 $n$ 个顶点有 $n!$ 个不同的顺序。     </p>
<p>邻接矩阵也可以用来表示带环和多重边的无向图。把顶点 $a_i$ 上的环表示成邻接矩阵第 $(i,i)$ 位置上 1，当出现多重边时，第 $(i,j)$ 项等于 ${a_i,a_j}$ 关联的边数。包括多重图和伪图在内的所有无向图都具有对称的邻接矩阵。      </p>
<p>有向图的邻接矩阵不必是对称的，因为当从 $a_i$ 到 $a_j$ 有边时，从 $a_j$ 到 $a_i$ 可以没边。    </p>
<h4 id="关联矩阵"><a href="# 关联矩阵" class="headerlink" title="关联矩阵"></a>关联矩阵 </h4><p> 设 $G=(\mathbf V,\mathbf E)$ 是无向图。设 $v_1,v_2,\dots, v_n$，是顶点而 $e_1,e_2,\dots,e_n$ 是边。则相对于 $\mathbf V$ 和 $\mathbf E$ 的这个顺序的关联矩阵是 $n\times m$ 矩阵 $\mathbf M=[m_{ij}]$，其中 $$m_{ij} =\begin{cases}1\qquad 当边 e_j 关联 v_i 时 \\0\qquad 否则 \end{cases}$$<br>关联矩阵示例：<br><img src="../images/graph_06.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图的表示&quot;&gt;&lt;a href=&quot;# 图的表示&quot; class=&quot;headerlink&quot; title=&quot;图的表示&quot;&gt;&lt;/a&gt;图的表示 &lt;/h2&gt;&lt;p&gt; 图有很多种表示方式，本章介绍两种表示方法，一种是邻接表，一种是邻接矩阵。     &lt;/p&gt;
&lt;h3 id=&quot;邻接表&quot;&gt;
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="graph" scheme="http://blog.freeabyss.com/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 图的基本概念 30</title>
    <link href="http://blog.freeabyss.com/Math/Math-DM-30-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html"/>
    <id>http://blog.freeabyss.com/Math/Math-DM-30-图的基本概念.html</id>
    <published>2017-02-22T13:09:01.000Z</published>
    <updated>2017-03-16T12:25:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图定义"><a href="# 图定义" class="headerlink" title="图定义"></a>图定义 </h2><p> 一个图 $G$ 由顶点（或结点）的非空集 $\mathbf V$ 和边集 $\mathbf E$ 构成，每条边有一个或两个顶点与它相连，这样的顶点称为边的端点。边连接它的端点。    </p>
<ul>
<li>环：把一个顶点连接自身的边     </li>
<li>多重边：$m$ 条不同的边连接相同的两个顶点称为多重边，也可以说该边是一条多重度为 $m$ 的边     </li>
</ul>
<h3 id="有向图"><a href="# 有向图" class="headerlink" title="有向图"></a>有向图 </h3><p> 一个有向图 $(\mathbf V,\mathbf E)$ 由一个非空顶点集 $\mathbf V$ 和一个有向边集 $\mathbf E$ 组成。每条有向边与一个顶点有序对相关联。认为与有序对 $u,v)$ 相关的有向边开始于 $u$，结束于 $v$。    </p>
<h3 id="度"><a href="# 度" class="headerlink" title="度"></a>度 </h3><h4 id="无向图中顶点的度"><a href="# 无向图中顶点的度" class="headerlink" title="无向图中顶点的度"></a> 无向图中顶点的度 </h4><p> 在无向图里顶点的度是与该顶点关联的边的数目，例外的情形是，顶点上的环算为度数加 2。顶点 $v$ 的度表示成 $deg(v)$。</p>
<h4 id="无向图中顶点的度的性质"><a href="# 无向图中顶点的度的性质" class="headerlink" title="无向图中顶点的度的性质"></a>无向图中顶点的度的性质 </h4><h5 id="握手定理"><a href="# 握手定理" class="headerlink" title="握手定理"></a> 握手定理 </h5><p> 设 $G=(\mathbf V,\mathbf E)$ 是有 $e$ 条边的无向图，则 $$2e=\sum_{v\in V}deg(v)$$</p>
<h5 id="无向图有偶数个奇数度顶点"><a href="# 无向图有偶数个奇数度顶点" class="headerlink" title="无向图有偶数个奇数度顶点"></a>无向图有偶数个奇数度顶点 </h5><h4 id="有向图中顶点的度"><a href="# 有向图中顶点的度" class="headerlink" title="有向图中顶点的度"></a> 有向图中顶点的度 </h4><p> 当 $(u,v)$ 是有向边时，说 $u$ 邻接到 $v$，顶点 $u$ 称为 $(u,v)$ 的起点，$v$ 称为 $(u,v)$ 的终点。环的起点和终点相同。<br>在有向图中，顶点 $v$ 的入度是以 $v$ 作为终点的边数，表示成 $deg^-(v)$，顶点 $v$ 的出度是以 $v$ 作为起点的边数，表示成 $deg^+(v)$.<br>设 $G=(\mathbf V,\mathbf E)$ 是带有向边的图。于是 $$\sum_{v\in V}deg^-(v)=\sum_{v\in V}deg^+(v)=\mid E\mid$$</p>
<h3 id="子图"><a href="# 子图" class="headerlink" title="子图"></a>子图 </h3><p> 图 $G=(\mathbf V,\mathbf E)$ 的子图是图 $H=(\mathbf W,\mathbf F)$，其中 $\mathbf W\subseteq\mathbf F$ 而且 $\mathbf F\subseteq\mathbf E$。</p>
<h3 id="并图"><a href="# 并图" class="headerlink" title="并图"></a>并图 </h3><p> 两个简单图 $G_1=(\mathbf V_1,\mathbf E_1)$ 和 $G_2=(\mathbf V_2,\mathbf E_2)$ 的并图是带有顶点集 $\mathbf V_1\cup\mathbf V_2$ 和边集 $\mathbf E_1\cup\mathbf E_2$ 的简单图。$G_1$ 和 $G_2$ 的并图表示成 $G_1\cup G_2$。</p>
<h2 id="图的类型"><a href="# 图的类型" class="headerlink" title="图的类型"></a>图的类型</h2><table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">边</th>
<th style="text-align:left">多重边</th>
<th style="text-align:left">环</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">简单图</td>
<td style="text-align:left">无向</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">多重图</td>
<td style="text-align:left">无向</td>
<td style="text-align:left">是</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">伪图</td>
<td style="text-align:left">无向</td>
<td style="text-align:left">是</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">有向图</td>
<td style="text-align:left">有向</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">有向多重图</td>
<td style="text-align:left">有向</td>
<td style="text-align:left">是</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">混合图</td>
<td style="text-align:left">有向 + 无向</td>
<td style="text-align:left">是</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
<p>因为图论在各个行业中广泛应用，不同行业之间术语有些差异。尽管图的术语可能差异很大，但有三个需要注意的地方：    </p>
<ul>
<li>图的边是无向还是有向，又或者两者皆有</li>
<li>是否存在多重边或多重有向边</li>
<li>是否存在环 </li>
</ul>
<h3 id="一些特殊的简单图"><a href="# 一些特殊的简单图" class="headerlink" title="一些特殊的简单图"></a>一些特殊的简单图 </h3><h4 id="完全图"><a href="# 完全图" class="headerlink" title="完全图"></a> 完全图</h4><p>$n$ 个顶点的完全图是在每对顶点之间都恰好有一条边的简单图。用 $K_n$ 表示。<br><img src="../images/graph_01.png" alt=""></p>
<h4 id="圈图"><a href="# 圈图" class="headerlink" title="圈图"></a>圈图 </h4><p> 圈图是由 $n$ 个顶点 $v_1,v_2,\dots,v_n$ 以及边 ${v_1,v_2},{v_2,v_3},\dots, {v_{n-1}, v_n},{v_n,v_1}$ 组成的。用 $C_n$ 表示。<br><img src="../images/graph_02.png" alt=""></p>
<h4 id="轮图"><a href="# 轮图" class="headerlink" title="轮图"></a>轮图 </h4><p> 当给圈图添加另一个顶点，并且把这个新顶点与圈图里 $n$ 个顶点逐个连接时，就得出轮图。用 $W_n$ 表示。<br><img src="../images/graph_03.png" alt="">    </p>
<h4 id="n 立方体图"><a href="#n 立方体图" class="headerlink" title="n 立方体图"></a>n 立方体图</h4><p>$n$ 立方体图是用顶点表示 $2^n$ 个长度为 $n$ 的位串的图。两个顶点相邻当且仅当它们所表示的位串恰恰相差一位。 可以从 $n$ 立方图 $Q_n$ 来构造 $(n+1)$ 立方体图 $Q_{n+1}$，方法是建立 $Q_n$ 的两个副本，在 $Q_n$ 的一个副本的顶点标记前加 0，在 $Q_n$ 的另一个副本的顶点标记前加 1，并且加入连接那些标志只在第一位不同的两个顶点的边。<br><img src="../images/graph_04.png" alt=""></p>
<h4 id="偶图"><a href="# 偶图" class="headerlink" title="偶图"></a>偶图 </h4><p> 若把简单图 $G$ 的顶点集分成两个不相交的非空集合 $\mathbf V_1$ 和 $\mathbf V_2$，使得图的每一条边都连接着 $\mathbf V_1$ 里的一个顶点与 $\mathbf V_2$ 里的一个顶点。因此 $G$ 里没有边是连接着 $\mathbf V_1$ 里的两个顶点或 $\mathbf V_2$ 里的两个顶点。则 $G$ 称为偶图或者二分图。     </p>
<h5 id="判断简单图是偶图的准则"><a href="# 判断简单图是偶图的准则" class="headerlink" title="判断简单图是偶图的准则"></a>判断简单图是偶图的准则 </h5><p> 对图中的每个顶点赋以两种不同的颜色，而不让相邻接的顶点被赋以相同的颜色。     </p>
<h5 id="完全偶图"><a href="# 完全偶图" class="headerlink" title="完全偶图"></a>完全偶图 </h5><p> 完全偶图 $K_{m,n}是顶点集分成分别含有 $m$ 和 $n$ 个顶点的两个子集的图。两个顶点之间有边当且仅当一个顶点属于第一个子集而另外一个顶点属于第二个子集。<br><img src="../images/graph_05.png" alt=""></p>
<h3 id="度序列"><a href="# 度序列" class="headerlink" title="度序列"></a>度序列 </h3><p> 一个图的度序列是由该图的各节点的度按递减顺序排列的序列。其中，如果一个序列是简单图的度序列，那么该序列是 <strong> 成图 </strong> 的</p>
<h3 id="正则"><a href="# 正则" class="headerlink" title="正则"></a>正则 </h3><p> 若简单图每个顶点的度都相同，则这个图称为正则的。若正则图的每个顶点的度都为 $n$，则这个图称为 $n$ 正则。   </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图定义&quot;&gt;&lt;a href=&quot;# 图定义&quot; class=&quot;headerlink&quot; title=&quot;图定义&quot;&gt;&lt;/a&gt;图定义 &lt;/h2&gt;&lt;p&gt; 一个图 $G$ 由顶点（或结点）的非空集 $\mathbf V$ 和边集 $\mathbf E$ 构成，每条边有一个或两个顶点
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="graph" scheme="http://blog.freeabyss.com/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>Mac-Mac 下制作 MacOS 启动盘</title>
    <link href="http://blog.freeabyss.com/Mac/Mac-Mac%E4%B8%8B%E5%88%B6%E4%BD%9CMacOS%E5%90%AF%E5%8A%A8%E7%9B%98.html"/>
    <id>http://blog.freeabyss.com/Mac/Mac-Mac下制作MacOS启动盘.html</id>
    <published>2017-02-10T06:37:04.000Z</published>
    <updated>2017-02-10T06:41:43.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li> 从 App Store 中下载 macOS Sierra，不需要安装 </li>
<li></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt; 从 App Store 中下载 macOS Sierra，不需要安装 &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

    
    </summary>
    
      <category term="Mac" scheme="http://blog.freeabyss.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://blog.freeabyss.com/tags/Mac/"/>
    
      <category term="os" scheme="http://blog.freeabyss.com/tags/os/"/>
    
      <category term="tools" scheme="http://blog.freeabyss.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 关系的闭包 29</title>
    <link href="http://blog.freeabyss.com/Math/Math-DM-29-%E5%85%B3%E7%B3%BB%E7%9A%84%E9%97%AD%E5%8C%85.html"/>
    <id>http://blog.freeabyss.com/Math/Math-DM-29-关系的闭包.html</id>
    <published>2017-01-27T08:32:03.000Z</published>
    <updated>2017-02-23T12:57:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系的闭包"><a href="# 关系的闭包" class="headerlink" title="关系的闭包"></a>关系的闭包 </h2><p> 一般来说，设 $\mathbf R$ 是集合 $\mathbf A$ 上的关系。$\mathbf R$ 可能具有或者不具有某些性质 $\mathbf P$，例如自反性、对称性或传递性。如果存在包含 $\mathbf R$ 的具有性质 $\mathbf P$ 的关系 $\mathbf S$，并且 $\mathbf S$ 是包含 $\mathbf R$ 且具有性质 $\mathbf P$ 的每一个关系的子集，那么 $\mathbf S$ 叫做 $\mathbf R$ 的关于 $\mathbf P$ 的闭包。</p>
<h3 id="构造闭包"><a href="# 构造闭包" class="headerlink" title="构造闭包"></a>构造闭包 </h3><h4 id="自反闭包"><a href="# 自反闭包" class="headerlink" title="自反闭包"></a> 自反闭包 </h4><p> 给定集合 $\mathbf A$ 上的关系 $\mathbf R$，对于 $a\in\mathbf R$，可以通过把形如 $(a,a)$ 的所有的对，除了已在 $\mathbf R$ 中的之外，都加到 $\mathbf R$ 中，就构成了 $\mathbf R$ 的自反闭包。 </p>
<h4 id="对称闭包"><a href="# 对称闭包" class="headerlink" title="对称闭包"></a>对称闭包</h4><p>$\mathbf R\cup\mathbf R^{-1}$ 是 $\mathbf R$ 的对称闭包，其中 $\mathbf R^{-1}={(b,a)\mid (a,b)\in\mathbf R}$。     </p>
<h4 id="传递闭包"><a href="# 传递闭包" class="headerlink" title="传递闭包"></a>传递闭包 </h4><p> 我们需要借助图来构造传递闭包，首先介绍几个关于图的术语。      </p>
<ol>
<li>在有向图 $G$ 中从 $a$ 到 $b$ 的一条路径是 $G$ 中一条或多条边的序列 $(x_0,x_1),(x_1,x_2),(x_2,x_3),\dots,(x_{n-1},x_n)$，其中 $x_0=a, x_n=b$。即一个边的序列，其中一条边的终点和路径中下一条边的始点相同。这条路记为 $x_0,x_1,\dots,x_{n-1},x_n$，长度为 $n$。    </li>
<li>在同一顶点开始和结束的路径叫做回路或圈。       </li>
<li>有向图的一条路径可以多次通过一个顶点。此外，有向图的一条边也可以多次出现在一条路径中。     </li>
<li>设 $\mathbf R$ 是集合 $\mathbf A$ 上的关系。从 $a$ 到 $b$ 存在一条长为 $n$ 的路径，当且仅当 $(a,b)\in\mathbf R$。      </li>
</ol>
<p>现在证明找一个关系的传递闭包与在相关的有向图中确定哪些顶点对被路径连接是等价的。由此要定义一个新的关系。<br>连通性关系: 设 $\mathbf R$ 是集合 $\mathbf A$ 上的关系，连通性关系 $\mathbf R^<em>$ 由对 $(a,b)$ 构成，使得在 $\mathbf R$ 中从顶点 $a$ 到 $b$ 之间存在一条至少长为 1 的路径。<br>因为 $\mathbf R^n$ 由对 $(a,b)$ 构成，使得存在一条从 $a$ 到 $b$ 的长为 $n$ 的路径，从而 $\mathbf R^</em>$ 是所有集合 $\mathbf R^n$ 的并。即 $$\mathbf R^<em>=\bigcup^\infty_{n=1}\mathbf R^n$$<br>关系 $\mathbf R$ 的传递闭包等于连通性关系 $\mathbf R^</em>$。     </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关系的闭包&quot;&gt;&lt;a href=&quot;# 关系的闭包&quot; class=&quot;headerlink&quot; title=&quot;关系的闭包&quot;&gt;&lt;/a&gt;关系的闭包 &lt;/h2&gt;&lt;p&gt; 一般来说，设 $\mathbf R$ 是集合 $\mathbf A$ 上的关系。$\mathbf R$ 可能具
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="Relations" scheme="http://blog.freeabyss.com/tags/Relations/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 关系的表示 28</title>
    <link href="http://blog.freeabyss.com/Math/Math-DM-28-%E5%85%B3%E7%B3%BB%E7%9A%84%E8%A1%A8%E7%A4%BA.html"/>
    <id>http://blog.freeabyss.com/Math/Math-DM-28-关系的表示.html</id>
    <published>2017-01-22T11:25:37.000Z</published>
    <updated>2017-02-23T12:56:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系的表示"><a href="# 关系的表示" class="headerlink" title="关系的表示"></a>关系的表示 </h2><p> 本文讨论用 $0-1$ 矩阵和有向图的方式表示关系。    </p>
<h3 id="用矩阵表示关系"><a href="# 用矩阵表示关系" class="headerlink" title="用矩阵表示关系"></a>用矩阵表示关系 </h3><p> 假设 $\mathbf R$ 是从 $\mathbf A={a_1,a_2,\dots,a_m}$ 到 $\mathbf B={b_1,b_2,\dots,b_n}$ 的关系。关系 $\mathbf R$ 可以用矩阵 $\mathbf M_R=[m_{ij}]$ 来表示，其中 <br>$$m_{ij}=\begin{cases}1\qquad 如果(a_i,a_j)\in\mathbf R\\0\qquad 如果(a_i,b_j)\notin\mathbf R\end{cases}$$ 该表示方式，依赖于 $\mathbf A$ 和 $\mathbf B$ 的使用的排序。<br> 集合上的关系的矩阵是一个方阵，可以用矩阵来确定关系是否具有某种性质。<br>例如 $\mathbf R={(2,1),(3,1),(3,2)}$, 关于 $\mathbf R$ 的矩阵是 $$\mathbf M_R=\begin{bmatrix}0&amp;0\\1&amp;0\\1&amp;1\end{bmatrix}$$   </p>
<h4 id="自反关系的矩阵"><a href="# 自反关系的矩阵" class="headerlink" title="自反关系的矩阵"></a>自反关系的矩阵</h4><p>$\mathbf R$ 是自反的，当且仅当 $i=1,2,\dots,n,m_i=1$。换句话说，如果 $\mathbf M_R$ 的主对角线的所有元素都等于 1，那么 $\mathbf R$ 是自反的。    </p>
<h4 id="对称关系的矩阵"><a href="# 对称关系的矩阵" class="headerlink" title="对称关系的矩阵"></a>对称关系的矩阵 </h4><p>$\mathbf R$ 是对称的，当且仅当对所有的整数对 $i，j$(其中 $i=1,2,\dots,n, j=1,2,\dots,m$) 都有 $m_{ij}=m_{ji}$。也就是说 $\mathbf R$ 是对称的当且仅当 $\mathbf M_R=(\mathbf M_R)^t$</p>
<h4 id="反对称关系的矩阵"><a href="# 反对称关系的矩阵" class="headerlink" title="反对称关系的矩阵"></a>反对称关系的矩阵</h4><p>$\mathbf R$ 是反对称的，当 $i\neq j$ 时，$m_{ij}=0$ 或 $m_{ji}=0$</p>
<h4 id="关系运算和矩阵"><a href="# 关系运算和矩阵" class="headerlink" title="关系运算和矩阵"></a>关系运算和矩阵</h4><p>$$\mathbf M_{R_1\cup R_2}=\mathbf M_{R_1}\lor \mathbf M_{R_2}\\<br>\mathbf M_{R_1\cap R_2}=\mathbf M_{R_1}\land \mathbf M_{R_2}\\<br>\mathbf M_{R_1\cdot R_2}=\mathbf M_{R_1}\odot  \mathbf M_{R_2}\\$$</p>
<h3 id="用图表示关系"><a href="# 用图表示关系" class="headerlink" title="用图表示关系"></a>用图表示关系 </h3><p> 一个有向图由顶点 (或结点) 集 $V$ 和边 (或弧) 集 $E$ 组成，其中边集是 $V$ 中元素的有序对的集合。顶点 $a$ 叫做边 $(a,b)$ 的始点，而顶点 $b$ 叫做这条边的终点。<br>形如 $(a,a)$ 的边用一条从顶点 $a$ 到自身的弧表示。这种边叫做环。<br>用图来表示关系，就是把集合的每个元素表示成一个点，每个有序对表示成一条弧，弧上的箭头标明了弧的方向。    </p>
<h4 id="用图来确定关系的性质"><a href="# 用图来确定关系的性质" class="headerlink" title="用图来确定关系的性质"></a>用图来确定关系的性质</h4><ul>
<li>一个关系是自反的，当且仅当有向图的每个顶点都有环</li>
<li>一个关系是对称的，当且仅当有向图不同顶点之间的每一条边都存在一条方向相反的边</li>
<li>一个关系是反对称的，当且仅当在不同的两个顶点之间不存在两条方向相反的边</li>
<li>一个关系是传递的，当且仅当一条从顶点 $x$ 到顶点 $y$ 的边和一条顶点 $y$ 到顶点 $z$ 的边，就有一条从顶点 $x$ 到顶点 $z$ 的边(完成一个三角形，其中每条边都是具有正确方向的有向边)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关系的表示&quot;&gt;&lt;a href=&quot;# 关系的表示&quot; class=&quot;headerlink&quot; title=&quot;关系的表示&quot;&gt;&lt;/a&gt;关系的表示 &lt;/h2&gt;&lt;p&gt; 本文讨论用 $0-1$ 矩阵和有向图的方式表示关系。    &lt;/p&gt;
&lt;h3 id=&quot;用矩阵表示关系&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="Relations" scheme="http://blog.freeabyss.com/tags/Relations/"/>
    
  </entry>
  
</feed>
