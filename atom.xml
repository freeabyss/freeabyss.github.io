<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Abyss&#39;s blog</title>
  <subtitle>随笔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.freeabyss.com/"/>
  <updated>2017-01-27T08:26:36.000Z</updated>
  <id>http://blog.freeabyss.com/</id>
  
  <author>
    <name>Abyss</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Math-DM-28-关系的表示</title>
    <link href="http://blog.freeabyss.com/2017/01/22/Math-DM-28-%E5%85%B3%E7%B3%BB%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
    <id>http://blog.freeabyss.com/2017/01/22/Math-DM-28-关系的表示/</id>
    <published>2017-01-22T11:25:37.000Z</published>
    <updated>2017-01-27T08:26:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系的表示"><a href="#关系的表示" class="headerlink" title="关系的表示"></a>关系的表示</h2><p>本文讨论用$0-1$矩阵和有向图的方式表示关系。    </p>
<h3 id="用矩阵表示关系"><a href="#用矩阵表示关系" class="headerlink" title="用矩阵表示关系"></a>用矩阵表示关系</h3><p>假设$\mathbf R$是从$\mathbf A=\{a_1,a_2,\dots,a_m\}$到$\mathbf B=\{b_1,b_2,\dots,b_n\}$的关系。关系$\mathbf R$可以用矩阵$\mathbf M_R=[m_{ij}]$来表示，其中<br>$$m_{ij}=\begin{cases}1\qquad 如果(a_i,a_j)\in\mathbf R\\0\qquad 如果(a_i,b_j)\notin\mathbf R\end{cases}$$该表示方式，依赖于$\mathbf A$和$\mathbf B$的使用的排序。<br>集合上的关系的矩阵是一个方阵，可以用矩阵来确定关系是否具有某种性质。<br>例如$\mathbf R=\{(2,1),(3,1),(3,2)\}$,关于$\mathbf R$的矩阵是$$\mathbf M_R=\begin{bmatrix}0&amp;0\\1&amp;0\\1&amp;1\end{bmatrix}$$   </p>
<h4 id="自反关系的矩阵"><a href="#自反关系的矩阵" class="headerlink" title="自反关系的矩阵"></a>自反关系的矩阵</h4><p>$\mathbf R$是自反的，当且仅当$i=1,2,\dots,n,m_i=1$。换句话说，如果$\mathbf M_R$的主对角线的所有元素都等于1，那么$\mathbf R$是自反的。    </p>
<h4 id="对称关系的矩阵"><a href="#对称关系的矩阵" class="headerlink" title="对称关系的矩阵"></a>对称关系的矩阵</h4><p>$\mathbf R$是对称的，当且仅当对所有的整数对$i，j$(其中$i=1,2,\dots,n, j=1,2,\dots,m$)都有$m_{ij}=m_{ji}$。也就是说$\mathbf R$是对称的当且仅当$\mathbf M_R=(\mathbf M_R)^t$</p>
<h4 id="反对称关系的矩阵"><a href="#反对称关系的矩阵" class="headerlink" title="反对称关系的矩阵"></a>反对称关系的矩阵</h4><p>$\mathbf R$是反对称的，当$i\neq j$时，$m_{ij}=0$或$m_{ji}=0$</p>
<h4 id="关系运算和矩阵"><a href="#关系运算和矩阵" class="headerlink" title="关系运算和矩阵"></a>关系运算和矩阵</h4><p>$$\mathbf M_{R_1\cup R_2}=\mathbf M_{R_1}\lor \mathbf M_{R_2}\\<br>\mathbf M_{R_1\cap R_2}=\mathbf M_{R_1}\land \mathbf M_{R_2}\\<br>\mathbf M_{R_1\cdot R_2}=\mathbf M_{R_1}\odot  \mathbf M_{R_2}\\$$</p>
<h3 id="用图表示关系"><a href="#用图表示关系" class="headerlink" title="用图表示关系"></a>用图表示关系</h3><p>一个有向图由顶点(或结点)集$V$和边(或弧)集$E$组成，其中边集是$V$中元素的有序对的集合。顶点$a$叫做边$(a,b)$的始点，而顶点$b$叫做这条边的终点。<br>形如$(a,a)$的边用一条从顶点$a$到自身的弧表示。这种边叫做环。<br>用图来表示关系，就是把集合的每个元素表示成一个点，每个有序对表示成一条弧，弧上的箭头标明了弧的方向。    </p>
<h4 id="用图来确定关系的性质"><a href="#用图来确定关系的性质" class="headerlink" title="用图来确定关系的性质"></a>用图来确定关系的性质</h4><ul>
<li>一个关系是自反的，当且仅当有向图的每个顶点都有环</li>
<li>一个关系是对称的，当且仅当有向图不同顶点之间的每一条边都存在一条方向相反的边</li>
<li>一个关系是反对称的，当且仅当在不同的两个顶点之间不存在两条方向相反的边</li>
<li>一个关系是传递的，当且仅当一条从顶点$x$到顶点$y$的边和一条顶点$y$到顶点$z$的边，就有一条从顶点$x$到顶点$z$的边(完成一个三角形，其中每条边都是具有正确方向的有向边)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关系的表示&quot;&gt;&lt;a href=&quot;#关系的表示&quot; class=&quot;headerlink&quot; title=&quot;关系的表示&quot;&gt;&lt;/a&gt;关系的表示&lt;/h2&gt;&lt;p&gt;本文讨论用$0-1$矩阵和有向图的方式表示关系。    &lt;/p&gt;
&lt;h3 id=&quot;用矩阵表示关系&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="Relations" scheme="http://blog.freeabyss.com/tags/Relations/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 关系及其性质 27</title>
    <link href="http://blog.freeabyss.com/2017/01/21/Math-DM-27-%E5%85%B3%E7%B3%BB%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/"/>
    <id>http://blog.freeabyss.com/2017/01/21/Math-DM-27-关系及其性质/</id>
    <published>2017-01-21T08:59:50.000Z</published>
    <updated>2017-01-21T14:57:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二元关系"><a href="#二元关系" class="headerlink" title="二元关系"></a>二元关系</h2><p>关系是一种结构，通常用元组来表示关系。<br>集合之间的关系，是集合间的笛卡儿积的一个子集。<br>设$\mathbf A$和$\mathbf B$是集合，一个从$\mathbf A$到$\mathbf B$的二元关系是$\mathbf A\times \mathbf B$的子集。<br>二元关系表示了两个集合的元素之间的关系。$n$元关系表示三个以上集合中元素之间的关系。    </p>
<h3 id="函数作为关系"><a href="#函数作为关系" class="headerlink" title="函数作为关系"></a>函数作为关系</h3><p>函数表示了这样一种关系，对于$\mathbf A$中的每个元素恰好只有一个$\mathbf B$中的元素与之相关。  </p>
<h3 id="集合的关系"><a href="#集合的关系" class="headerlink" title="集合的关系"></a>集合的关系</h3><p>集合的关系表示集合到它自身的关系。 例如，集合$\mathbf A$的关系是从$\mathbf A$到$\mathbf A$的关系。    </p>
<h4 id="集合关系的数量"><a href="#集合关系的数量" class="headerlink" title="集合关系的数量"></a>集合关系的数量</h4><p>因为集合$\mathbf A$上的关系是$\mathbf A\times \mathbf A$的子集，$n$个元素集合的笛卡儿积有$n^2$个元素，因此集合$\mathbf A$存在$2^{n^2}$个关系。    </p>
<h3 id="关系的性质"><a href="#关系的性质" class="headerlink" title="关系的性质"></a>关系的性质</h3><h4 id="自反"><a href="#自反" class="headerlink" title="自反"></a>自反</h4><p>如果对每个元素$a\in\mathbf A$有$(a,a)\in\mathbf R$，那么集合$\mathbf A$上的关系$\mathbf R$叫做自反的。    </p>
<h4 id="反自反"><a href="#反自反" class="headerlink" title="反自反"></a>反自反</h4><p>如果对于每个$a\in\mathbf A$，有$(a,a)\notin\mathbf R$,那么集合$\mathbf A$上的关系$\mathbf R$是反自反的，即没有$\mathbf A$中的元素与自己有关系，关系$\mathbf R$就是反自反的。</p>
<h4 id="对称"><a href="#对称" class="headerlink" title="对称"></a>对称</h4><p>对于$a,b\in\mathbf A$，如果只要$(a,b)\in\mathbf R$就有$(b,a)\in\mathbf R$，则集合$\mathbf A$上的关系$\mathbf R$叫做对称的。$a$和$b$可以是相等的。  </p>
<h4 id="非对称的"><a href="#非对称的" class="headerlink" title="非对称的"></a>非对称的</h4><p>如果$(a,b)\in\mathbf R$推出(b,a)\notin\mathbf R$，关系$\mathbf R$叫做非对称的。  </p>
<h4 id="反对称"><a href="#反对称" class="headerlink" title="反对称"></a>反对称</h4><p>如果对$a,b\in\mathbf A$，仅当$a=b$时$(a,b)\in\mathbf R$和$(b,a)\in\mathbf R$，则集合$\mathbf A$上的关系$\mathbf R$叫做反对称的。<br>只要关系$\mathbf R$不存在这样的有序对:即由$a$和$b$构成，并且$a\neq b$，但是$(a,b)\in\mathbf R$和$(b,a)\in\mathbf R$。    </p>
<h4 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h4><p>如果对于$a,b,c\in\mathbf A，(a,b)\in\mathbf R$并且$(b,c)\in\mathbf R$则$(a,c)\in\mathbf R$，那么集合$\mathbf A$上的关系$\mathbf R$叫做传递的</p>
<h4 id="逆关系"><a href="#逆关系" class="headerlink" title="逆关系"></a>逆关系</h4><p>设$\mathbf R$是从集合$\mathbf A$到集合$\mathbf B$的关系。从$\mathbf B$到$\mathbf A$的逆关系是有序对的集合$\{(b,a)\mid (a,b)\in\mathbf R\}$，记作$\mathbf R^{-1}$。    </p>
<h4 id="补关系"><a href="#补关系" class="headerlink" title="补关系"></a>补关系</h4><p>补关系$\overline {\mathbf R}$是有序对的集合$\{(a,b)\mid (a,b)\notin\mathbf R\}$</p>
<h3 id="关系的组合"><a href="#关系的组合" class="headerlink" title="关系的组合"></a>关系的组合</h3><p>因为从$\mathbf A$到$\mathbf B$的关系是$\mathbf A\times\mathbf B$的子集，可以按照两个集合组合的任何方式来组合两个从$\mathbf A$到$\mathbf B$的关系。例如<br>$$\mathbf R_1\cup\mathbf  R_2 \\ \mathbf R_1\cap\mathbf R_2\\\mathbf R_1-\mathbf R_2\\\mathbf R_1\oplus\mathbf R_2$$<br>另一种组合方式类似于复函数。<br>设$\mathbf R$是从集合$\mathbf A$到集合$\mathbf B$的关系，$\mathbf S$是从集合$\mathbf B$到集合$\mathbf C$的关系。$\mathbf R$和$\mathbf S$的合成是由有序对$(a,c)$构成的关系，其中$a\in\mathbf A，c\in\mathbf C$，并且对于它们存在一个元素$b\in\mathbf B$使得$(a,b)\in\mathbf R$和$(b,c)\in\mathbf S$.我们用$\mathbf S\dots\mathbf R$表示$\mathbf R$和$\mathbf S$的合成。</p>
<h4 id="自身的合成"><a href="#自身的合成" class="headerlink" title="自身的合成"></a>自身的合成</h4><p>设$\mathbf R$是集合$\mathbf A$上的关系。幂$\mathbf R^n, n=1,2,3,\dots,$递归的定义为$$\mathbf R^1=\mathbf R\quad 和\quad \mathbf R^{n+1}=\mathbf R^n\cdot \mathbf R $$</p>
<h2 id="n元关系"><a href="#n元关系" class="headerlink" title="n元关系"></a>n元关系</h2><p>设$\mathbf A_1,\mathbf A_2,\dots ,\mathbf A_n$是集合。在这些集合上的$n$元关系是$\mathbf A_1\times\mathbf A_2\times\dots\times\mathbf A_n$的子集。这些集合$\mathbf A_1,\mathbf A_2,\dots,\mathbf A_n$叫做关系的域，$n$叫做它的阶。    </p>
<h3 id="n元关系运算"><a href="#n元关系运算" class="headerlink" title="n元关系运算"></a>n元关系运算</h3><h4 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h4><p>设$\mathbf R$是$n$元关系，$\mathbf C$是$\mathbf R$中元素可能满足的一个条件。那么选择运算$s_c$将$n$元关系$\mathbf R$映射到$\mathbf R$中满足条件$\mathbf C$的所有$n$元组构成的$n$元关系。    </p>
<h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>投影$\mathbf P_{i_1,i_2,\dots,i_m}$将$n$元组$(a_1,a_2,\dots,a_n)$映到$m$元组$(a_{i_1},a_{i_2},\dots,a_{i_m})$，其中$m\le n$。</p>
<h4 id="连接运算"><a href="#连接运算" class="headerlink" title="连接运算"></a>连接运算</h4><p>设$\mathbf R$是$m$元关系且$\mathbf S$是$n$元关系，其中$p\le m$和$p\le n$。连接$\mathbf J_p(\mathbf R,\mathbf S)$是$m+n-p$元关系，它包含了所有的$(m+n-p)$元组$(a_1,a_2,\dots,a_{m-p},c_1,c_2,\dots,c_p,b_1,b_2,\dots,b_{n-p})$，其中$m$元组(a_1,a_2,\dots,a_{m-p},c_1,c_2,\dots,c_p)$属于$\mathbf R$且$n$元组$(c_1,c_2,\dots,c_p,b_1,b_2,\dots,b_{n-p})$属于$\mathbf S$。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二元关系&quot;&gt;&lt;a href=&quot;#二元关系&quot; class=&quot;headerlink&quot; title=&quot;二元关系&quot;&gt;&lt;/a&gt;二元关系&lt;/h2&gt;&lt;p&gt;关系是一种结构，通常用元组来表示关系。&lt;br&gt;集合之间的关系，是集合间的笛卡儿积的一个子集。&lt;br&gt;设$\mathbf A$
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="Relations" scheme="http://blog.freeabyss.com/tags/Relations/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 最佳实践</title>
    <link href="http://blog.freeabyss.com/2017/01/17/JavaScript-JavaScript-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://blog.freeabyss.com/2017/01/17/JavaScript-JavaScript-最佳实践/</id>
    <published>2017-01-17T06:25:53.000Z</published>
    <updated>2017-01-18T07:48:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UI-松耦合"><a href="#UI-松耦合" class="headerlink" title="UI 松耦合"></a>UI 松耦合</h2><h3 id="将JavaScript从CSS中抽离"><a href="#将JavaScript从CSS中抽离" class="headerlink" title="将JavaScript从CSS中抽离"></a>将JavaScript从CSS中抽离</h3><p>IE8及更早版本的IE有一个特性，允许将JavaScript直接插入CSS中。虽然IE9已经不在支持这种特性，但应当注意不要在CSS中嵌入JavaScript代码</p>
<h3 id="将CSS从JavaScript中抽离"><a href="#将CSS从JavaScript中抽离" class="headerlink" title="将CSS从JavaScript中抽离"></a>将CSS从JavaScript中抽离</h3><p>所有的样式信息都应当保持在CSS中，当需要通过JavaScript来修改元素样式的时候，最佳方法是操作CSS的<code>className</code>。<br>有一种情形可以例外:当需要给页面中的元素作定位，使其相对于另外一个元素或整个页面重新定位。这种计算是无法在CSS中完成的。    </p>
<h3 id="将JavaScript从HTML中抽离"><a href="#将JavaScript从HTML中抽离" class="headerlink" title="将JavaScript从HTML中抽离"></a>将JavaScript从HTML中抽离</h3><ul>
<li>最好将所有的JavaScript代码都放入外置文件中，并在页面中通过<code>&lt;script&gt;</code>标签引用</li>
<li>在HTML页面中，禁止使用<code>on</code>属性挂载事件处理程序。应当使用方法来添加事件</li>
</ul>
<h3 id="将HTML从JavaScript中抽离"><a href="#将HTML从JavaScript中抽离" class="headerlink" title="将HTML从JavaScript中抽离"></a>将HTML从JavaScript中抽离</h3><p>尽量避免将HTML嵌入JavaScript代码中。</p>
<h2 id="避免使用全局变量"><a href="#避免使用全局变量" class="headerlink" title="避免使用全局变量"></a>避免使用全局变量</h2><p>全局变量和全局函数带来很多问题，例如命名冲突、代码脆弱性、难以测试、意外的bug。    </p>
<h3 id="零全局变量方式"><a href="#零全局变量方式" class="headerlink" title="零全局变量方式"></a>零全局变量方式</h3><p>如果你的代码运行时不需要于其他代码产生交互，可以使用零全局变量方式 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">win</span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line">    <span class="comment">// body</span></div><div class="line">&#125;(<span class="built_in">window</span>));</div></pre></td></tr></table></figure>
<p>如果项目中使用jQuery框架的话，一般用<code>jQuery</code>代替<code>window</code>。 </p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="隔离应用逻辑"><a href="#隔离应用逻辑" class="headerlink" title="隔离应用逻辑"></a>隔离应用逻辑</h3><p>将应用逻辑从事件处理程序中抽离出来有两点好处:一是可重用，二是方便测试。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> popup = <span class="built_in">document</span>.getElementById(<span class="string">"popup"</span>);</div><div class="line">    popup.style.left = event.clientX + <span class="string">"px"</span>;</div><div class="line">    popup.style.top = event.clientY + <span class="string">"px"</span>;</div><div class="line">    popup.className = <span class="string">"reveal"</span>;</div><div class="line">&#125;</div><div class="line">addListener(element, <span class="string">"click"</span>, handleClick);</div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">var</span> MyApplication = &#123;</div><div class="line">    handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.showPopup(event);</div><div class="line">    &#125;,</div><div class="line">    showPopup: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> popup = <span class="built_in">document</span>.getElementById(<span class="string">"popup"</span>);</div><div class="line">        popup.style.left = event.clientX + <span class="string">"px"</span>;</div><div class="line">        popup.style.top = event.clientY + <span class="string">"px"</span>;</div><div class="line">        popup.className = <span class="string">"reveal"</span>;        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">addListener(element, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    MyApplication.handleClick(event);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="不要分发事件"><a href="#不要分发事件" class="headerlink" title="不要分发事件"></a>不要分发事件</h3><p>上述实例代码还存在一个问题，即<code>event</code>被毫无节制地分发，应用逻辑不应当依赖于<code>event</code>对像，原因如下:      </p>
<ul>
<li>方法接口没有表明那些数据是必要的。好的API应该明确清楚表明回调传值的用处以及需要传那些值 </li>
<li>最重要的一点是，如果想测试这个方法，必须重新创建一个<code>event</code>对象并将它作为参数传入。</li>
</ul>
<p>最佳方法是让事件处理程序使用<code>event</code>对象来处理事件，然后拿到所有需要的数据传给应用逻辑。<br>另外，如果需要对<code>event</code>执行任何必要的操作，包括阻止默认事件或阻止事件冒泡，都应该直接包含在事件处理程序中。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyApplication = &#123;</div><div class="line">    handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        event.preventDefault();</div><div class="line">        event.stopPropagation();</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.showPopup(event.clientX, event.clientY);</div><div class="line">    &#125;,</div><div class="line">    showPopup: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> popup = <span class="built_in">document</span>.getElementById(<span class="string">"popup"</span>);</div><div class="line">        popup.style.left = x + <span class="string">"px"</span>;</div><div class="line">        popup.style.top = y +<span class="string">"px"</span>;</div><div class="line">        popup.className = <span class="string">"reveal"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="避免“空比较”"><a href="#避免“空比较”" class="headerlink" title="避免“空比较”"></a>避免“空比较”</h2><h3 id="检测原始值"><a href="#检测原始值" class="headerlink" title="检测原始值"></a>检测原始值</h3><p>如果你希望一个值是字符串、数字、布尔值或<code>undefined</code>，最佳选择是使用<code>typeof</code>运算符。<code>typeof</code>的独特之处在于，将其用于一个未声明的变量也不会报错。<br><code>null</code>一般不应用于检测语句，简单的和<code>null</code>比较通常不会包含足够的信息以判断值的类型是否合法。 但是如果所期望的值真的是<code>null</code>，则可以直接和<code>null</code>比较。这时应当使用<code>===</code>或<code>!==</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">"string"</span>) &#123;</div><div class="line">    anotherName = name.substirng(<span class="number">3</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> count === <span class="string">"number"</span>) &#123;</div><div class="line">    updateCount(count);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> found === <span class="string">"boolean"</span> &amp;&amp; found) &#123;</div><div class="line">    message(<span class="string">"Found!"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> MyApp === <span class="string">"undefined"</span>) &#123;</div><div class="line">    MyApp = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"><span class="comment">// null</span></div><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"my-div"</span>);</div><div class="line"><span class="keyword">if</span> (element !== <span class="literal">null</span>) &#123;</div><div class="line">    element.className = <span class="string">"found"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="检测引用值"><a href="#检测引用值" class="headerlink" title="检测引用值"></a>检测引用值</h3><ul>
<li>杜绝使用<code>typeof</code>检测<code>null</code>的类型，因为<code>typeof null</code>会返回<code>object</code></li>
<li>检测自定义类型或者内置类型可以使用<code>value instanceof Object</code>来判断，不过因为<code>instanceof</code>不仅检测对象的构造器，还检测原型链，因此使用时需注意 </li>
</ul>
<h3 id="检测函数"><a href="#检测函数" class="headerlink" title="检测函数"></a>检测函数</h3><p>检测函数最好的方法是使用<code>typeof</code>。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myFunc === <span class="string">"function"</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>检测数组最优雅的解决方案是:   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">"[object Array]"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式在识别内置对象时往往十分有用。<br>ECMAScript5 已经将<code>Array.isArray</code>正式引入JavaScript。</p>
<h3 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h3><ul>
<li>判断属性是否存在的最好办法是使用<code>in</code>运算符。<code>in</code>运算符仅仅简单的判断属性是否存在，而不会读取属性的值 </li>
<li><code>in</code>运算符同时会检测对象的原型，如果只想检测实例对象的某个属性是否存在，则使用<code>hasOwnProperty()</code>方法</li>
</ul>
<h2 id="将配置数据从代码中分离出来"><a href="#将配置数据从代码中分离出来" class="headerlink" title="将配置数据从代码中分离出来"></a>将配置数据从代码中分离出来</h2><p>配置数据示例:     </p>
<ul>
<li>URL</li>
<li>需要展现给用户的字符串</li>
<li>重复的值</li>
<li>设置(比如每页的配置项)</li>
<li>任何可能发生变更的值</li>
</ul>
<p>最好将配置数据抽离出来，可以放在文件最前面，或者单独一个文件。好处是不用修改JavaScript源码已、方便修改和防止漏改。   </p>
<h2 id="抛出自定义错误"><a href="#抛出自定义错误" class="headerlink" title="抛出自定义错误"></a>抛出自定义错误</h2><h3 id="抛出错误的方式"><a href="#抛出错误的方式" class="headerlink" title="抛出错误的方式"></a>抛出错误的方式</h3><p>抛出错误时，最好抛出<code>Error</code>类型对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Something bad happened'</span>);</div></pre></td></tr></table></figure>
<h3 id="抛出错误的好处"><a href="#抛出错误的好处" class="headerlink" title="抛出错误的好处"></a>抛出错误的好处</h3><p>抛出错误有助于调试，例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDivs</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (element &amp;&amp; element.getElementsByTagName) &#123;</div><div class="line">        <span class="keyword">return</span> element.getElementsByTagName(<span class="string">"div"</span>);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"getDivs() : Argument must be a DOM element."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="何时检查错误"><a href="#何时检查错误" class="headerlink" title="何时检查错误"></a>何时检查错误</h3><ul>
<li>如果一个函数被已知的实体调用，错误检查很可能没有必要，一般情况下该函数为私有函数</li>
<li>如果不能确定函数被调用的所有地方，则需要进行一些错误检查</li>
<li>抛出错误最佳的地方是在工具函数中  </li>
<li>一旦修复了一个很难调试的错误，尝试增加一两个自定义错误，当再次发生错误时，这将有助于更容易的解决问题</li>
<li>如果正在编写代码，思考一下: “我希望[某些事情]不会发生，如果发生，我的代码会一团糟糕”。这时，如果“某些事情”发生，就抛出一个错误</li>
<li>如果正在编写的代码别人也会使用，思考一下他们使用的方式在特定的情况下抛出错误</li>
<li>抛出错误的目的不是防止错误，而是在错误发生时能更加容易地调试</li>
</ul>
<h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><ul>
<li>可以用<code>instanceof</code>判断错误类型，从而处理特定的错误</li>
<li>自定义错误类型可以区别于浏览器抛出的错误</li>
<li>不要将<code>try-catch</code>中的<code>catch</code>块留空</li>
</ul>
<h2 id="直接量"><a href="#直接量" class="headerlink" title="直接量"></a>直接量</h2><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>禁止八进制直接量</p>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>以下场景应当使用<code>null</code></p>
<ul>
<li>用来初始化一个变量</li>
<li>用来和一个已初始化的变量比较</li>
<li>当函数的入参和返回值</li>
</ul>
<p>以下场景不应当使用<code>null</code>   </p>
<ul>
<li>不要使用<code>null</code>来检测是否传入了某个参数 </li>
<li>不要用<code>null</code>来检测一个未初始化的变量<br>理解<code>null</code>最好的方式是将它当作对象的占位符。    <h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3>避免在代码中使用<code>undefined</code>。  尤其不要将一个变量赋值为<code>undefined</code>。</li>
</ul>
<h3 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h3><p>推荐使用对象直接量的方式创建一个对象。    </p>
<h3 id="数组直接量"><a href="#数组直接量" class="headerlink" title="数组直接量"></a>数组直接量</h3><p>推荐使用数组直接量的方式创建数组</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>任何情况下，都不应该省略<code>default</code>语句。    </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UI-松耦合&quot;&gt;&lt;a href=&quot;#UI-松耦合&quot; class=&quot;headerlink&quot; title=&quot;UI 松耦合&quot;&gt;&lt;/a&gt;UI 松耦合&lt;/h2&gt;&lt;h3 id=&quot;将JavaScript从CSS中抽离&quot;&gt;&lt;a href=&quot;#将JavaScript从CSS中抽离&quot;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.freeabyss.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.freeabyss.com/tags/JavaScript/"/>
    
      <category term="effective" scheme="http://blog.freeabyss.com/tags/effective/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript编程风格</title>
    <link href="http://blog.freeabyss.com/2017/01/17/JavaScript-JavaScript-%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"/>
    <id>http://blog.freeabyss.com/2017/01/17/JavaScript-JavaScript-编程风格/</id>
    <published>2017-01-17T02:40:58.000Z</published>
    <updated>2017-01-17T07:12:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h2><h3 id="基本格式化"><a href="#基本格式化" class="headerlink" title="基本格式化"></a>基本格式化</h3><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>使用4个空格进行缩进     </p>
<h4 id="语句结尾"><a href="#语句结尾" class="headerlink" title="语句结尾"></a>语句结尾</h4><p>不要省略分号     </p>
<h4 id="长度限制"><a href="#长度限制" class="headerlink" title="长度限制"></a>长度限制</h4><p>每行的长度不要超过100字符  </p>
<h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>当需要换行时，最好在运算符后换行，下一行增加两个层级的缩进。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">callAFunction(<span class="built_in">document</span>, element, <span class="built_in">window</span>, <span class="string">"some string value"</span>, <span class="literal">true</span>, <span class="number">123</span>,</div><div class="line">        navigator);</div></pre></td></tr></table></figure>
<p>例外:当给变量赋值时，第二行的位置应当和赋值运算符的位置保持对齐，比如:      </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = something + anotherThing + yeAnotherTing + somethingElse + </div><div class="line">             anotherSomethingElse;</div></pre></td></tr></table></figure>
<h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><p>一般在以下场景中添加空行:      </p>
<ul>
<li>方法之间</li>
<li>方法中的局部变量和第一条语句之间</li>
<li>在多行或单行注释之前</li>
<li>在方法内的逻辑片段之间插入空行，提高可读性</li>
</ul>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ul>
<li>遵照小驼峰式大小写命名法，即由小写字母开始，后续每个单词首字母都大写   </li>
<li>变量尽量以名词作为前缀，函数以动词作为前缀  </li>
<li>尽量在变量名中体现出值的数据类型，例如<code>count</code>、<code>length</code>和<code>size</code>表明数据类型是数字，<code>name</code>、<code>title</code>和<code>message</code>表明数据类型是字符串</li>
<li>单个字符命名的变量，例如<code>i</code>、<code>j</code>和<code>k</code>通常在循环中使用   <h5 id="动词常见的约定"><a href="#动词常见的约定" class="headerlink" title="动词常见的约定"></a>动词常见的约定</h5>|动词| 含义|<br>|:–|:—|<br>|can| 函数返回一个布尔值|<br>|has| 函数返回一个布尔值|<br>|is | 函数返回一个布尔值|<br>|get| 函数返回一个非布尔值|<br>|set| 函数用来保存一个值|</li>
</ul>
<h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>使用大写字母和下划线 </p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>构造函数即前面冠以<code>new</code>运算符的函数，遵循大驼峰命名法，即以大写字母开始，后续每个单词首字母都大写。     </p>
<h4 id="直接量字符串使用双引号，主要是因为方便在Java和JavaScript之间来回切换。"><a href="#直接量字符串使用双引号，主要是因为方便在Java和JavaScript之间来回切换。" class="headerlink" title="直接量字符串使用双引号，主要是因为方便在Java和JavaScript之间来回切换。"></a>直接量字符串使用双引号，主要是因为方便在<code>Java</code>和<code>JavaScript</code>之间来回切换。</h4><p>禁止使用多行字符串，使用字符串连接符将字符串分成多份。     </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">var</span> longString = <span class="string">"Here's the sotry, of a man \</span></div><div class="line">named Brady";</div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">var</span> longString = <span class="string">"Here's the sotry, of a man "</span> +</div><div class="line">                 <span class="string">"named Brady"</span>;</div></pre></td></tr></table></figure>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h4 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h4><ul>
<li>独占一行的注释，用来解释下一行代码。这行注释之前总是有一个空行，且缩进层级和下一行代码保持一致</li>
<li>代码行尾部的注释。代码结束到注释之间至少有一个缩进。并且不应当超过单行最大字符数限制，如果超过了应该将注释放在代码行上方</li>
<li>单行注释不应该以连续多行注释的形式出现，除非你注释掉一大段代码</li>
</ul>
<h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4><ul>
<li>多行注释推荐使用<code>Java</code>的风格</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 这是一段多行注释</div><div class="line"> * 这段注释包含两行文本</div><div class="line"> */</div></pre></td></tr></table></figure>
<ul>
<li>多行注释和代码之间没有空行，注释上方应当有一行空行，并且缩进层级和下放的代码保持一致</li>
</ul>
<h4 id="使用注释"><a href="#使用注释" class="headerlink" title="使用注释"></a>使用注释</h4><ul>
<li>难于理解的代码通常都应当加注释</li>
<li>可能被误认为错误的代码，应当添加注释，防止被好心的开发者“修复”</li>
</ul>
<h2 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h2><p>无论何种情况下，所有块语句都应当使用花括号，包括:</p>
<ul>
<li>if…else</li>
<li>for</li>
<li>while</li>
<li>do…while</li>
<li>try…catch…finally</li>
</ul>
<h3 id="花括号的对齐方式"><a href="#花括号的对齐方式" class="headerlink" title="花括号的对齐方式"></a>花括号的对齐方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">    doSomething();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    doSomethingElse();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><h4 id="缩进-1"><a href="#缩进-1" class="headerlink" title="缩进"></a>缩进</h4><ul>
<li>每条<code>case</code>语句相对于<code>switch</code>关键字都缩进一个层级</li>
<li>从第二条<code>case</code>语句开始，每条<code>case</code>语句前后各有一个空行</li>
<li>连续的<code>case</code>语句之间省略空行</li>
<li><code>default</code>语句是必须的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (condition) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"first"</span>:</div><div class="line">         <span class="comment">// 代码</span></div><div class="line">         <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="string">"second"</span>:</div><div class="line">    <span class="keyword">case</span> <span class="string">"third"</span>:</div><div class="line">         <span class="comment">// 代码</span></div><div class="line">         <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>: </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="变量、函数和运算符"><a href="#变量、函数和运算符" class="headerlink" title="变量、函数和运算符"></a>变量、函数和运算符</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>推荐将局部变量的定义作为函数内第一条语句。 并且推荐使用单<code>var</code>语句风格，每个变量的初始化独占一行，没有初始值的变量放在<code>var</code>语句的尾部。 例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingWithItems</span>(<span class="params">items</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> value = <span class="number">10</span>,</div><div class="line">        result = value + <span class="number">10</span>,</div><div class="line">        i, len;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>, len=items.length; i&lt;len; i++) &#123;</div><div class="line">        doSomething(items[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><ul>
<li>推荐先声明函数，再使用</li>
<li>对于函数内的局部函数，应该紧接着变量声明之后声明，之间用空行隔开</li>
<li>函数声明禁止出现在<code>if</code>、<code>while</code>、<code>for</code>、<code>try...catch</code>、<code>switch</code>的语句块内</li>
</ul>
<h3 id="立即调用的函数"><a href="#立即调用的函数" class="headerlink" title="立即调用的函数"></a>立即调用的函数</h3><p>为了让立即执行的函数能够被一眼看出来，将函数用一对圆括号包裹起来。比如:    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> value = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 函数体</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        message: <span class="string">"Hi"</span></div><div class="line">    &#125;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>最好不要在全局作用域使用<code>&quot;use strict&quot;</code>。 如果你将多个文件连接合并成一个文件时，当期中一个文件在全局作用域中启用了严格模式，则所有的代码都将以严格模式解析，这会很可能造成其他以非严格模式写的代码报错。     </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// code </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line">    <span class="comment">// code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>推荐所有函数中都加上<code>&quot;use strict&quot;</code>。 </p>
<h3 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h3><p>因为强制类型转换的缘故，推荐使用<code>===</code>和<code>!==</code>，而不要使用<code>==</code>和<code>!=</code>。</p>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><ul>
<li>尽量避免使用<code>eval()</code>，如果无它法，尽量在严格模式下使用<code>eval()</code></li>
<li>严禁使用<code>Function</code> </li>
<li>可以使用<code>setTimeout()</code>和<code>setInterval()</code>，但不要用字符串形式，要用函数</li>
</ul>
<h3 id="原始包装类型"><a href="#原始包装类型" class="headerlink" title="原始包装类型"></a>原始包装类型</h3><p>禁止使用原始包装类型</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编程风格&quot;&gt;&lt;a href=&quot;#编程风格&quot; class=&quot;headerlink&quot; title=&quot;编程风格&quot;&gt;&lt;/a&gt;编程风格&lt;/h2&gt;&lt;h3 id=&quot;基本格式化&quot;&gt;&lt;a href=&quot;#基本格式化&quot; class=&quot;headerlink&quot; title=&quot;基本格式化&quot;&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.freeabyss.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.freeabyss.com/tags/JavaScript/"/>
    
      <category term="style guideline" scheme="http://blog.freeabyss.com/tags/style-guideline/"/>
    
  </entry>
  
  <entry>
    <title>Windows 10 快速安装.NET 3.5</title>
    <link href="http://blog.freeabyss.com/2017/01/16/Window-Windows-10-%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85-NET-3-5/"/>
    <id>http://blog.freeabyss.com/2017/01/16/Window-Windows-10-快速安装-NET-3-5/</id>
    <published>2017-01-16T03:49:25.000Z</published>
    <updated>2017-01-16T03:52:55.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>加载windows 10镜像文件到光驱</li>
<li>按<code>Win</code>+<code>X</code>，选择’命令提示符(管理员)’ </li>
<li>输入以下命令，其中<code>D:</code>代表光驱盘符 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dism.exe /online /enable-feature /featurename:netfx3 /Source:D:\sources\sxs</div></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;加载windows 10镜像文件到光驱&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;Win&lt;/code&gt;+&lt;code&gt;X&lt;/code&gt;，选择’命令提示符(管理员)’ &lt;/li&gt;
&lt;li&gt;输入以下命令，其中&lt;code&gt;D:&lt;/code&gt;代表光驱盘符 &lt;figure class
    
    </summary>
    
      <category term="windows" scheme="http://blog.freeabyss.com/categories/windows/"/>
    
    
      <category term="windows" scheme="http://blog.freeabyss.com/tags/windows/"/>
    
      <category term="os" scheme="http://blog.freeabyss.com/tags/os/"/>
    
      <category term=".net" scheme="http://blog.freeabyss.com/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>幻方介绍</title>
    <link href="http://blog.freeabyss.com/2017/01/15/Math-01-%E5%B9%BB%E6%96%B9/"/>
    <id>http://blog.freeabyss.com/2017/01/15/Math-01-幻方/</id>
    <published>2017-01-15T10:10:55.000Z</published>
    <updated>2017-01-21T09:06:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="幻方"><a href="#幻方" class="headerlink" title="幻方"></a>幻方</h2><p>幻方是一种将数字安排在正方形格子中，使每行、列和对角线上的数字和都相等的方法。<br>通常幻方由从$1$到$n^2$的连续整数组成。其中$n$为正方形的行或列的数目。因此$n$阶幻方有$n$行$n$列。<br>幻和是幻方各行、各列、各对角线上所有数的和。幻和的公式: $$s={n(n^2+1)\over 2}$$</p>
<h3 id="幻方的数量"><a href="#幻方的数量" class="headerlink" title="幻方的数量"></a>幻方的数量</h3><h3 id="幻方生成方法"><a href="#幻方生成方法" class="headerlink" title="幻方生成方法"></a>幻方生成方法</h3><h4 id="奇数阶幻方构造法"><a href="#奇数阶幻方构造法" class="headerlink" title="奇数阶幻方构造法"></a>奇数阶幻方构造法</h4><ul>
<li>把$1$放置在第一行的中间    </li>
<li>顺序将$2、3、\dots$等数放在右上方格子中。</li>
<li>当右上方格出界的时候，则由另一方进入。 </li>
<li>当右上方格中已经填有数，则把数填入正下方的方格中。</li>
<li>按照以上步骤直到填完所有$n^2$个方格。      <h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5>以$5$阶幻方为例<br>第一行中间格填 1，从这个格子开始，向右上方按顺序填充。如果超出了第一行，则填到最底下一行；如果超出了最右边一列，则填到最左边一列<br><img src="../images/magic_0.jpg" alt="阶乘图"><br>如果遇到下一个格子里已经有数字的，就填到当前格子的下方<br><img src="../images/magic_1.jpg" alt="阶乘图"><br>按照上面两条规则继续填充<br><img src="../images/magic_2.jpg" alt="阶乘图"></li>
</ul>
<h4 id="4m阶幻方构造法"><a href="#4m阶幻方构造法" class="headerlink" title="4m阶幻方构造法"></a>4m阶幻方构造法</h4><ul>
<li>将所有格子划分为$2m\times 2m$的小幻方，给每个小幻方画上对角线。      </li>
<li>从第一行第一列开始，从左往右，从上到下，从$1$到$(4m)^2$。依次填充。规则是只填充没对角线经过的格子。</li>
<li>从最后一行最后一列开始，从右到左，从下到上，从$1$到$(4m)^2$依次填充。规则是只填充对角线经过的格子。 </li>
</ul>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>以$8$阶幻方为例，将其分成$4$个$4\times 4$个小幻方，每个小幻方画上对角线。<br><img src="../images/magic_3.jpg" alt="阶乘图"><br>从第一行第一列，从左到右，从上到下，从$1$到$64$，依次填充，跳过对角线经过的格子<br><img src="../images/magic_4.jpg" alt="阶乘图"><br>从最后一行最后一列，从右到左，从下到上，从$1$到$64$，依次添加，跳过对角线没有经过的格子，忽略已经填过的数字<br><img src="../images/magic_5.jpg" alt="阶乘图">      </p>
<h4 id="4m-2阶幻方构造法"><a href="#4m-2阶幻方构造法" class="headerlink" title="4m+2阶幻方构造法"></a>4m+2阶幻方构造法</h4><ul>
<li>将格子分成$4$个等大的象限。      </li>
<li>按照$A\rightarrow D\rightarrow B\rightarrow C$的顺序，把四个部分按照奇数阶幻方的顺序填充起来。      </li>
<li>从$A$象限的中间行中间列开始为第一格，往右标出$m$格。然后标出$A$象限其他行的左边$m$列。把$A$象限作出标记的格子跟$C$象限对应的格子对换。     </li>
<li>从$B$象限的中间列开始，向左标出$m-1$列，与$D$象限对换。</li>
</ul>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><p>以$6$阶幻方为例。<br>把格子分成$4$个等大的象限<br><img src="../images/magic_6.jpg" alt="阶乘图"><br>按照$A\rightarrow D\rightarrow B\rightarrow C$的顺序，把四个部分按照奇数阶幻方的顺序填充起来。<br><img src="../images/magic_7.jpg" alt="阶乘图"><br>标出需要互换的格子，因为$m-1=0$所以$B、D$象限不需要互换<br><img src="../images/magic_8.jpg" alt="阶乘图">      </p>
<p>如果是$14$阶幻方，需要对换的格子如下图所示<br><img src="../images/magic_9.jpg" alt="阶乘图">      </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;幻方&quot;&gt;&lt;a href=&quot;#幻方&quot; class=&quot;headerlink&quot; title=&quot;幻方&quot;&gt;&lt;/a&gt;幻方&lt;/h2&gt;&lt;p&gt;幻方是一种将数字安排在正方形格子中，使每行、列和对角线上的数字和都相等的方法。&lt;br&gt;通常幻方由从$1$到$n^2$的连续整数组成。其中$n
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 递推关系</title>
    <link href="http://blog.freeabyss.com/2017/01/11/Math-DM-26-%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB/"/>
    <id>http://blog.freeabyss.com/2017/01/11/Math-DM-26-递推关系/</id>
    <published>2017-01-11T13:00:45.000Z</published>
    <updated>2017-01-21T09:06:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h2><p>对于递归定义，这个从某些前项求后项的规则就叫做递推关系。<br>关于序列$\{a_n\}$的递推关系是一个等式，它把$a_n$用序列中在$a_n$前面的一项或多项即$a_0,a_1,\dots,a_{n-1}$来表示，这里$n\ge n_0$，$n_0$是一个非负整数。如果一个序列的项满足递推关系，这个序列就叫做递推关系的解。     </p>
<h3 id="用递推关系构造模型"><a href="#用递推关系构造模型" class="headerlink" title="用递推关系构造模型"></a>用递推关系构造模型</h3><h4 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h4><p>令$H_n$表示解$n$个盘子的汉诺塔问题所需要的移动次数。建立一个关于序列$\{H_n\}$的递推关系。<br>解:开始$n$个盘子在柱1。按照游戏规则我们可以用$H_{n-1}$次移动将上边的$n-1$个盘子移动柱3.在这些移动中保留最大的盘子不动。然后，我们用一次移动将最大的盘子移动第二根柱子上。我们可以再使用$H_{n-1}$次移动将柱3上的$n-1$个盘子移到柱2，把它们放到最大的盘子上面，这个最大的盘子一直放在柱2的底部。容易看出，使用更少的步数是不能求解这个难题。这就证明了$H_n=2H_{n-1}+1$。<br>使用迭代方法求这个递推关系:$$\begin{array}{l}H_n&amp;=2H_{n-1}+1\\ &amp;=2(2H_{n-2}+1)+1=2^2H_{n-2}+2+1\\ &amp;=2^2(2H_{n-3}+1)+2+1=2^3H_{n-3}+2^2+2+1\\ &amp;\dots\\ &amp;=2^{n-1}H_1+2^{n-2}+2^{n-3}+\dots+2+1\\ &amp;=2^{n-1}+2^{n-2}+\dots+2+1\\&amp;=2^n-1\end{array}$$</p>
<h4 id="编码字的枚举"><a href="#编码字的枚举" class="headerlink" title="编码字的枚举"></a>编码字的枚举</h4><p>一个计算机系统把一个十进制数字串作为一个编码字，如果它包含偶数个$0$，就是有效的。<br>注意到$a_1=9$，因为存在$10$个$1$位十进制数字串，并且只有一个，即串$0$是无效的。通过考虑怎样由$n-1$位的数字串构成一个$n$位有效数字串，就可以推导出关于这个序列的递推关系。从少$1$位数字的串构成$n$位有效数字串有两种方式:      </p>
<ol>
<li>在一个$n-1$位有效数字串后面加上一个非$0$的数字就可以得到一个$n$位的有效数字串。加这个数字的方式有$9$种。因此用这个方法构成$n$位有效数字串的方式有$9a_{n-1}$种。      </li>
<li>在一个无效的$n-1$位数字串后面加上一个$0$就可以得到$n$位有效的数字串。这样做的方式数等于无效的$n-1$位数字串的个数。因为存在$10^{n-1}$个$n-1$位数字串，其中有$a_{n-1}$个是有效的，通过在无效的$n-1$位数字串后面加上一个$0$就得到$10^{n-1}-a_{n-1}$个$n$位的有效数字串。<br>因为所有的$n$位有效数字串都用这两种方式之一产生，从而存在$$\begin{array}{l}a_n &amp;=9a_{n-1}+(10^{n-1}-a_{n-1})\\ &amp;=8a_{n-1}+10^{n-1}\end{array}$$</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;递推关系&quot;&gt;&lt;a href=&quot;#递推关系&quot; class=&quot;headerlink&quot; title=&quot;递推关系&quot;&gt;&lt;/a&gt;递推关系&lt;/h2&gt;&lt;p&gt;对于递归定义，这个从某些前项求后项的规则就叫做递推关系。&lt;br&gt;关于序列$\{a_n\}$的递推关系是一个等式，它把$a_n
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
  </entry>
  
  <entry>
    <title>npm 概述</title>
    <link href="http://blog.freeabyss.com/2017/01/08/JavaScript-NPM-%E6%A6%82%E8%BF%B0/"/>
    <id>http://blog.freeabyss.com/2017/01/08/JavaScript-NPM-概述/</id>
    <published>2017-01-08T04:24:29.000Z</published>
    <updated>2017-01-17T06:29:40.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.freeabyss.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.freeabyss.com/tags/JavaScript/"/>
    
      <category term="npm" scheme="http://blog.freeabyss.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 递归 25</title>
    <link href="http://blog.freeabyss.com/2017/01/07/Math-DM-25-%E9%80%92%E5%BD%92/"/>
    <id>http://blog.freeabyss.com/2017/01/07/Math-DM-25-递归/</id>
    <published>2017-01-07T08:20:54.000Z</published>
    <updated>2017-01-09T14:06:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>为了定义以非负整数集合作为其定义域的函数，使用两个步骤:<br>基础步骤:规定这个函数在$0$处的值。<br>递归步骤:给出从较小的整数处的值来求出当前的值的规则。<br>这样的定义称为递归定义或归纳定义。     </p>
<h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p>斐波那契数$f_0,f_1,f_2,\dots $是用方程组$f_0=0,f_1=1$和$f_n=f_{n-1}+f_n$来定义的。<br>其中$n=2,3,4,\dots $ </p>
<h4 id="使用斐波那契数的性质证明示例"><a href="#使用斐波那契数的性质证明示例" class="headerlink" title="使用斐波那契数的性质证明示例"></a>使用斐波那契数的性质证明示例</h4><p>证明:每当$n\ge 3$时，有$f_n&gt;a_{n-1}$，其中$a=(1+\sqrt 5)/2$<br>基础步骤:证明$P(3)$和$P(4)$都为真。 $$a<2=f_3,\; a^2="(3+\sqrt" 5)="" 2<3="f_4$$" 归纳步骤:假定$p(j)$为真，即对所有满足$3\le="" j\le="" k$的整数$j$来说有$f_j="">a^{j-2}$。其中$k\ge 4$。必须证明$P(k+1)$为真，即$f_{k+1}&gt;a^{k-1}$。因为$a$是$x^2-x-1=0$的解，所有得出$a^2=a+1$。因此$$a^{k-1}=a^2\cdot a^{k-1}=(a+1)a^{k-3}=a\cdot a^{k-3}+1\cdot a^{k-3}=a^{k-2}+a^{k-3}$$<br>根据归纳假设，若$k\ge 4$则得出 $$f_{k-1}&gt;a^{k-3},\;\;f_k&gt;a^{k-2}$$<br>因此有 $$f_{k+1}=f_k+f_{k-1}&gt;a^{k-2}+a^{k-3}$$因此$P(k+1)$为真，证毕。 </2=f_3,\;></p>
<p>###拉梅定理<br>设$a$和$b$是满足$a\ge b$的正整数，则欧几里得算法为了求出$gcd(a,b)$而使用的除法的次数小于或等于$b$的十进制位数的$5$倍。<br>证: 当用欧几里得算法求满足$a\ge b$的$gcd(a,b)$时，得出下面的等式序列(其中$a=r_0$而$b=r_1$)<br>$$\begin{array}{l}<br>r_0=r_1q_1+r_2 \qquad 0\le r_2<r_1 1="f_2" \\="" r_1="r_2q_2+r_3" \qquad="" 0\le="" r_3<r_2="" \dots="" r_{n-2}="r_{n-1}q_{n-1}+r_n" r_n<r_{n-1}="" r_{n-1}="r_nq_n" \end{array}$$="" 在这里为了求出$r_n="gcd(a,b)$而使用了$n$次除法。注意商$q_1,q_2,\dots,q_{n-1}$都至少是$1$。另外，$q_n\ge" 2$，因为$r_n<r_{n-1}$。这就蕴含着="" $$\begin{array}{l}r_n\ge="" \\r_{n-1}\ge="" 2r_n\ge="" 2f_2="f_2" \\r_{n-2}\ge="" r_{n-1}+r_n\ge="" f_3+f_2="f_4" \\\dots="" r_2\ge="" r_3+r_4\ge="" f_{n-1}+f_{n-2}="f_n\\b=r_1\ge" r_2+r_3\ge="" f_n+f_{n-1}="f_{n+1}\end{array}$$" 因此得出，若欧几里得算法为了求出满足$a\ge="" b$的$gcd(a,b)$而使用了$n$次除法，则$b\ge="" f_{n+1}$从列6中知道，对$n="">2$来说$f_{n+1}&gt;a^{n-1}$，其中$a=(1+\sqrt 5)/2$。因此得出$b&gt; a^{n-1}$.另外，因为$log_{10}a~0.208&gt;1/5$。所以可以看出$$log_{10}b&gt;(n-1)log_{10}a&gt;(n-1)/5$$因此，$n-1&lt;5\cdot log_{10}b$。现在假定$b$有$k$个十进制位。则$b&lt;10^k$而且$log_{10}b&lt;k$。由此得出$n-1&lt;5k$，而且因为$k$是整数，所以得出$n\le 5k$。证毕。</r_1></p>
<h3 id="结构归纳法"><a href="#结构归纳法" class="headerlink" title="结构归纳法"></a>结构归纳法</h3><p>结构归纳法包含两个步骤:<br>基础步骤:证明对于递归定义的基础步骤所规定的属于该集合的所以元素来说，结果成立。<br>递归步骤:证明如果对于定义的递归步骤中用来构造新元素的每个元素来说命题为真，则对于这些新的元素来说结果成立。      </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h2&gt;&lt;p&gt;为了定义以非负整数集合作为其定义域的函数，使用两个步骤:&lt;br&gt;基础步骤:规定这个函数在$0$处的值。&lt;br&gt;递归步骤:给出从较小的整数处的
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 强归纳法 24</title>
    <link href="http://blog.freeabyss.com/2017/01/07/Math-DM-24-%E5%BC%BA%E5%BD%92%E7%BA%B3%E6%B3%95/"/>
    <id>http://blog.freeabyss.com/2017/01/07/Math-DM-24-强归纳法/</id>
    <published>2017-01-07T07:54:56.000Z</published>
    <updated>2017-01-09T13:36:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="强归纳法"><a href="#强归纳法" class="headerlink" title="强归纳法"></a>强归纳法</h2><p>要证明对所有正整数$n$而言，都有$P(n)$为真，其中$P(n)$为命题函数，我们要完成如下两个步骤:<br>基础步骤: 证明$P(1)$为真。<br>归纳步骤: 要证明对所有正整数$k$来说，蕴含式$[P(1)\land P(2)\land\dots\land P(k)]\rightarrow P(k+1)$</p>
<h3 id="强归纳法-or-数学归纳法"><a href="#强归纳法-or-数学归纳法" class="headerlink" title="强归纳法 or 数学归纳法"></a>强归纳法 or 数学归纳法</h3><p>一般情况下，我们应当尽量限制数学归纳法的使用。除非已经看出数学归纳法的归纳步骤证明是明显成立的。</p>
<h3 id="强归纳法示例"><a href="#强归纳法示例" class="headerlink" title="强归纳法示例"></a>强归纳法示例</h3><h4 id="算术基本定理证明"><a href="#算术基本定理证明" class="headerlink" title="算术基本定理证明"></a>算术基本定理证明</h4><p>证明:若$n$是大于$1$的整数，则$n$可以写成素数之和。<br>设$P(n)$是命题:$n$可以写成素数之积。<br>基础步骤: $P(2)$为真，因为$2$可以写成一个素数之积，即它自身。<br>归纳步骤: 假定对所有满足$j\le k$的正整数$j$来说$P(j)$为真。要完成归纳步骤就必须证明在这个假定下$P(k+1)$为真。<br>有两种情况要考虑，即$k+1$是素数和$k+1$是合数。$k+1$是素数，则立即看出$P(k+1)$为真。否则，$k+1$是合数并且可以写成满足$2\le a\le b&lt;k+1$的两个整数$a$和$b$之积。根据归纳假设，$a$和$b$都可以写成素数之积。因此，若$k+1$是合数，则它可以写成素数之积。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;强归纳法&quot;&gt;&lt;a href=&quot;#强归纳法&quot; class=&quot;headerlink&quot; title=&quot;强归纳法&quot;&gt;&lt;/a&gt;强归纳法&lt;/h2&gt;&lt;p&gt;要证明对所有正整数$n$而言，都有$P(n)$为真，其中$P(n)$为命题函数，我们要完成如下两个步骤:&lt;br&gt;基础步骤: 
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 数学归纳法 23</title>
    <link href="http://blog.freeabyss.com/2017/01/07/Math-DM-23-%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/"/>
    <id>http://blog.freeabyss.com/2017/01/07/Math-DM-23-数学归纳法/</id>
    <published>2017-01-07T01:59:39.000Z</published>
    <updated>2017-01-07T07:51:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><p>数学归纳法用来证明形如$\forall nP(n)$的一类定理，其中论域是正整数集合。<br>数学归纳法主要用于证明一个公式是否正确，而不能用于推导公式。     </p>
<h3 id="数学归纳法原理"><a href="#数学归纳法原理" class="headerlink" title="数学归纳法原理"></a>数学归纳法原理</h3><p>为证明对所有的正整数$n$，$P(n)$为真，其中$P(n)$是一个命题函数，需要完成两个步骤:<br>    基础步骤:证明命题$P(1)$为真。<br>    归纳步骤:证明对每个正整数$k$来说，蕴含式$P(k)\rightarrow P(k+1)$为真。<br>有时候需要证明对$n=b,b+1,b+2,\dots$ 来说$P(n)$为真，其中$b$是不等于$1$的整数。只要改变基础步骤，就可以用数学归纳法来完成这个证明。     </p>
<h3 id="数学归纳法证明示例"><a href="#数学归纳法证明示例" class="headerlink" title="数学归纳法证明示例"></a>数学归纳法证明示例</h3><h4 id="几何级数求和"><a href="#几何级数求和" class="headerlink" title="几何级数求和"></a>几何级数求和</h4><p>设$n$是一个非负整数，证明一下等式成立。 $$\sum_{j=0}^n ar^j=a+ar+ar^2+\dots+ar^n={ar^{n+1}-a\over r-1}, r\neq 1$$<br>基础步骤: $P(0)$为真，因为$${ar^{0+1}-a\over r-1}={ar-a\over r-1}=a$$<br>归纳步骤: 假设$P(k)$为真。 $$a+ar+ar^2+\dots+ar^k={ar^{k+1}-a\over r-1}$$<br>接着要证明$P(k+1)$为真， 将上述等式两边加上$ar^{k+1}$，得到$$a+ar+ar^2+\dots+ar^k+ar^{k+1}={ar^{k+1}-a\over r-1}+ar^{k+1}$$<br>改写等式右边: $${ar^{k+1}-a\over r-1}+ar^{k+1}={ar^{k+1}-a\over r-1}+{ar^{k+2}-ar^{k+1}\over r-1}={ar^{k+2}-a\over r-1}$$<br>于是: $$a+ar+ar^2+\dots+ar^k+ar^{k+1}={ar^{k+2}-a\over r-1}$$<br>这就证明了，如果归纳假设$P(k)$为真，则$P(k+1)$也必为真。      </p>
<h4 id="证明不等式"><a href="#证明不等式" class="headerlink" title="证明不等式"></a>证明不等式</h4><p>证明:对每个满足$n\ge 4$的正整数$n$来说，有$2^n&lt;n!$。<br>设$P(n)$是命题:$2^n&lt;n!$。<br>基础步骤: 为了证明对$n\ge 4$来说这个不等式成立，基础步骤应该是$P(4)$。$P(4)$为真，因为$2^4&lt;4!$。<br>归纳步骤: 对归纳步骤，假定$P(k)$为真，其中$k\ge 4$。接下来证明$2^{k+1}&lt;(k+1)!$为真，<br>$$\begin{array}{l}2^{k+1} &amp; =2\cdot 2^k\\ &amp;&lt; 2\cdot k!\\ &amp;&lt;(k+1)k!\\&amp;=(k+1)!\end{array}$$</p>
<h4 id="调和数的不等式"><a href="#调和数的不等式" class="headerlink" title="调和数的不等式"></a>调和数的不等式</h4><p>调和数$H_j(j=1,2,3,\dots)$的定义为 $$H_j=1+{1\over 2}+{1\over 3}+\dots + {1\over j}$$<br>证明:$$H_{2^n}\ge 1+{n\over 2}$$<br>设$P(n)$是命题 $H_{2^n}\ge 1+n/2$<br>基础步骤: $P(0)$为真，因为$H_{2^0}=H_1=1\ge 1+0/2$<br>归纳步骤: 归纳假设命题是$P(k)$为真，即$H_{2^k}\ge 1+{k\over 2}$,其中$k$是非负整数。证明$P(k+1)$也为真，即命题$H_{2^{k+1}}\ge 1+{k+1\over 2}$为真。<br>$$\begin{array}{l} H_{2^{k+1}}&amp;=1+{1\over 2}+\dots+{1\over 2^k}+{1\over 2^k+1}+\dots+{1\over 2^{k+1}}\\&amp;=H_{2^k}+{1\over 2^k+1}+\dots+{1\over 2^{k+1}}\\&amp;\ge (1+{k\over 2})+{1\over 2^k+1}+\dots+{1\over 2^{k+1}}\\&amp;\ge (1+{k\over 2}+2^k\cdot {1\over 2^{k+1}}\\ &amp;\ge (1+{k\over 2})+{1\over 2}\\&amp;=1+{k+1\over 2} \end{array}$$</p>
<h4 id="有限集合自己的个数"><a href="#有限集合自己的个数" class="headerlink" title="有限集合自己的个数"></a>有限集合自己的个数</h4><p>证明: 若$S$有$n$个元素的有限集合，其中$n$是一个非负整数，则$S$有$2^n$个子集。<br>设 $P(n)$是命题:有$n$个元素的集合有$2^n$个子集。<br>基础步骤:$P(0)$为真，因为有$0$个元素的集合，即空集，有$1$个子集，即它本身。<br>归纳步骤:假定对于所有非负整数$k$，$P(k)$为真，即假定所有$k$个元素的几个都有$2^k$个子集。必须证明在此假定下，命题$P(k+1)$为真。为此，假定$T$是一个具有$k+1$个元素的集合，于是$T$可以写成$T=S\cup \{a\}$,其中$a$是$T$中的一个元素，且$S=T-\{a\}$，因此$\mid S\mid =k$。对于$S$的每个子集$X$而言，存在$T$的两个子集，即$X$和$X\cup {a}$。这些集合构成卵$T$的所有子集，且这些子集都不相同。因为$S$有$2^k$个子集，所有$T$有$2\cdot 2^k=2^{k+1}$个子集。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数学归纳法&quot;&gt;&lt;a href=&quot;#数学归纳法&quot; class=&quot;headerlink&quot; title=&quot;数学归纳法&quot;&gt;&lt;/a&gt;数学归纳法&lt;/h2&gt;&lt;p&gt;数学归纳法用来证明形如$\forall nP(n)$的一类定理，其中论域是正整数集合。&lt;br&gt;数学归纳法主要用于证明
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 把物体放入盒子 22</title>
    <link href="http://blog.freeabyss.com/2016/12/28/Math-DM-22-%E6%8A%8A%E7%89%A9%E4%BD%93%E6%94%BE%E5%85%A5%E7%9B%92%E5%AD%90/"/>
    <id>http://blog.freeabyss.com/2016/12/28/Math-DM-22-把物体放入盒子/</id>
    <published>2016-12-28T14:11:05.000Z</published>
    <updated>2017-01-07T02:00:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="把物体放入盒子"><a href="#把物体放入盒子" class="headerlink" title="把物体放入盒子"></a>把物体放入盒子</h2><p>许多计数问题都可以通过枚举把不同的物体放入不同盒子的方式数来解决，这些被放入盒子的物体的次序是无关紧要的。<br>这些物体既可以是可辨别的，即每个都是不同的，也可以是不可辨别的，即认为每个都是相同的。可辨别的物体也称为有标号的，而不可辨别的物体则称为没有标号的。<br>类似的盒子也分为可辨别的、不可辨别的。    </p>
<h3 id="可辨别的物体与可辨别的盒子"><a href="#可辨别的物体与可辨别的盒子" class="headerlink" title="可辨别的物体与可辨别的盒子"></a>可辨别的物体与可辨别的盒子</h3><p>把$n$个不同的物体分配到$k$个不同的盒子使得$n_i$个物体放入盒子$i(i=1,2,\dots,k)$的方式数等于<br>$$n!\over n_1!n_2!\dots n_k!$$</p>
<h3 id="不可辨别的物体与可辨别的盒子"><a href="#不可辨别的物体与可辨别的盒子" class="headerlink" title="不可辨别的物体与可辨别的盒子"></a>不可辨别的物体与可辨别的盒子</h3><p>$n$个不可辨别的物体放入$k$个可辨别的盒子的方式数等价于在允许重复计数的情况下，对具有$k$个元素的集合计算$n$组合的问题。    </p>
<h3 id="可辨别的物体与不可辨别的盒子"><a href="#可辨别的物体与不可辨别的盒子" class="headerlink" title="可辨别的物体与不可辨别的盒子"></a>可辨别的物体与不可辨别的盒子</h3><p>关于计算把$n$个可辨别的物体放入$j$个不可辨别的盒子的方式数问题，我们没有一个简单可用的封闭公式。但是，却有一个相当复杂的计算公式，设$S(n,j)$表示将$n$个可辨别的物体放入$j$个不可辨别的盒子的方式数，其中不允许有空的盒子。$S(n,j)$称为第二类斯特灵数。<br>$$\sum_{j=1}^kS(n,j)=\sum_{j=1}^k{1\over j!}\sum_{i=0}^{j-1}(-1)^i\left(\begin{array}{c}j\\i\end{array}\right)(j-i)^n$$</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;把物体放入盒子&quot;&gt;&lt;a href=&quot;#把物体放入盒子&quot; class=&quot;headerlink&quot; title=&quot;把物体放入盒子&quot;&gt;&lt;/a&gt;把物体放入盒子&lt;/h2&gt;&lt;p&gt;许多计数问题都可以通过枚举把不同的物体放入不同盒子的方式数来解决，这些被放入盒子的物体的次序是无关紧
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="count" scheme="http://blog.freeabyss.com/tags/count/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 其他排列组合 21</title>
    <link href="http://blog.freeabyss.com/2016/12/27/Math-DM-21-%E9%87%8D%E5%A4%8D%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    <id>http://blog.freeabyss.com/2016/12/27/Math-DM-21-重复的排列组合/</id>
    <published>2016-12-27T13:49:58.000Z</published>
    <updated>2017-01-15T12:58:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重复的排列和组合"><a href="#重复的排列和组合" class="headerlink" title="重复的排列和组合"></a>重复的排列和组合</h2><p>具有$n$个物体的集合允许重复的$r$的排列数是$n^r$。<br>$n$个元素的集合中允许重复的$r$的组合含有$Cn+r-1,r)=C(n+r-1,n-1)$个。     </p>
<h3 id="允许和不允许重复的组合与排列"><a href="#允许和不允许重复的组合与排列" class="headerlink" title="允许和不允许重复的组合与排列"></a>允许和不允许重复的组合与排列</h3><table>
<thead>
<tr>
<th style="text-align:left">类别</th>
<th style="text-align:left">允许重复</th>
<th style="text-align:left">公式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$r$排列</td>
<td style="text-align:left">不</td>
<td style="text-align:left">$n!\over (n-r)!$</td>
</tr>
<tr>
<td style="text-align:left">$r$组合</td>
<td style="text-align:left">不</td>
<td style="text-align:left">$n!\over r!(n-r)!$</td>
</tr>
<tr>
<td style="text-align:left">$r$排列</td>
<td style="text-align:left">是</td>
<td style="text-align:left">$n^r$</td>
</tr>
<tr>
<td style="text-align:left">$r$组合</td>
<td style="text-align:left">是</td>
<td style="text-align:left">$(n+r-1)!\over r!(n-1)!$</td>
</tr>
</tbody>
</table>
<h2 id="多重排列"><a href="#多重排列" class="headerlink" title="多重排列"></a>多重排列</h2><p>设类型1的相同物体有$n_1$个，类型2的相同物体有$n_2$个，$\dots$，类型$k$的相同物体有$n_k$个，那么$n$个物体的不同排列数是$$n!\over n_1!n_2!\dots n_k!$$</p>
<p>证: 为确定排列数，首先注意到可以用$C(n,n_1)$种方式在$n$个位置中放类型1的$n_1$个物体，剩下$n-n_1$个空位。然后用$C(n-n_1,n_2)$种方式放类型2的物体，剩下$n-n_1-n_2$个空位。继续放类型3的物体，$\dots$，类型$k-1$的物体，直到最后可用$C(n-n_1-n_2-\dots -n_{k-1},n_k)$种方式放类型$k$的物体。因此由乘积法则，不同排列的总数是<br>$$\begin{array}{l}<br>C(n,n_1)C(n-n_1,n_2)\dots(n-n_1-\dots -n_{k-1},n_k) \\<br>={n!\over n_1!(n-n_1)!}{(n-n_1)!\over n_2!(n-n_1-n_2)!}\dots{(n-n_1-\dots -n_{k-1})!\over n_k!0!} \\<br>={n!\over n_1!n_2!\dots n_k!}<br>\end{array}$$</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>重新排序单词SUCCESS中的字母能构成多少个不同的串?<br>因为SUCCESS中的某些字母是重复的，答案并不是$7$个字母的排列数。这个单词包含$3$个S、$2$个、$1$个U和$1$个E。为确定重新排列单词中的字母能构成多少个不同的串，首先，注意到$3$个S可以用$C(7,3)$种不同的方式放在$7$个位置中，剩下$4$个空位i。然后可以用$C(4,2)$种方式放$2$个C，留下2个空位。又可以用$C(2,1)$种方式放U，留下$1$个空位。因此放E只有$C(1,1)$种方式。从而，由乘积法则，产生不同的串数是<br>$$\begin{array}{l}C(7,3)C(4,2)C(2,1)C(1,1)&amp;={7!\over 3!4!}\cdot{4!\over 2!2!}\cdot{2!\over 1!1!}\cdot{1!\over 1!0!}\\<br>&amp;={7!\over 3!2!1!1!}\\<br>&amp;=420\end{array}$$</p>
<p>换个思路，我们可以将$SUCCESS$的看成是$S_1S_2S_3U_1C_1C_2E_1$，然后再除以每个字母的冗余度。$S_1S_2S_3$共有$3!$种排列方式，$U_1$共有$1!$种排列方式，$C_1C_2$共有$2!$种排列方式，$E_1$共有$1!$种排列方式，因此SUCCESS产生的排列数是${7!\over 3!2!1!1!}$</p>
<h2 id="其他排列"><a href="#其他排列" class="headerlink" title="其他排列"></a>其他排列</h2><h3 id="字母不可相邻"><a href="#字母不可相邻" class="headerlink" title="字母不可相邻"></a>字母不可相邻</h3><p>从26个字母中选取4个不同的字母，且b、d不能相邻。<br>首先，找出b,d相邻有多少排列数。 其中bd已确定，需要从剩下24个字母中选取2个与bd进行排列，共有$C(24，2)\times 3!$种方式，又因为b、d有bd,db两种相邻方式，因此b、d相邻共有$C(24,2)\times 3!\times 2$种方式。<br>因此，不包含b、d相邻的排列数有$P(26,4)-C(24,2)\times 3!\times 2$</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;重复的排列和组合&quot;&gt;&lt;a href=&quot;#重复的排列和组合&quot; class=&quot;headerlink&quot; title=&quot;重复的排列和组合&quot;&gt;&lt;/a&gt;重复的排列和组合&lt;/h2&gt;&lt;p&gt;具有$n$个物体的集合允许重复的$r$的排列数是$n^r$。&lt;br&gt;$n$个元素的集合中允许
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="count" scheme="http://blog.freeabyss.com/tags/count/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 二项式系数 20</title>
    <link href="http://blog.freeabyss.com/2016/12/26/Math-DM-20-%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0/"/>
    <id>http://blog.freeabyss.com/2016/12/26/Math-DM-20-二项式系数/</id>
    <published>2016-12-26T14:08:38.000Z</published>
    <updated>2017-01-15T12:17:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h2><p>设$x$和$y$是变量，$n$是非负整数，那么$$(x+y)^n=\sum_{j=0}^n\left(\begin{array}{c}n \\r\end{array}\right)x^{n-1}y^i$$</p>
<p>设$n$为非负整数，那么$$\sum_{k=0}^n\left(\begin{array}{c}n \\k\end{array}\right)=2^n$$<br>证明:<br>$$<br>2^n=(1+1)^n =\sum_{k=0}^n\left(\begin{array}{c}n\\k\end{array}\right)1^k1^{n-k}= \sum_{k=0}^n\left(\begin{array}{c}n \\k\end{array}\right)<br>$$</p>
<p>设$n$是正整数，那么 $$\sum_{k=0}^n\left(\begin{array}{c}n\\k\end{array}\right)(-1)^k=0$$</p>
<p>设$n$是非负整数，那么 $$\sum_{k=0}^n\left(\begin{array}{c}n\\k\end{array}\right)2^k=3^n$$</p>
<h2 id="恒等式"><a href="#恒等式" class="headerlink" title="恒等式"></a>恒等式</h2><h3 id="帕斯卡恒等式"><a href="#帕斯卡恒等式" class="headerlink" title="帕斯卡恒等式"></a>帕斯卡恒等式</h3><p>设$n$和$k$是满足$n\ge k$的正整数，那么有 $$\left(\begin{array}{c}n+1\\k\end{array}\right)=\left(\begin{array}{c}n\\k-1\end{array}\right)=\left(\begin{array}{c}n\\k\end{array}\right)$$<br>证:假定$T$是包含$n+1$个元素的集合。令$a$是$T$的一个元素且$S=T-\{a\}$。注意到$T$包含$k$个元素的子集有$\left(\begin{array}{c}n+1\\k\end{array}\right)$个。然而$T$的含$k$个元素的子集或者包含$a$和$S$中的$k-1$个元素，或者不包含$a$但包含$S$中的$k$个元素。由于$S$的$k-1$元子集有$\left(\begin{array}{c}n\\k-1\end{array}\right)$个，故$T$含$a$在内的$k$元子集有$\left(\begin{array}{c}n\\k-1\end{array}\right)$个。由由于$S$的$k$元子集有$\left(\begin{array}{c}n\\k\end{array}\right)$个。故$T$的不含$a$的$k$元子集有$\left(\begin{array}{c}n\\k\end{array}\right)$个。从而得到$$\left(\begin{array}{c}n+1\\k\end{array}\right)=\left(\begin{array}{c}n\\k-1\end{array}\right)=\left(\begin{array}{c}n\\k\end{array}\right)$$</p>
<h3 id="范德蒙德恒等式"><a href="#范德蒙德恒等式" class="headerlink" title="范德蒙德恒等式"></a>范德蒙德恒等式</h3><p>设$n、m、r$是非负整数，其中$r$不超过$m$或$n$，那么<br>$$\left(\begin{array}{c}n+m\\r\end{array}\right)=\sum_{k=0}^r\left(\begin{array}{c}m\\r-k\end{array}\right)\left(\begin{array}{c}n\\k\end{array}\right)$$</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>可以将公式等价于从$n$个红球，$m$个蓝球中选取$r$个球的问题。<br>首先，选取$0$个红球，$m$个蓝球，共有$\left(\begin{array}{c}n\\0\end{array}\right)\left(\begin{array}{c}m\\r\end{array}\right)$种方式。<br>选取$1$个红球，$m-1$个蓝球，共有$\left(\begin{array}{c}n\\1\end{array}\right)\left(\begin{array}{c}m\\r-1\end{array}\right)$种方式。<br>$\begin{array}{l}\dots \end{array}$<br>选取$r$个红球，$0$个蓝球共有$\left(\begin{array}{c}n\\r\end{array}\right)\left(\begin{array}{c}m\\0\end{array}\right)$种方式。<br>将以上$r$种方式相加得出 $$\left(\begin{array}{c}n+m\\r\end{array}\right)=\sum_{k=0}^r\left(\begin{array}{c}m\\r-k\end{array}\right)\left(\begin{array}{c}n\\k\end{array}\right)$$</p>
<h4 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h4><p>如果$n$是非负整数，那么$$\left(\begin{array}{c}2n\\n\end{array}\right)=\sum_{k=0}^n\left(\begin{array}{c}n\\k\end{array}\right)^2$$<br>证: 在范德蒙德恒等式中令$m=r=n$得到$$\left(\begin{array}{c}2n\\n\end{array}\right)=\sum_{k=0}^n\left(\begin{array}{c}n\\n-k\end{array}\right)\left(\begin{array}{c}n\\k\end{array}\right)=\sum_{k=0}^n\left(\begin{array}{c}n\\k\end{array}\right)^2$$</p>
<p>设$n$和$r$是非负整数，$r\le n$那么$$\left(\begin{array}{c}n+1\\r+1\end{array}\right)=\sum_{j=r}^n\left(\begin{array}{c}j\\r\end{array}\right)$$</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二项式定理&quot;&gt;&lt;a href=&quot;#二项式定理&quot; class=&quot;headerlink&quot; title=&quot;二项式定理&quot;&gt;&lt;/a&gt;二项式定理&lt;/h2&gt;&lt;p&gt;设$x$和$y$是变量，$n$是非负整数，那么$$(x+y)^n=\sum_{j=0}^n\left(\begin{
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="count" scheme="http://blog.freeabyss.com/tags/count/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 排列和组合 19</title>
    <link href="http://blog.freeabyss.com/2016/12/26/Math-DM-19-%E6%8E%92%E5%88%97%E5%92%8C%E7%BB%84%E5%90%88/"/>
    <id>http://blog.freeabyss.com/2016/12/26/Math-DM-19-排列和组合/</id>
    <published>2016-12-26T13:01:43.000Z</published>
    <updated>2017-01-15T12:27:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><p>集合中不同元素的排列，是对这些元素一种有序的安排。我们也对集合中某些元素的有序安排感兴趣。对一个集合中$r$个元素的有序安排称为一个$r$排列。<br>一个$n$元集的$r$排列数记为$P(n,r)$。我们可以使用乘积法则求出$P(n,r)$。<br>具有$n$个不同元素的集合的$r$排列数是 $$P(n,r)=n(n-1)(n-2)\dots(n-r+1)$$</p>
<blockquote>
<p>只要是$n$非负，就有$P(n,0)=1$。      </p>
</blockquote>
<p>如果$n$和$r$都是整数，且$0\le r\le n$，则$$P(n,r)={n!\over (n-r)!}$$</p>
<h3 id="圆排列"><a href="#圆排列" class="headerlink" title="圆排列"></a>圆排列</h3><p>将圆排列展开就是线排列。$r$个元素进行排列，就有$r$种展开方式，因此，圆排列共有 $$P(n,r)/r={n!\over r(n-r)!}$$</p>
<h3 id="项链排列"><a href="#项链排列" class="headerlink" title="项链排列"></a>项链排列</h3><p>项链排列在圆排列的基础上，正面向上和反面向上两种方式放置各个数是同一个排列，因此项链排列等于$$P(n,r)/2r={n!\over 2r(n-r)!} \qquad 3\ge r\le n$$</p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>集合元素的$r$组合是从这个集合无序选取的$r$个元素。简单地说，一个$r$组合是这个集合的一个$r$个元素的子集。<br>具有$n$个不同元素集合的$r$组合记为$C(n,r)$。也记作$\left(\begin{array}{c}n \\r\end{array}\right)$并且称为二项式系数。<br>设$n$是正整数，$r$是满足$0\le r\le n$的整数，$n$元素的集合的$r$组合数等于$$C(n,r)={n!\over r!(n-r)!}$$<br>证 可以如下得到这个集合的$r$排列。先构成集合的$C(n,r)$个$r$组合，然后以$P(n,r)$种方式排序每个$r$组合中的元素，这可以用$P(r,r)$种方式来做。因此$$P(n,r)=C(n,r)*P(r,r)$$这就推出$$C(n,r)={P(n,r)\over P(r,r)}={n!/(n-r)!\over r!/(r-r)!}={n!\over r!(n-r)!}$$</p>
<p>设$n,r$是满足$n\le r$的非负整数，那么$C(n,r)=C(n,n-r)$。      </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排列&quot;&gt;&lt;a href=&quot;#排列&quot; class=&quot;headerlink&quot; title=&quot;排列&quot;&gt;&lt;/a&gt;排列&lt;/h2&gt;&lt;p&gt;集合中不同元素的排列，是对这些元素一种有序的安排。我们也对集合中某些元素的有序安排感兴趣。对一个集合中$r$个元素的有序安排称为一个$r$排
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="count" scheme="http://blog.freeabyss.com/tags/count/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 鸽巢原理 18</title>
    <link href="http://blog.freeabyss.com/2016/12/25/Math-DM-18-%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.freeabyss.com/2016/12/25/Math-DM-18-鸽巢原理/</id>
    <published>2016-12-25T13:49:15.000Z</published>
    <updated>2016-12-26T12:28:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="鸽巢原理"><a href="#鸽巢原理" class="headerlink" title="鸽巢原理"></a>鸽巢原理</h2><p>如果$k+1$个或更多的物体放入$k$个盒子，那么至少有一个盒子包含了$2$个或更多的物体。    </p>
<blockquote>
<p>证:假定$k$个盒子中没有一个盒子包含的物体多于$1$个，那么物体总数至多是$k$，这与至少有$k+1$个物体矛盾。    </p>
</blockquote>
<h2 id="广义鸽巢原理"><a href="#广义鸽巢原理" class="headerlink" title="广义鸽巢原理"></a>广义鸽巢原理</h2><p>如果$N$个物体放入$k$个盒子，那么至少有一个盒子包含了至少$\lceil N/k\rceil$个物体。   </p>
<blockquote>
<p>证:假定没有盒子包含比$\lceil N/k \rceil-1$多的物体，那么物体总数至多是 $$k(\lceil{N\over k}\rceil -1)&lt;k(({N\over k}+1)-1)=N$$ 这里用到不等式$\rceil N/k\rceil &lt;(N/k)+1$。这与存在有总数$N$个物体矛盾。  </p>
</blockquote>
<p>一类普遍的问题是，把一些物体分到$k$个盒子中要使某个盒子至少含有$r$个物体，求这些物体的最少个数。当有$N$个物体时，广义鸽巢原理告诉我们，只要$\lceil N/k\rceil\ge r$一定有$r$个物体在同一个盒子里。满足$N/k&gt;r-1$的最小正整数，即$N=k(r-1)+1$。</p>
<h3 id="鸽巢原理的巧妙应用"><a href="#鸽巢原理的巧妙应用" class="headerlink" title="鸽巢原理的巧妙应用"></a>鸽巢原理的巧妙应用</h3><p>在30天的一个月里，某棒球队一天至少打一场比赛，但至多打45场。证明一定有连续若干天内这个队恰好打了14场。<br>令$a_j$是在这个月的第$j$天或第$j$天之前所打的场数，则$a_1,a_2,\dots,a_30$是不同正整数的一个递增序列，其中$1\le a_j\le 45$。从而$a_1+14,a_2+14,\dots,a_30+14$也是不同正整数的一个递增序列，其中$15\le a_j+15\le 59$。<br>$60$个正整数$a_1,a_2,\dots,a_30,a_1+14,a_2+14,\dots,a_30+14$全部小于等于$59$.因此，由鸽巢原理有两个正整数相等。因此整数$a_j j=1,2,\dots,30$都不相同，并且$a_j+14,j=1,2,dots,30$也不相同，一定存在下标$i,j$满足$a_i=a_j+14$。这意味着从第$j+1$天到第$i$天恰好打了14场比赛。     </p>
<p>每个由$n^2+1$个不同实数构成的序列都包含一个长为$n+1$的严格递增子序列或严格递减子序列。     </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;鸽巢原理&quot;&gt;&lt;a href=&quot;#鸽巢原理&quot; class=&quot;headerlink&quot; title=&quot;鸽巢原理&quot;&gt;&lt;/a&gt;鸽巢原理&lt;/h2&gt;&lt;p&gt;如果$k+1$个或更多的物体放入$k$个盒子，那么至少有一个盒子包含了$2$个或更多的物体。    &lt;/p&gt;
&lt;blockq
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="count" scheme="http://blog.freeabyss.com/tags/count/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 计数基础 17</title>
    <link href="http://blog.freeabyss.com/2016/12/25/Math-DM-17-%E8%AE%A1%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.freeabyss.com/2016/12/25/Math-DM-17-计数基础/</id>
    <published>2016-12-25T12:07:33.000Z</published>
    <updated>2016-12-25T13:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>组合数学是研究个体安排的学科，枚举具有确定性质的个体的个数，是组合数学的一个重要的部分。组合数学的另一个问题涉及生成某个特定类型的所有排列。    </p>
<h2 id="基本的计数原则"><a href="#基本的计数原则" class="headerlink" title="基本的计数原则"></a>基本的计数原则</h2><h3 id="乘积法则"><a href="#乘积法则" class="headerlink" title="乘积法则"></a>乘积法则</h3><p>当一个过程由独立的任务组成时使用乘法法则。<br>假定一个过程可以被分解成两个任务。如果完成第一个任务有$n_1$中方式，在第一个任务完成之后有$n_2$种方式完成第二个任务，那么完成这个过程有$n_1n_2$种方式。   </p>
<h4 id="推广的乘积法则"><a href="#推广的乘积法则" class="headerlink" title="推广的乘积法则"></a>推广的乘积法则</h4><p>假定一个过程由执行任务$T_1,T_2,\dots ,T_m$来完成。如果在完成任务之后用$n_i$种方式来完成$T_i$，那么完成这个过程有$n_1\cdot n_2\cdot\dots\cdot n_m$种方式。  </p>
<h4 id="乘积法则集合语言表达"><a href="#乘积法则集合语言表达" class="headerlink" title="乘积法则集合语言表达"></a>乘积法则集合语言表达</h4><p>如果$\mathbf {A_1, A_2,\dots,A_m}$是有穷集，那么存在这些集合的笛卡尔积中的元素数是每个集合的元素数之积。为把这种表述与乘积法则联系起来，注意到在笛卡尔积$\mathbf {A_1\times A_2\times\dots\times A_m}$中选一个元素的任务是通过在$\mathbf {A_1}$中选一个元素，$\mathbf {A_2}$中选一个元素$\dots $ 。由乘积法则得到$$\mid\mathbf {A_1\times A_2\times\dots\times A_m \mid= \mid A_1\mid\cdot\mid A_2\mid\cdot\dots\cdot\mid A_m\mid}$$</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>例如:用一个字母和一个不超过$100$的正整数给礼堂的座位编号。那么不同编号的座位最多有多少?<br>解: 给一个座位编号的过程由两个任务组成，即从$26$个字母中先选择一个字母分配给这个座位，然后再从$100$个正整数中选择一个整数分配给它。乘积法则表明一个座位可以有$26\cdot 100=2600$种不同的编号方式。     </p>
<h5 id="计数函数"><a href="#计数函数" class="headerlink" title="计数函数"></a>计数函数</h5><p>从一个$n$元集到一个$m$元集存在多少个函数?<br>解: 一个函数对于定义域中$m$个元素中的每个元素都要选择陪域中$n$个元素中的一个元素来对应。因此，由乘积法则存在$n\cdot n\cdot\dots\cdot n=n^m$个从$m$元集到$n元集再的函数。</p>
<h5 id="计数一对一函数"><a href="#计数一对一函数" class="headerlink" title="计数一对一函数"></a>计数一对一函数</h5><p>从一个$m$元集到一个$n$元集存在多少个一对一函数?<br>解: 首先注意到当$m&gt;n$时没有从$m$元集到$n$元集的一对一函数。现在令$m\le n$。假设定义域中的元素是$a_1,a_2,\dots ,a_m$。有$n$种方式选择函数在$a_1$的值。因为函数是一对一的，可以有$n-1$种方式选择函数在$a_2$的值。由乘积法则，从一个$m$元集到一个$n$元集存在着$n(n-1)(n-2)\dots(n-m+1)$个一对一函数。   </p>
<h5 id="计数有穷集的子集"><a href="#计数有穷集的子集" class="headerlink" title="计数有穷集的子集"></a>计数有穷集的子集</h5><p>用乘积法则证明一个有穷集$\mathbf S$的不同子集数是$2^{\mid s\mid}$。<br>设$\mathbf S$是有穷集。按任意的顺序将$\mathbf S$的元素列成一个表，考虑到$\mathbf S$的子集和长为$\mid \mathbf S\mid$的二进制串之间存在一对一的对应，即如果表的第$i$个元素在这个子集里，则该子集对应的二进制串的第$i$位为$1$，否则为$0$。又乘积法则，存在着$2^{\mid S\mid}$个长为$\mid S\mid$的二进制串。因此$\mid P(S)\mid=2^{\mid S\mid}$。    </p>
<h3 id="求和法则"><a href="#求和法则" class="headerlink" title="求和法则"></a>求和法则</h3><p>如果完成第一项任务有$n_1$种方式，完成第二项任务有$n_2$种方式，并且这些任务不能同时完成，那么完成第一或第二项任务有$n_1+n_2$种方式。    </p>
<h4 id="求和法则的集合表达"><a href="#求和法则的集合表达" class="headerlink" title="求和法则的集合表达"></a>求和法则的集合表达</h4><p>如果$\mathbf {A_1, A_2,\dots,A_m}$是不交的集合，那么在其并集中的元素数是每个集合的元素数之和。为把这种表述与求和法则联系起来，令$\mathbf T_i$是从$\mathbf A_i(i=1,2,\dots,m)$中选取一个元素的任务。有$\mid A_i\mid$种方式做$\mathbf T_i$。由于任何两个任务不可能同时做，根据求和法则，从其中某个集合选择一个元素的方式数，即在并集中的元素数是$$\mid \mathbf {A_1\cup A_2\cup\dots\cup A_m\mid=\mid A_1\mid+\mid A_2\mid+\dots+\mid A_m\mid}$$</p>
<h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>当同时做两个任务时，我们不能使用求和法则来计数完成其中一个任务的方式。为了正确的计数完成其中一个任务的方式，我们先把完成每个任务的方式数加起来，然后再减去同时完成两个任务的方式数。这个技术叫做容斥原理。     </p>
<h4 id="集合表述"><a href="#集合表述" class="headerlink" title="集合表述"></a>集合表述</h4><p>令$\mathbf {A_1}$和$\mathbf {A_2}$是集合，$T_1$是从$A_1$选择一个元素的任务，$T_2$是从$A_2$选择一个元素的任务。完成$T_1$有$\mid A_1\mid$种方式，完成$T_2$有$\mid A_2\mid$种方式。完成$T_1$或$T_2$的方式数是完成$T_1$的方式数与完成$T_2$的方式数之和减去同时完成$T_1、T_2$两个任务的方式数。因为存在$\mid\mathbf {A_1\cup A_2\mid}$种方式完成$T_1$或$T_2$，$\mid A_1\cap A_2\mid$种方式完成$T_1$和$T_2$，我们有$$\mid\mathbf {A_1\cup A_2\mid=\mid A_1\mid+\mid A_2\mid-\mid A_1\cap A_2\mid }$$</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;组合数学是研究个体安排的学科，枚举具有确定性质的个体的个数，是组合数学的一个重要的部分。组合数学的另一个问题涉及生成某个特定类型的所有排列。
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="count" scheme="http://blog.freeabyss.com/tags/count/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 数论应用 16</title>
    <link href="http://blog.freeabyss.com/2016/12/24/Math-DM-16-%E6%95%B0%E8%AE%BA%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.freeabyss.com/2016/12/24/Math-DM-16-数论应用/</id>
    <published>2016-12-24T08:43:40.000Z</published>
    <updated>2016-12-25T06:31:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些有用的结果"><a href="#一些有用的结果" class="headerlink" title="一些有用的结果"></a>一些有用的结果</h2><p>若$a$和$b$为正整数，则存在整数$s$和$t$，使$gcd(a, b)=sa+tb$。<br>通过以上定理，可以推导出以下结果:<br>如果$a,b,c$为正整数，使得$gcd(a,b)=1$且$a\mid bc$，那么$a\mid c$。     </p>
<blockquote>
<p>证明:由于$gcd(a,b)=1$，根据上面的定理可知有整数$s ,t $使得，$$sa+tb=1$$用$c$乘以等式两边，得$$sac+tbc=c$$ 由于$a\mid tbc$，且$a\mid sac$，因此$a\mid sac+tbc$，从而$a\mid c$。     </p>
</blockquote>
<p>如果$p$是素数，且$p\mid a_1a_2\dots a_n$，其中$a_i$为整数，则对于某个$i$，$p\mid a_i$。<br>令$m$为正整数，$a,b,c$为整数。如果$ac\equiv bc\pmod m$，且$gcd(c,m)=1$，那么$a\equiv b\pmod m$</p>
<h3 id="证明正整数的素因子分解的唯一性"><a href="#证明正整数的素因子分解的唯一性" class="headerlink" title="证明正整数的素因子分解的唯一性"></a>证明正整数的素因子分解的唯一性</h3><p>假定正整数$n$能用两种方式写成素数的乘积，比如$n=p_1p_2\dots p_s$和$n=q_1q_2\dots q_t$，其中$p_i,q_j$都是素数，而且$p_1\le p_2\le \dots\le p_s$和$q_1\le q_2\le \dots\le q_t$，现在从两个分解式中去掉共有的素数，得$$p_{i_1}p_{i_2}\dots p_{i_u}=q_{j_1}q_{j_2}\dots q_{j_v}$$其中任何素数都不同时出现在等式两边，而$u,v$为正整数。由上面的定理可知，存在某个$k$使得$p_{i_1}$整除$q_{j_k}$。由于任何素数都不能整除另一个素数，搜以不可能有这样的$q_{j_k}$。这说明$n$至多有一种非递减序分解为素数的方式。     </p>
<h3 id="线性同余"><a href="#线性同余" class="headerlink" title="线性同余"></a>线性同余</h3><p>形如$ax\equiv b\pmod m$的同余式称为线性同余。其中$m$为正整数，$a$和$b$为整数，$x$为变量。<br>如果$a\overline a\equiv 1\pmod m$的整数$\overline a$存在的话，这样的$\overline a$称为$a$的模$m$逆。<br>如果$a$和$m$为互素的整数，$m&gt;1$，则存在$a$的模$m$的逆。而且这个逆模$m$是唯一的。(即有小于$m$的唯一正整数$\overline a$，它是$a$模$m$的逆，且$a$的任何别的模$m$逆均和$\overline a$模$m$同余)      </p>
<blockquote>
<p>证明: 由于$gcd(a,m)=1$，有整数$s,t$使得，$$sa+tm=1$$于是$$sa+tm\equiv 1\pmod m$$由于$tm\equiv 0\pmod m$，所以$$sa\equiv 1\pmod m$$结论是$s$为$a$的模$m$逆。     </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一些有用的结果&quot;&gt;&lt;a href=&quot;#一些有用的结果&quot; class=&quot;headerlink&quot; title=&quot;一些有用的结果&quot;&gt;&lt;/a&gt;一些有用的结果&lt;/h2&gt;&lt;p&gt;若$a$和$b$为正整数，则存在整数$s$和$t$，使$gcd(a, b)=sa+tb$。&lt;br&gt;通
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="Number Theory" scheme="http://blog.freeabyss.com/tags/Number-Theory/"/>
    
  </entry>
  
  <entry>
    <title>二进制运算</title>
    <link href="http://blog.freeabyss.com/2016/12/22/Function-05-%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97/"/>
    <id>http://blog.freeabyss.com/2016/12/22/Function-05-二进制运算/</id>
    <published>2016-12-22T14:52:26.000Z</published>
    <updated>2016-12-24T09:58:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整数相加"><a href="#整数相加" class="headerlink" title="整数相加"></a>整数相加</h2><p>$$<br>\begin{array}{l}<br>\mathbf {procedure} \; \mathcal {add} (a, b:integer)\\<br>\{a和b的二进制展开分别是(a_{n-1}a_{n-2}\dots a_1a_0)_2和(b_{n-1}b_{n-2}\dots b_1b_0)_2\} \\<br>c:= 0  \\<br>\mathbf {for}\; j:=0 \;\mathbf {to}\; n-1 \\<br>\mathbf {begin} \\<br>\qquad d:=\lfloor (a_j+b_j+c)/2\rfloor \\<br>\qquad s_j:=a_j+b_j+c-2d \\<br>\qquad c:=d \\<br>\mathbf {end}  \\<br>s_n := c \\<br>\{和数的二进制展开是(s_ns_{n-1}\dots s_0)_2\}<br>\end{array}<br>$$</p>
<h2 id="整数相乘"><a href="#整数相乘" class="headerlink" title="整数相乘"></a>整数相乘</h2><p>$$<br>\begin{array}{l}<br>\mathbf {procedure} \;\mathcal {multiply} (a, b:integer)\\<br>\{a和b的二进制展开分别是(a_{n-1}a_{n-2}\dots a_1a_0)_2和(b_{n-1}b_{n-2}\dots b_1b_0)_2\} \\<br>\mathbf {for}\; j:=0 \;\mathbf {to}\; n-1 \\<br>\mathbf {begin} \\<br>\qquad \mathbf {if}\; b_j=1\;\mathbf {then}\; c_j:=a\;shifted\; j places \\<br>\qquad \mathbf{else}\; c_j:=0\\<br>\mathbf {end} \\<br>\{c_0,c_1,\dots,c_{n-1}是部分乘积\} \\<br>p:=0\\<br>\mathbf {for}\; j:=0\;\mathbf {to}\; n-1 \\<br>\qquad p:=p+c_j \\<br>\{p是ab的值\}<br>\end{array}<br>$$</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;整数相加&quot;&gt;&lt;a href=&quot;#整数相加&quot; class=&quot;headerlink&quot; title=&quot;整数相加&quot;&gt;&lt;/a&gt;整数相加&lt;/h2&gt;&lt;p&gt;$$&lt;br&gt;\begin{array}{l}&lt;br&gt;\mathbf {procedure} \; \mathcal {add
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="function" scheme="http://blog.freeabyss.com/tags/function/"/>
    
      <category term="Alg" scheme="http://blog.freeabyss.com/tags/Alg/"/>
    
  </entry>
  
  <entry>
    <title>离散数学学习笔记 整数和算法 15</title>
    <link href="http://blog.freeabyss.com/2016/12/22/Math-DM-15-%E6%95%B4%E6%95%B0%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.freeabyss.com/2016/12/22/Math-DM-15-整数和算法/</id>
    <published>2016-12-22T14:14:51.000Z</published>
    <updated>2016-12-24T08:42:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><p>令$b$为不等于$1$的正整数，那么如果$n$是个正整数，就可以唯一地表示为下面的形式：<br>$$n = a_kb^k+a_{k-1}b^{k-1}+\cdots +a_1b+a_0$$<br>其中$k$是非负整数，$a_0,a_1,\cdots,a_k$是小于$b$的非负整数，$a_k\neq 0$。该形式被称为$n$的$b$进制展开。</p>
<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>现在介绍一个构造整数$n$的$b$进制展开的算法。首先，用$b$除$n$得到商和余数，即 $$n=bq_0+a_0, 0\le a_0&lt;b$$余数$a_0$就是$n$的$b$进制展开的最右边一位数字。下一步用$b$除$q_0$，得$$q_0=bq_1+a_1， 0\le a_1&lt;b$$可以看出$a_1$是$n$进制展开中从右边数的第二个数字。重复该过程，直到商为$0$时为止。下面给出伪代码。<br>$$<br>\begin{array}{l}<br>\mathbf {procedure} \; \mathcal {base\;b\;expansion} (n:integer)\\<br>q:=n \\<br>k:=0 \\<br>\mathbf {while}(q\neq 0) \\<br>\mathbf {begin} \\<br>\qquad a_k:=q\;\mathbf{mod}\;b \\<br>\qquad q:=\lfloor q/b\rfloor \\<br>\qquad k:=k+1 \\<br>\mathbf {end}<br>\{n的b进制展开是(a_{k-1}\dots a_1a_0)\}<br>\end{array}<br>$$</p>
<h3 id="二进制算法"><a href="#二进制算法" class="headerlink" title="二进制算法"></a>二进制算法</h3><h4 id="整数相加"><a href="#整数相加" class="headerlink" title="整数相加"></a>整数相加</h4><p>$$\begin{array}{l}<br>\mathbf {procedure} \; \mathcal {add} (a, b:integer)\\<br>\{a和b的二进制展开分别是(a_{n-1}a_{n-2}\dots a_1a_0)_2和(b_{n-1}b_{n-2}\dots b_1b_0)_2\} \\<br>c:= 0  \\<br>\mathbf {for}\; j:=0 \;\mathbf {to}\; n-1 \\<br>\mathbf {begin} \\<br>\qquad d:=\lfloor (a_j+b_j+c)/2\rfloor \\<br>\qquad s_j:=a_j+b_j+c-2d \\<br>\qquad c:=d \\<br>\mathbf {end}  \\<br>s_n := c \\<br>\{和数的二进制展开是(s_ns_{n-1}\dots s_0)_2\}<br>\end{array}$$</p>
<h4 id="整数相乘"><a href="#整数相乘" class="headerlink" title="整数相乘"></a>整数相乘</h4><p>$$\begin{array}{l}<br>\mathbf {procedure} \; \mathcal {multiply} (a, b:integer)\\<br>\{a和b的二进制展开分别是(a_{n-1}a_{n-2}\dots a_1a_0)_2和(b_{n-1}b_{n-2}\dots b_1b_0)_2\} \\<br>\mathbf {for}\; j:=0 \;\mathbf {to}\; n-1 \\<br>\mathbf {begin} \\<br>\qquad \mathbf {if}\; b_j=1\;\mathbf {then}\; c_j:=a\; shifted\; j\; places \\<br>\qquad \mathbf{else}\; c_j:=0\\<br>\mathbf {end} \\<br>\{c_0,c_1,\dots,c_{n-1}是部分乘积\} \\<br>p:=0\\<br>\mathbf {for}\; j:=0\;\mathbf {to}\; n-1 \\<br>\qquad p:=p+c_j \\<br>\{p是ab的值\}<br>\end{array}$$</p>
<blockquote>
<p>$a\;shifted\; j\; places$左移$j$位    </p>
</blockquote>
<h3 id="同余幂"><a href="#同余幂" class="headerlink" title="同余幂"></a>同余幂</h3><p>在密码学中重要的是能有效得求$b^n\;\mathbf{mod}\;m$，其中$b,n,m$都是大整数。先计算$b^n$，再求$b^n$除以$m$的余数，这是不行的，因为$b^n$是非常大的数。可行的是一种利用指数$n$的二进制展开的算法。<br>该算法的基本思想是利用以下公式:<br>$$b^n=b^{a_{k-1}\cdot 2^{k-1}+\dots +a_1\cdot 2+a_0}=b^{a_{k-1}\cdot 2^{k-1}}\dots b^{a_1\cdot 2}\cdot b^a_0$$<br>为了计算$b^n$的值，我们要找到<br>$b,b^2,{(b^2)}^2=b^4,{(b^4)}^2=b^8,\dots ,b^{2^k}$的值，把其中$a_j=1$的那些项$b^{2^j}$乘起来，就得到了$b^n$的值。<br>这个算法依次求$b\;\mathbf{mod}\; m, b^2\;\mathbf{mod}\; m, b^4\;\mathbf{mod}\; m,\dots ,b^{2^{k-1}}\;\mathbf{mod}\; m$，把其中$a_j =1$的项$b^{2^j}\;\mathbf{mod}\; m$乘起来，在每次乘法后求乘积除以$m$的余数。伪代码示例:  </p>
<p>$$\begin{array}{l}<br>\mathbf {procedure} \; \mathcal {modular\; exponentiation} (n,m,b:integer)\\<br>\{n的二进制展开是(a_{n-1}a_{n-2}\dots a_1a_0)_2\} \\<br>x:=1 \\<br>power := b\;\mathbf{mod}\; m\\<br>\mathbf {for}\; i:=0 \;\mathbf {to}\; k-1 \\<br>\mathbf {begin} \\<br>\qquad\mathbf{if}\; a_i=1\;\mathbf{then}\; x:=(x\cdot power)\;\mathbf{mod}\; m\\power := (power\cdot power)\;\mathbf{mod}\; m \\<br>\mathbf {end} \\<br>\{x等于b^n\;\mathbf{mod}\; m\} \\<br>\end{array}$$<br>该算法的效率为$O((log\,m)^2\,log\, n)$次位运算就能求得$b^n\;\mathbf{mod}\; m$。   </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;整数表示&quot;&gt;&lt;a href=&quot;#整数表示&quot; class=&quot;headerlink&quot; title=&quot;整数表示&quot;&gt;&lt;/a&gt;整数表示&lt;/h2&gt;&lt;p&gt;令$b$为不等于$1$的正整数，那么如果$n$是个正整数，就可以唯一地表示为下面的形式：&lt;br&gt;$$n = a_kb^k+a
    
    </summary>
    
      <category term="Math" scheme="http://blog.freeabyss.com/categories/Math/"/>
    
    
      <category term="Math" scheme="http://blog.freeabyss.com/tags/Math/"/>
    
      <category term="note" scheme="http://blog.freeabyss.com/tags/note/"/>
    
      <category term="Discrete Mathematics" scheme="http://blog.freeabyss.com/tags/Discrete-Mathematics/"/>
    
      <category term="Number Theory" scheme="http://blog.freeabyss.com/tags/Number-Theory/"/>
    
  </entry>
  
</feed>
